!SESSION 2019-03-31 09:29:51.685 -----------------------------------------------
eclipse.buildId=4.5.2.M20160212-1500
java.version=1.8.0_65
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file E:\STO\Java Source\workspace_jse\.metadata\.bak_2.log
Created Time: 2019-03-31 15:09:44.408

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:44.408
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:44.409
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:44.409
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:44.413
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:44.413
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:44.583
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:44.586
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:44.604
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:898)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:767)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:716)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:639)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:631)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:44.607
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:898)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:767)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:716)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:639)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:631)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-31 15:09:46.433
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.sto.utils;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashMap;

import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.stream.ImageOutputStream;

import com.sto.base.PolePositionItems;
import com.sto.base.SharpChgItems;
import com.sto.data.ImgExtractLine;
import com.sto.data.ProductSpec;

public class ImageUtils {
	//Judge Criteria
	private final double minValidRatio = 0.15;//Very depending on the image quality
	private final double minValidRate = 0.7;//Check it in +/-1 line
	private final double maxInvalidRatio = 0.4;//There should be no much white area around the line
	private final double maxSlopeDelta = 0.1;//The lines should be parallel
	private final double minOffsetDelta = 3.0;//There should be some distance between two near line
	private final double maxNoiseRate = 0.4;//There should be no much noise around the line
	private final double maxOffsetChgRate = 1.4;//Check whether some line is missed
	private final double minOffsetChgRate = 0.7;//Check whether there is noise line
	private final int noiseScanRng = 2;//Two sides scanning
	private final int lineScanRange = 6;//One side scanning
	private int targetLinesQty = 16;//The total lines to extract
	private double lineFitGrayThr = 255 * 0.8;
	private final double noiseGrayThr = 255 * 0.9;
	private final double noiseGrayThr2 = 255 * 0.95;
	private final double noiseGrayThr3 = 255 * 0.15;
	private final double minBestRsq = 0.991;
	private final int lineIndexBase = 100;
	private boolean firstPoleIsLonger = false;
	private boolean firstPoleIsThicker = true;
	
	private int[][] finalData = null;
	private boolean logEnabled = true;
	private boolean evenPoleIsLonger = false;
	private long imgProcTime = 0;
	private long imgStartSavingT = 0;
	
	private ProductSpec productSpec = ProductSpec.getInstance();
	private LinkedHashMap<String, Object> criteria = null;
	
	private ArrayList<ImgExtractLine> allPossibleLines = new ArrayList<ImgExtractLine>();
	private ArrayList<ImgExtractLine> allPotentialLines = new ArrayList<ImgExtractLine>();
	private LinkedHashMap<String, Double> imgProcResultLength = new LinkedHashMap<String, Double>();
	private LinkedHashMap<String, Boolean> imgProcResultOK = new LinkedHashMap<String, Boolean>();
	private LinkedHashMap<String, Double> imgProcResultAngle = new LinkedHashMap<String, Double>();
	private LinkedHashMap<String, String> imgProcResultStr = new LinkedHashMap<String, String>();
	
	private void clearMemory(){
		allPossibleLines.clear();
		allPotentialLines.clear();
		imgProcResultLength.clear();
		imgProcResultOK.clear();
		imgProcResultAngle.clear();
	}
	
	public void setLogEnabled(boolean enabled){
		logEnabled = enabled;
	}
	
	public long getImgProcTime(){
		return imgProcTime;
	}
	
	public long getImgStartSavingTime(){
		return imgStartSavingT;
	}
	
	private PolePositionItems getPolePositionInImage(BufferedImage BI){
		PolePositionItems polePosition = PolePositionItems.TOPLEFT;
		int imgWidth = BI.getWidth(), imgHeight = BI.getHeight();
		int[] fourCornersGray = new int[4];
        int pixel = 0, minGray = 0, minGrayIdx = 0;
        
        int start = (int)(imgHeight*0.25), stop = start-10;
        int width = (int)(imgWidth*0.25);
        for(int height=start; height>stop; height--){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[0] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.25); stop = start-10;
        width = (int)(imgWidth*0.75);
        for(int height=start; height>stop; height--){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[1] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.75); stop = start+10;
        width = (int)(imgWidth*0.75);
        for(int height=start; height<stop; height++){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[2] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.75); stop = start+10;
        width = (int)(imgWidth*0.25);
        for(int height=start; height<stop; height++){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[3] += (pixel & 0xffffff - 0xffff00);
        }
		
        minGray = fourCornersGray[0];
        minGrayIdx = 0;
        for(int i=0; i<fourCornersGray.length; i++){
        	if(fourCornersGray[i]<minGray){
        		minGray = fourCornersGray[i];
        		minGrayIdx = i;
        	}
        }
        
        switch(minGrayIdx){
        case 0:
        	polePosition = PolePositionItems.TOPLEFT;
        	break;
        case 1:
        	polePosition = PolePositionItems.TOPRIGHT;
        	break;
        case 2:
        	polePosition = PolePositionItems.BOTTOMRIGHT;
        	break;
        case 3:
        	polePosition = PolePositionItems.BOTTOMLEFT;
        	break;
        }
        
		return polePosition;
	}
	
	private LinkedHashMap<PolePositionItems,Integer> getLayersQty(){
		LinkedHashMap<PolePositionItems,Integer> layers = new LinkedHashMap<PolePositionItems,Integer>();
		
		layers.put(PolePositionItems.BOTTOMRIGHT, 
				Integer.parseInt(""+criteria.get("lowerRightCornerLayers")));
		
		layers.put(PolePositionItems.BOTTOMLEFT, 
				Integer.parseInt(""+criteria.get("lowerLeftCornerLayers")));
		
		layers.put(PolePositionItems.TOPRIGHT, 
				Integer.parseInt(""+criteria.get("topRightCornerLayers")));
		
		layers.put(PolePositionItems.TOPLEFT, 
				Integer.parseInt(""+criteria.get("topLeftCornerLayers")));
		
		return layers;
	}
	
	private void setFirstPoleConfig(){
		String c1 = (String) criteria.get("firstPoleIsShorter");
		String c2 = (String) criteria.get("firstPoleIsThicker");
		
		if(null!=c1) firstPoleIsLonger = (1==Integer.parseInt(c1)?false:true);
		if(null!=c2) firstPoleIsThicker = (1==Integer.parseInt(c2)?true:false);
	}
	
	private ArrayList<Object> edgeFoundParas(BufferedImage BI, PolePositionItems polePosition, double baseFactor, int layersQty, boolean searchWidth, int grapWidthStart, int grapWidthStop
		, int i, int baseAvgPts, int searchStart, int searchStop, int searchPos, int continueCnt1
		, int continueCntThr, int backOffPixels
		, double currGray, double baseGVal, double searchLineFactor, double grapFactor, int[] heightRng
		, ArrayList<Double> slopes, double[] searchParas){
		
		ArrayList<Object> edgeParas = new ArrayList<Object>();
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int edgeStart = 0, edgeStop = 0, maxLen = 0;
        boolean edgeFound = false, forwardSearch = searchStart>searchStop?false:true;
        
		if(currGray<baseGVal){
    		continueCnt1++;
    		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
    			if(searchStart<=i+continueCntThr){
    				searchLineFactor = searchLineFactor*(forwardSearch?0.8:1.25);
    				if(searchWidth){
    					searchStart = (int)(imgWidth*searchLineFactor);
    				}else{
    					searchStart = (int)(imgHeight*searchLineFactor);
    				}
    				if(forwardSearch && searchStart<imgWidth-baseAvgPts || !forwardSearch && searchStart>baseAvgPts){
    					i = searchStart;
    					searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, forwardSearch);
    					baseGVal = searchParas[1] * baseFactor;
    					slopes.clear();
    					slopes.add(searchParas[2]);
        				continueCnt1=0;
    				}
    			}
    			
    			if(forwardSearch){
	    			edgeStart = i + backOffPixels;
	    			if(edgeStart>maxLen) edgeStart = maxLen;
	    			if(searchWidth){
	    				edgeStop = edgeStart - (int)(imgWidth*grapFactor);
	    			}else{
	    				edgeStop = edgeStart - (int)(imgHeight*grapFactor);
	    			}
	    			if(edgeStop<0) edgeStop = 0;
    			}else{
    				edgeStart = i - backOffPixels;
        			if(edgeStart<0) edgeStart = 0;
        			if(searchWidth){
        				edgeStop = edgeStart + (int)(imgWidth*grapFactor);
        			}else{
        				edgeStop = edgeStart + (int)(imgHeight*grapFactor);
        			}
        			if(edgeStop>maxLen) edgeStop = maxLen;
    			}
    			
    			edgeFound = true;
    		}
    		if(searchWidth && currGray<noiseGrayThr3 && null==heightRng){//Already enter the very dark region(almost search to the picture edge)
    			heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
				searchPos = (heightRng[0]+heightRng[1])/2;
				searchStart = (int)(imgWidth*searchLineFactor);
				i = searchStart;
				searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
				baseGVal = searchParas[1] * baseFactor;
				slopes.clear();
				slopes.add(searchParas[2]);
				continueCnt1=0;
    		}
    	}else{
    		baseGVal = searchParas[1] * baseFactor;
    		continueCnt1=0;
    	}
		
		edgeParas.add(0, continueCnt1);
		edgeParas.add(1, searchStart);
		edgeParas.add(2, edgeStart);
		edgeParas.add(3, edgeStop);
		edgeParas.add(4, baseGVal);
		
		return edgeParas;
	}
	
	private int[] getImgProcEdges(BufferedImage BI, PolePositionItems polePosition, double baseFactor, int layersQty, boolean searchWidth, int grapWidthStart, int grapWidthStop){
		int edgeStart = 0, edgeStop = 0, backOffPixels = 50, baseAvgPts = 10, searchPos = 0;
		int continueCnt1 = 0, continueCntThr = 5, maxLen = 0, searchStart = 0, searchStop = 0;
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int[] heightRng = null;
		double baseGVal = 0.0, grapFactor = 0.0, searchLineFactor = 0.0, currGray = 0.0;
		double[] searchParas = null;
		ArrayList<Double> slopes = new ArrayList<Double>();
		ArrayList<Object> edgeParas = null;
		
		if(searchWidth){
			maxLen = imgWidth - 1;
			grapFactor = 0.375;
			if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
	        	searchLineFactor = 0.85;
	        	if(polePosition==PolePositionItems.TOPRIGHT) searchLineFactor = 0.15;
	        	searchPos = (int)(imgHeight*searchLineFactor);
	        	searchStart = baseAvgPts; searchStop = imgWidth-1;
	        	edgeStart = searchStart;
				edgeStop = searchStart + (int)(imgWidth*grapFactor);
			}else{
				searchLineFactor = 0.15;
	        	if(polePosition==PolePositionItems.BOTTOMLEFT) searchLineFactor = 0.85;
	        	searchPos = (int)(imgHeight*searchLineFactor);
	        	searchStart = imgWidth-baseAvgPts; searchStop = 0;
	        	edgeStart = searchStart;
				edgeStop = searchStart - (int)(imgWidth*grapFactor);
			}
		}else{
			maxLen = imgHeight - 1;
			if(layersQty<=8){
				grapFactor = 0.25;
	        }else{
	        	grapFactor = 0.28 / 8.0 * layersQty;
	        }
			
			if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.BOTTOMLEFT){
	        	searchLineFactor = 0.75;
	        	if(polePosition==PolePositionItems.BOTTOMLEFT) searchLineFactor = 0.25;
	        	if(grapWidthStart<0 || grapWidthStop<0){
	        		searchPos = (int)(imgWidth*searchLineFactor);
	        	}else{
	        		searchPos = (grapWidthStart + grapWidthStop)/2;
	        	}
	        	searchStart = baseAvgPts; searchStop = imgHeight-1;
	        	edgeStart = searchStart;
				edgeStop = searchStart + (int)(imgHeight*grapFactor);
			}else{
				searchLineFactor = 0.25;
				if(polePosition==PolePositionItems.TOPRIGHT) searchLineFactor = 0.75;
				if(grapWidthStart<0 || grapWidthStop<0){
	        		searchPos = (int)(imgWidth*searchLineFactor);
	        	}else{
	        		searchPos = (grapWidthStart + grapWidthStop) / 2;
	        	}
	        	searchStart = imgHeight-baseAvgPts; searchStop = 0;
	        	edgeStart = searchStart;
				edgeStop = searchStart - (int)(imgHeight*grapFactor);
			}
		}
		
		searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
		currGray = searchParas[0];
		baseGVal = searchParas[1] * baseFactor;
		slopes.add(searchParas[2]);
		
		if(searchStart>searchStop){
        	for(int i=searchStart; i>=searchStop; i--){
        		searchParas = getEdgeSearchParas(BI, i, baseAvgPts, searchPos, searchWidth, false);
        		currGray = searchParas[0];
        		slopes.add(searchParas[2]);
        		
        		if(currGray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){
            			if(searchStart>=i-continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            				searchLineFactor = searchLineFactor*1.25;
            				if(searchWidth){
            					searchStart = (int)(imgWidth*searchLineFactor);
            				}else{
            					searchStart = (int)(imgHeight*searchLineFactor);
            				}
            				if(searchStart>baseAvgPts){
            					i = searchStart;
            					searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
            					baseGVal = searchParas[1] * baseFactor;
            					slopes.clear();
            					slopes.add(searchParas[2]);
	            				continueCnt1=0;
	            				continue;
            				}
            			}
            			edgeStart = i - backOffPixels;
            			if(edgeStart<0) edgeStart = 0;
            			if(searchWidth){
            				edgeStop = edgeStart + (int)(imgWidth*grapFactor);
            			}else{
            				edgeStop = edgeStart + (int)(imgHeight*grapFactor);
            			}
            			if(edgeStop>maxLen) edgeStop = maxLen;
            			break;
            		}
            		
            		if(searchWidth && currGray<noiseGrayThr3 && null==heightRng){//Already enter the very dark region(almost search to the picture edge)
            			heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
        				searchPos = (heightRng[0]+heightRng[1])/2;
        				searchStart = (int)(imgWidth*searchLineFactor);
        				i = searchStart;
        				searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
    					baseGVal = searchParas[1] * baseFactor;
    					slopes.clear();
    					slopes.add(searchParas[2]);
        				continueCnt1=0; 
        				continue;
            		}
            	}else{
            		baseGVal = searchParas[1] * baseFactor;
            		continueCnt1=0;
            	}
        	}
        }else{
        	for(int i=searchStart; i<=searchStop; i++){
        		searchParas = getEdgeSearchParas(BI, i, baseAvgPts, searchPos, searchWidth, true);
        		currGray = searchParas[0];
        		slopes.add(searchParas[2]);
        		
        		edgeParas = edgeFoundParas(BI, polePosition, baseFactor, layersQty, searchWidth, grapWidthStart, grapWidthStop
        				, i, baseAvgPts, searchStart, searchStop, int searchPos, int continueCnt1
        				, int continueCntThr, int backOffPixels
        				, double currGray, double baseGVal, double searchLineFactor, double grapFactor, int[] heightRng
        				, ArrayList<Double> slopes, double[] searchParas);
        	}
        }
        
		return new int[]{edgeStart, edgeStop};
	}
	
	private double[] getEdgeSearchParas(BufferedImage BI, int currIdx, int baseAvgPts, int searchPos, boolean searchWidth, boolean forwardSearch){
		ArrayList<Integer> xAxis = new ArrayList<Integer>();
		ArrayList<Integer> yAxis = new ArrayList<Integer>();
		int pixel = 0, gray = 0, start = 0, stop = 0, currGray = 0;
		double avgGray = 0.0;
		double[] coef = null;
		
		if(forwardSearch){
			start = currIdx - baseAvgPts + 1; stop = currIdx;
		}else{
			start = currIdx; stop = currIdx + baseAvgPts - 1;
		}
		
		if(searchWidth){
			pixel = BI.getRGB(currIdx, searchPos);
			currGray = (pixel & 0xffffff - 0xffff00);
		}else{
			pixel = BI.getRGB(searchPos, currIdx);
			currGray = (pixel & 0xffffff - 0xffff00);
		}
		
		for(int i=start; i<=stop; i++){
			if(searchWidth){
    			pixel = BI.getRGB(i, searchPos);
            	gray = (pixel & 0xffffff - 0xffff00);
    		}else{
    			pixel = BI.getRGB(searchPos, i);
            	gray = (pixel & 0xffffff - 0xffff00);
    		}
			xAxis.add(i);
			yAxis.add(gray);
			avgGray += gray;
		}
		
		avgGray = avgGray / baseAvgPts;
		coef = MathUtils.lineFitting(xAxis, yAxis);
		
		return new double[]{(double)currGray,avgGray,coef[0]*coef[0]};
	}
	
	private int[] getImgProcWidthRng(BufferedImage BI, PolePositionItems polePosition, int layersQty){
		int[] widthRng = new int[2];
		int[] heightRng = null;
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int grapWidthStart = 0, grapWidthStop = 0, backOffPixels = 50, baseAvgPts = 10;
        int continueCnt1 = 0, start = 0, stop = 0, pixel = 0, gray = 0, continueCntThr = 5;
        double heightFactor = 0.0, widthFactor = 0.0, baseGVal = 0.0, baseFactor = 0.95;
		String strX = "X", strG = "G";
		
        if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
        	heightRng = null;
        	widthFactor = 0.25; heightFactor = 0.85;
        	if(polePosition==PolePositionItems.TOPRIGHT) heightFactor = 0.15;
        	start = (int)(imgWidth*widthFactor); stop = imgWidth-1;
        	int h = (int)(imgHeight*heightFactor);
        	
        	grapWidthStart = start;
			grapWidthStop = grapWidthStart + (int)(imgWidth*0.375);
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start-baseAvgPts; k<start; k++){
	        		pixel = BI.getRGB(k, h);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		widthFactor = widthFactor*0.8;
    				start = (int)(imgWidth*widthFactor);
    				if(start<=baseAvgPts){
    					start = baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int w=start; w<stop; w++){
        		pixel = BI.getRGB(w, h);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strX += "," + w;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){
            			if(start>=w-continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            				widthFactor = widthFactor*0.8;
            				start = (int)(imgWidth*widthFactor);
            				if(start>baseAvgPts){
            					w = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start-baseAvgPts; k<start; k++){
	            	        		pixel = BI.getRGB(k, h);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapWidthStart = w - backOffPixels;
            			if(grapWidthStart<0) grapWidthStart = 0;
            			grapWidthStop = grapWidthStart + (int)(imgWidth*0.375);
            			if(grapWidthStop>=imgWidth) grapWidthStop = imgWidth - 1;
            			break;
            		}
            		if(gray<noiseGrayThr3){//Already enter the very dark region(almost search to the picture edge)
            			if(null!=heightRng){
            				//If the height range is fixed, fixed the width range by guessing
	            			grapWidthStart = (int)(imgWidth*0.75);
	            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
	            			break;
            			}else{
            				heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
            				h = (heightRng[0]+heightRng[1])/2;
            				widthFactor = 0.25;
            				start = (int)(imgWidth*widthFactor);
            				w = start; continueCnt1=0; continue;
            			}
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=w; k>w-baseAvgPts; k--){
                		pixel = BI.getRGB(k, h);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(polePosition==PolePositionItems.TOPLEFT || polePosition==PolePositionItems.BOTTOMLEFT){
        	heightRng = null;
        	widthFactor = 0.75; heightFactor = 0.15;
        	if(polePosition==PolePositionItems.BOTTOMLEFT) heightFactor = 0.85;
        	start = (int)(imgWidth*widthFactor); stop = 0;
        	int h = (int)(imgHeight*heightFactor);
        	
        	grapWidthStart = start;
			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start+baseAvgPts; k>start; k--){
	        		pixel = BI.getRGB(k, h);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		widthFactor = widthFactor*1.25;
    				start = (int)(imgWidth*widthFactor);
    				if(start>=imgWidth-baseAvgPts){
    					start = imgWidth-baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int w=start; w>stop; w--){
        		pixel = BI.getRGB(w, h);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strX += "," + w;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start<=w+continueCntThr){
            				widthFactor = widthFactor*1.25;
            				start = (int)(imgWidth*widthFactor);
            				if(start<imgWidth-baseAvgPts){
            					w = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start+baseAvgPts; k>start; k--){
	            	        		pixel = BI.getRGB(k, h);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapWidthStart = w + backOffPixels;
            			if(grapWidthStart>=imgWidth) grapWidthStart = imgWidth - 1;
            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
            			if(grapWidthStop<0) grapWidthStop = 0;
            			break;
            		}
            		if(gray<noiseGrayThr3){//Already enter the very dark region(almost search to the picture edge)
            			if(null!=heightRng){
            				//If the height range is fixed, fixed the width range by guessing
	            			grapWidthStart = (int)(imgWidth*0.75);
	            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
	            			break;
            			}else{
            				heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
            				h = (heightRng[0]+heightRng[1])/2;
            				widthFactor = 0.75;
            				start = (int)(imgWidth*widthFactor);
            				w = start; continueCnt1=0; continue;
            			}
            		}
            	}else{
            		baseGVal = 0.0;
    	        	for(int k=start; k<start+baseAvgPts; k++){
    	        		pixel = BI.getRGB(k, h);
    	            	gray = (pixel & 0xffffff - 0xffff00);
    	        		baseGVal += gray;
    	        	}
    	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
    	        	
            		continueCnt1=0;
            	}
        	}
        }
		
        if(logEnabled){
        	LogUtils.rawLog("imgProcRegion_", strX);
        	LogUtils.rawLog("imgProcRegion_", strG);
        }
        
        widthRng[0] = grapWidthStart;
        widthRng[1] = grapWidthStop;
		return widthRng;
	}
	
	private int[] getImgProcHeightRng(BufferedImage BI, PolePositionItems polePosition, int layersQty, int grapWidthStart, int grapWidthStop){
		int[] heightRng = new int[2];
		int imgHeight = BI.getHeight();
		int imgWidth = BI.getWidth();
        int grapHeightStart = 0, grapHeightStop = 0, backOffPixels = 30, baseAvgPts = 10;
        int width = 0, continueCnt1 = 0, start = 0, stop = 0, pixel = 0, gray = 0, continueCntThr = 5;
        double heightFactor = 0.0, grapHeightFactor = 0.5, baseGVal = 0.0, baseFactor = 0.95;
        String strY = "Y", strG = "G";
        
        if(layersQty<=8){
        	grapHeightFactor = 0.25;
        }else{
        	grapHeightFactor = 0.28 / 8.0 * layersQty;
        }
		
        if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.BOTTOMLEFT){
        	heightFactor = 0.375;
        	start = (int)(imgHeight*heightFactor); stop = imgHeight-1;
        	
        	grapHeightStart = start;
			grapHeightStop = grapHeightStart + (int)(imgHeight*grapHeightFactor);
        	
        	if(grapWidthStart<0 || grapWidthStop<0){
        		if(polePosition==PolePositionItems.BOTTOMRIGHT) width = (int)(imgWidth*0.75);
        		if(polePosition==PolePositionItems.BOTTOMLEFT) width = (int)(imgWidth*0.25);
        	}else{
        		width = (grapWidthStart + grapWidthStop)/2;
        	}
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start-baseAvgPts; k<start; k++){
	        		pixel = BI.getRGB(width, k);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		heightFactor = heightFactor*0.8;
    				start = (int)(imgHeight*heightFactor);
    				if(start<=baseAvgPts){
    					start = baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int height=start; height<stop; height++){
        		pixel = BI.getRGB(width, height);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strY += "," + height;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start>=height-continueCntThr){
            				heightFactor = heightFactor*0.8;
            				start = (int)(imgHeight*heightFactor);
            				if(start>baseAvgPts){
            					height = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start-baseAvgPts; k<start; k++){
	            	        		pixel = BI.getRGB(width, k);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapHeightStart = height - backOffPixels;
            			if(grapHeightStart<0) grapHeightStart = 0;
            			grapHeightStop = grapHeightStart + (int)(imgHeight*grapHeightFactor);
            			if(grapHeightStop >= imgHeight){
            				grapHeightStart = grapHeightStart - (grapHeightStop-imgHeight);
            				grapHeightStop = imgHeight - 1;
            			}
            			break;
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=start; k>start-baseAvgPts; k--){
                		pixel = BI.getRGB(width, k);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(polePosition==PolePositionItems.TOPRIGHT || polePosition==PolePositionItems.TOPLEFT){
        	heightFactor = 0.625;
        	start = (int)(imgHeight*heightFactor); stop = 0;
        	
        	grapHeightStart = start;
			grapHeightStop = grapHeightStart - (int)(imgHeight*grapHeightFactor);
        	
        	if(grapWidthStart<0 || grapWidthStop<0){
        		if(polePosition==PolePositionItems.TOPRIGHT) width = (int)(imgWidth*0.75);
        		if(polePosition==PolePositionItems.TOPLEFT) width = (int)(imgWidth*0.25);
        	}else{
        		width = (grapWidthStart + grapWidthStop) / 2;
        	}
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start+baseAvgPts; k>start; k--){
	        		pixel = BI.getRGB(width, k);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		heightFactor = heightFactor*1.25;
    				start = (int)(imgHeight*heightFactor);
    				if(start>=imgHeight-baseAvgPts){
    					start = imgHeight - baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int height=start; height>stop; height--){
        		pixel = BI.getRGB(width, height);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strY += "," + height;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start<=height+continueCntThr){
            				heightFactor = heightFactor*1.25;
            				start = (int)(imgHeight*heightFactor);
            				if(start<imgHeight-baseAvgPts){
            					height = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start+baseAvgPts; k>start; k--){
	            	        		pixel = BI.getRGB(width, k);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapHeightStart = height + backOffPixels;
            			if(grapHeightStart>=imgHeight) grapHeightStart = imgHeight - 1;
            			grapHeightStop = grapHeightStart - (int)(imgHeight*grapHeightFactor);
            			if(grapHeightStop<0){
            				grapHeightStart = grapHeightStart - grapHeightStop;
            				grapHeightStop = 0;
            			}
            			break;
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=start; k<start+baseAvgPts; k++){
                		pixel = BI.getRGB(width, k);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(logEnabled){
        	LogUtils.rawLog("imgProcRegion_", strY);
        	LogUtils.rawLog("imgProcRegion_", strG);
        }
        
        heightRng[0] = grapHeightStart;
        heightRng[1] = grapHeightStop;
		return heightRng;
	}
	
	private int[] getImageProcRegion(BufferedImage BI, PolePositionItems polePosition, int layersQty){
		int[] grapImgStart = new int[4];
		int[] grapImgWidthRng = null, grapImgHeightRng = null;
		
		grapImgWidthRng = getImgProcWidthRng(BI,polePosition,layersQty);
		grapImgHeightRng = getImgProcHeightRng(BI,polePosition,layersQty,grapImgWidthRng[0],grapImgWidthRng[1]);
		
        grapImgStart[0] = grapImgHeightRng[0];
        grapImgStart[1] = grapImgHeightRng[1];
        grapImgStart[2] = grapImgWidthRng[0];
        grapImgStart[3] = grapImgWidthRng[1];
        
		return grapImgStart;
	}
	
	public boolean procImage(String imgRootDir, String imgFileName, boolean outImg, String specifiedSpec){
		boolean imgPassed = false;
		
        try {
			imgPassed = procImageEx(imgRootDir, imgFileName, outImg, specifiedSpec);
			clearMemory();
		} catch (Exception e) {
			LogUtils.errorLog("Process "+imgRootDir+File.separator+imgFileName+" error:"+e.getMessage());
		}
        
        return imgPassed;
	}
	
	private boolean procImageEx(String imgRootDir, String imgFileName, boolean outImg, String specifiedSpec){
		String src = imgRootDir + File.separator + imgFileName;
		criteria = productSpec.getData(imgRootDir);
		if(null==criteria){
			if(null!=specifiedSpec && !"".equals(specifiedSpec.trim())) criteria = productSpec.getData(specifiedSpec);
			if(null==criteria){
				System.out.println("Product Spec for "+imgRootDir+" is not set yet!");
				return false;
			}
		}
		
		long startProcTime = System.currentTimeMillis();
		File file = new File(src);
        BufferedImage BI = null;
        try{
            BI = ImageIO.read(file);
            if(null==BI){
            	System.out.println("Read "+src+" failed");
            	return false;
            }
        }catch(Exception e){
            e.printStackTrace();
            return false;
        }
        
        int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int grapHeightStart = 0, grapHeightStop = 0, grapHeight = 0;
        int grapWidthStart = 0, grapWidthStop = 0, grapWidth = 0;
        int[][] imgGrays = null, initVals = null, peakVals = null;
        int pixel = 0, gray = 0;
        
        PolePositionItems polePosition = getPolePositionInImage(BI);
        System.out.println("Pole Position:"+polePosition);
        
        LinkedHashMap<PolePositionItems,Integer> layers = getLayersQty();
        targetLinesQty = layers.get(polePosition)*2;
        if(targetLinesQty<=0) return false;
        LogUtils.clearLog(true);
        
        int[] imgProcRegion = getImageProcRegion(BI,polePosition,targetLinesQty/2);
        grapHeightStart = imgProcRegion[0]; grapHeightStop = imgProcRegion[1];
        grapWidthStart = imgProcRegion[2]; grapWidthStop = imgProcRegion[3];
        grapHeight = Math.abs(grapHeightStart-grapHeightStop);
        grapWidth = Math.abs(grapWidthStart-grapWidthStop);
        imgGrays = new int[grapWidth][grapHeight];
    	initVals = new int[imgGrays.length][imgGrays[0].length];
    	
    	if(grapWidthStop > grapWidthStart){
    		if(grapHeightStop > grapHeightStart){
    			//Bottom-right
    			for(int i=grapWidthStart; i<grapWidthStop; i++){
            		for(int j=grapHeightStart; j<grapHeightStop; j++){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[i-grapWidthStart][j-grapHeightStart] = gray;
            			initVals[i-grapWidthStart][j-grapHeightStart] = 255;
            		}
            	}
    		}else{
    			//Top-right
    			for(int i=grapWidthStart; i<grapWidthStop; i++){
            		for(int j=grapHeightStart; j>grapHeightStop; j--){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[i-grapWidthStart][grapHeightStart-j] = gray;
            			initVals[i-grapWidthStart][grapHeightStart-j] = 255;
            		}
            	}
    		}
    	}else{
    		if(grapHeightStop < grapHeightStart){
    			//Top-left
    			for(int i=grapWidthStart; i>grapWidthStop; i--){
            		for(int j=grapHeightStart; j>grapHeightStop; j--){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[grapWidthStart-i][grapHeightStart-j] = gray;
            			initVals[grapWidthStart-i][grapHeightStart-j] = 255;
            		}
            	}
    		}else{
    			//Bottom-left
    			for(int i=grapWidthStart; i>grapWidthStop; i--){
            		for(int j=grapHeightStart; j<grapHeightStop; j++){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[grapWidthStart-i][j-grapHeightStart] = gray;
            			initVals[grapWidthStart-i][j-grapHeightStart] = 255;
            		}
            	}
    		}
    	}
    	
        //Start image processing
        boolean imgPassed = false;
        allPossibleLines.clear();
        allPotentialLines.clear();
        imgProcResultLength.clear();
        imgProcResultOK.clear();
        imgProcResultAngle.clear();
        if(null!=imgGrays){
        	peakVals = getPeakVals(imgGrays,initVals);
            if(null!=peakVals){
            	setFirstPoleConfig();
            	ImgExtractLine baseLine = getBaseLine(peakVals,initVals,imgGrays,255);
            	if(null!=baseLine && baseLine.getLineRSQ()>0){
            		ArrayList<ImgExtractLine> extractLines = searchLines(peakVals,initVals,imgGrays,255,baseLine);
            		if(extractLines.size()>0){
            			imgPassed = checkLines(peakVals,initVals,imgGrays,255,baseLine,extractLines);
            		}
            	}else{
            		System.out.println("getBaseLine failed");
            	}
            }
        }
        
        //Save output image
        if(outImg){
        	BI = createBufferedImage(BI);
        	if(null!=finalData && finalData.length>0){
        		int realX = 0, realY = 0;
        		int firstLen = finalData.length, secondLen = finalData[0].length;
        		for(int i=0; i<firstLen; i++){
        			if(grapWidthStart>grapWidthStop){
    					realX = grapWidthStart - i;
    				}else{
    					realX = grapWidthStart + i;
    				}
        			
        			for(int j=0; j<secondLen; j++){
        				if(grapHeightStart>grapHeightStop){
        					realY = grapHeightStart - j;
        				}else{
        					realY = grapHeightStart + j;
        				}
        				
        				if(finalData[i][j]<255){
        					pixel = BI.getRGB(realX, realY);
        					if(4==finalData[i][j]){
        						BI.setRGB(realX, realY, Color.RED.getRGB());
        					}else{
        						if(evenPoleIsLonger && 0==finalData[i][j]%2 || !evenPoleIsLonger && 1==finalData[i][j]%2){
        							BI.setRGB(realX, realY, Color.ORANGE.getRGB());
        						}else{
        							BI.setRGB(realX, realY, Color.BLACK.getRGB());
        						}
        					}
        				}
        			}
        		}
        	}
        	
	        Iterator<ImageWriter> it = ImageIO.getImageWritersByFormatName("png");//
	        ImageWriter writer = it.next();
	        ImageOutputStream ios;
			try {
				writeProcResultInfo(imgFileName,BI,polePosition,imgPassed,imgWidth,imgHeight,startProcTime);
				if(imgPassed){
					ios = ImageIO.createImageOutputStream(new File(src+".OK.png"));
				}else{
					ios = ImageIO.createImageOutputStream(new File(src+".NG.png"));
				}
				writer.setOutput(ios);
		        writer.write(BI);
		        BI.flush();
		        ios.flush();
		        ios.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
        }
        
        String[] imgProcRslt = getImgProcRsltData(imgFileName);
        imgProcRslt[0] = imgProcRslt[0]+",imgSavingT(ms)";
        imgProcRslt[1] = imgProcRslt[1]+","+(System.currentTimeMillis()-getImgStartSavingTime());
        setImgProcRsltData(imgFileName,imgProcRslt[0],imgProcRslt[1]);
        
        return imgPassed;
	}
	
	private BufferedImage createBufferedImage(BufferedImage baseBI){
		int width = baseBI.getWidth();
		int height = baseBI.getHeight();
		
		BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
        bi.getGraphics().drawImage(baseBI, 0, 0,width, height, null);
        baseBI = null;
        
        return bi;
	}
	
	private void writeProcResultInfo(String imgFileName, BufferedImage BI, PolePositionItems polePosition, boolean imgPassed, int imgWidth, int imgHeight, long startProcTime){
		int txtX = 0, txtY = 0, txtOffset = 25, txtLine = 0, oriY = 0;
		double minL = 1000.0, maxL = -1000.0, curL = 0.0;
		String lenInfo = "", procRsltTitle = "", procRsltData = "";
		DecimalFormat df = new DecimalFormat("0.000");
		DecimalFormat df1 = new DecimalFormat("0.0");
		Graphics g = BI.getGraphics();
		g.setFont(new Font("Serif",Font.BOLD,54));
		g.setColor(imgPassed?Color.DARK_GRAY:Color.RED);
		if(polePosition==PolePositionItems.TOPLEFT || polePosition==PolePositionItems.BOTTOMLEFT){
			txtX = (int)(imgWidth*0.75);
			txtY = (int)(imgHeight*0.25);
		}else if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
			txtX = (int)(imgWidth*0.15);
			txtY = (int)(imgHeight*0.25);
		}
		oriY = txtY;
		
		g.drawString(imgPassed?"OK":"NG", txtX, txtY);
		g.setFont(new Font("Serif",Font.BOLD,18));
		txtLine = 3;
		txtY += txtOffset * txtLine;
		for(String key:imgProcResultLength.keySet()){
			txtY += txtOffset;
			curL = imgProcResultLength.get(key);
			lenInfo = key+" = "+df.format(curL);
			procRsltTitle += ","+key;
			procRsltData += ","+df.format(curL);
			
			if(null!=imgProcResultAngle.get(key)){
				lenInfo += " ["+df1.format(imgProcResultAngle.get(key))+"deg]";
			}
			
			if(imgProcResultOK.get(key)){
				g.setColor(Color.DARK_GRAY);
			}else{
				g.setColor(Color.RED);
			}
			g.drawString(lenInfo, txtX, txtY);
			if(minL>curL) minL = curL;
			if(maxL<curL) maxL = curL;
		}
		imgStartSavingT = System.currentTimeMillis();
		imgProcTime = imgStartSavingT-startProcTime;
		g.setColor(Color.DARK_GRAY);
		g.drawString("PRO_T = "+imgProcTime+" ms", txtX, oriY+txtOffset);
		g.drawString("MIN_L = "+df.format(minL)+" mm", txtX, oriY+txtOffset*2);
		g.drawString("MAX_L = "+df.format(maxL)+" mm", txtX, oriY+txtOffset*3);
		
		procRsltTitle = "procT(ms),MIN_L,MAX_L"+procRsltTitle;
		procRsltData = imgProcTime+","+df.format(minL)+","+df.format(maxL)+procRsltData;
		setImgProcRsltData(imgFileName,procRsltTitle,procRsltData);
	}
	
	public void clearImgProcRsltData(String imgFileName){
		imgProcResultStr.remove(imgFileName);
	}
	
	private void setImgProcRsltData(String imgFileName, String rsltTitle, String rsltData){
		imgProcResultStr.put(imgFileName, rsltTitle+"\r\n"+rsltData);
	}
	
	public String[] getImgProcRsltData(String imgFileName){
		String[] rsltStr = new String[]{"",""};
		String rslt = imgProcResultStr.get(imgFileName);
		if(null!=rslt) rsltStr = rslt.split("\r\n");
		return rsltStr;
	}
	
	private ArrayList<Object> getLinesTendencyParas(ArrayList<ImgExtractLine> extractLines, LinkedHashMap<Integer,ImgExtractLine> linesMap, int targetLinesQty){
		ArrayList<Object> tdcParas = new ArrayList<Object>();
		double[] coef = null, slope = null, offset = null;
		int reliableMaxIdx = 0, evenPoleCnt = 0, oddPoleCnt = 0;
		double evenPoleAvgOffset = 0.0, oddPoleAvgOffset = 0.0, finalRsq = 0.0;
		double evenMinOffset = 0.0, evenMaxOffset = 0.0, oddMinOffset = 0.0, oddMaxOffset = 0.0, curOffset = 0.0;
		
		LinkedHashMap<Double,Double> tendencyDt = new LinkedHashMap<Double,Double>();
		ArrayList<Double> tdcSlope = new ArrayList<Double>();
		ArrayList<Double> tdcOffset = new ArrayList<Double>();
		ArrayList<Double> tdcRsq = new ArrayList<Double>();
		
		if(null!=extractLines && extractLines.size()>0){
			if(null==linesMap){
				linesMap = new LinkedHashMap<Integer,ImgExtractLine>();
			}else if(!linesMap.isEmpty()){
				linesMap.clear();
			}
			
			for(int i=0; i<extractLines.size(); i++){
				if(i<targetLinesQty){
					linesMap.put(i, extractLines.get(i));
					tendencyDt.put((double)i, extractLines.get(i).getLineIntercept());
					if(i<2){
						tdcSlope.add(i,0.0);
						tdcOffset.add(i,0.0);
						tdcRsq.add(i,1.0);
						reliableMaxIdx = i;
					}else{
						coef = MathUtils.lineFitting(tendencyDt);
						tdcSlope.add(i,coef[0]);
						tdcOffset.add(i,coef[1]);
						tdcRsq.add(i,coef[2]);
						if(coef[2]>minBestRsq){
							reliableMaxIdx = i;
							finalRsq = coef[2];
						}
					}
				}else{
					break;
				}
			}
			
			//Recalculate the tendency
			if(reliableMaxIdx>5 && tdcRsq.get(reliableMaxIdx) < minBestRsq){
				LinkedHashMap<Double,Double> fittingDt = new LinkedHashMap<Double,Double>();
				for(int i=1; i<=reliableMaxIdx; i++){
					fittingDt.put((double)i, extractLines.get(i).getLineIntercept());
				}
				coef = MathUtils.lineFitting(fittingDt);
				finalRsq = coef[2];
			}
			
			//Calculate average offset of even & odd pole to its previous most-closed pole
			evenPoleAvgOffset=0.0; oddPoleAvgOffset=0.0;
			for(int i=1; i<=reliableMaxIdx; i++){
				curOffset = linesMap.get(i).getLineIntercept() - linesMap.get(i-1).getLineIntercept();
				if(0==i%2){
					evenPoleCnt++;
					evenPoleAvgOffset += curOffset;
					if(1==evenPoleCnt){
						evenMinOffset = curOffset; evenMaxOffset = curOffset;
					}else{
						if(evenMinOffset>curOffset) evenMinOffset = curOffset;
						if(evenMaxOffset<curOffset) evenMaxOffset = curOffset;
					}
				}else{
					oddPoleCnt++;
					oddPoleAvgOffset += curOffset;
					if(1==oddPoleCnt){
						oddMinOffset = curOffset; oddMaxOffset = curOffset;
					}else{
						if(oddMinOffset>curOffset) oddMinOffset = curOffset;
						if(oddMaxOffset<curOffset) oddMaxOffset = curOffset;
					}
				}
			}
			evenPoleAvgOffset = (evenPoleCnt>2)?(evenPoleAvgOffset-evenMinOffset-evenMaxOffset) / (evenPoleCnt-2):evenPoleAvgOffset / evenPoleCnt;
			oddPoleAvgOffset = (oddPoleCnt>2)?(oddPoleAvgOffset-oddMinOffset-oddMaxOffset) / (oddPoleCnt-2):oddPoleAvgOffset / oddPoleCnt;
		}
		
		tdcParas.add(0,finalRsq);
		tdcParas.add(1,evenPoleAvgOffset);
		tdcParas.add(2,oddPoleAvgOffset);
		tdcParas.add(3,reliableMaxIdx);
		if(tdcSlope.size()>0){
			slope = new double[tdcSlope.size()];
			offset = new double[tdcOffset.size()];
			for(int i=0; i<tdcSlope.size(); i++){
				slope[i] = tdcSlope.get(i);
				offset[i] = tdcOffset.get(i);
			}
		}
		tdcParas.add(4,slope);
		tdcParas.add(5,offset);
		
		return tdcParas;
	}
	
	private boolean checkLines(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, ImgExtractLine myBaseline, ArrayList<ImgExtractLine> extractLines){
		boolean bPassed = false;
		int extLinesQty = 0, bestRsqIdx = 0;
		double oddPoleAvgOffset = 0.0, evenPoleAvgOffset = 0.0;
		double[] slope = null, offset = null;
		
		LinkedHashMap<Integer,ImgExtractLine> linesMap = new LinkedHashMap<Integer,ImgExtractLine>();
		ArrayList<Object> tdcParas = null;
		
		extLinesQty = extractLines.size();
		if(extLinesQty>3){
			tdcParas = getLinesTendencyParas(extractLines, linesMap, targetLinesQty);
			if((double)tdcParas.get(0)<minBestRsq){
				System.out.println("RSQ NG:"+(double)tdcParas.get(0)+"(<"+minBestRsq+")");
				return bPassed;
			}
			evenPoleAvgOffset = (double)tdcParas.get(1);
			oddPoleAvgOffset = (double)tdcParas.get(2);
			bestRsqIdx = (int)tdcParas.get(3);
			slope = (double[]) tdcParas.get(4);
			offset = (double[]) tdcParas.get(5);
			
			//Recalculate the missing lines
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,false);
			}
			
			//Double check all lines
			evenPoleIsLonger = evenLineIsLonger(linesMap,imgGrays);
			System.out.println("bestIdx/evenOffset/oddOffset:"+bestRsqIdx
					+"/"+evenPoleAvgOffset+"/"+oddPoleAvgOffset
					+"/"+((currToLastOffsetDeltaIsBigger(2,evenPoleIsLonger)?
							((evenPoleAvgOffset>oddPoleAvgOffset)?"Correct":"Wrong"):
							((evenPoleAvgOffset<oddPoleAvgOffset)?"Correct":"Wrong"))));
			
			//Check one more layer inside if the first layer is longer
			if(evenPoleIsLonger && !firstPoleIsLonger){
				targetLinesQty = targetLinesQty + 1;
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,true);
			}
			
			//Compensate the longer layers
			linesMap = adjustLongerLines(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty,true);
			
			//Adjust all layers' index
			linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,true);
				linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			}
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = addMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
				linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			}
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = addMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
			}
			
			//Set all lines sharp change position
			linesMap = adjustLongerLines(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty,true);
			setLinesSharpChgPosition(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty);
			
			//Calculate the final result
			twoNearLayersOffsetCorrect(linesMap,evenPoleIsLonger);
			setLongerPolesLength(linesMap,imgGrays,peakVals,evenPoleIsLonger,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
			bPassed = calculateFinalResult(linesMap,evenPoleIsLonger,imgGrays,defaultVal,targetLinesQty,peakVals,evenPoleAvgOffset,oddPoleAvgOffset);
		}else{
			System.out.println("Extract Lines Qty:"+extractLines.size()+" is NG");
		}
		
		saveImgData("graysFinalLines_",finalData);
		System.out.println("Proc Result:"+(bPassed?"OK":"NG"));
		return bPassed;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> adjustLongerLines(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, int targetLinesQty, boolean bNotSetInterceptDelta){
		double[] weightOfLine = null;
		for(int lineIdx=0; lineIdx<targetLinesQty; lineIdx++){
			ImgExtractLine exLine = oriLinesMap.get(lineIdx);
			if(null!=exLine && 0==exLine.getXAxisStart()){
				exLine = setLineBoundary(exLine, imgGrays, 255);
				oriLinesMap.put(lineIdx, exLine);
			}
			
			if(curLineIsLonger(lineIdx,evenLineLonger)){
				if(null!=exLine){
					weightOfLine = exLine.weightOfBeingLine(oriLinesMap, exLine.getXAxisStop(), exLine.getXAxisStart(), 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, bNotSetInterceptDelta, curLineIsLonger(lineIdx,evenLineLonger), false);
					oriLinesMap.put(lineIdx, exLine);
					if(weightOfLine[0]<0.5) System.out.println("Weight of line("+lineIdx+"):"+weightOfLine[0]);
				}
			}
		}
		
		return oriLinesMap;
	}
	
	private int[] getPolePosX(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger, int targetLinesQty){
		double xPositionSum1 = 0.0, xPositionSum2 = 0.0;
		int counter1 = 0, counter2 = 0;
		int[] polePosX = new int[]{-1,-1};
		ImgExtractLine exLine = null;
		for(int lineIdx=0; lineIdx<targetLinesQty; lineIdx++){
			exLine = linesMap.get(lineIdx);
			if(null==exLine) continue;
			if(curLineIsLonger(lineIdx,evenLineLonger)){
				xPositionSum1 += exLine.getXAxisStop();
				counter1++;
			}else{
				xPositionSum2 += exLine.getXAxisStart();
				counter2++;
			}
		}
		if(counter1>0) polePosX[0] = (int)(xPositionSum1/counter1);
		if(counter2>0) polePosX[1] = (int)(xPositionSum2/counter2);
		return polePosX;
	}
	
	private boolean twoNearLayersOffsetCorrect(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger){
		boolean correct = true;
		ImgExtractLine currLine = null, lastLine = null;
		double evenPoleOffsetSum = 0.0, oddPoleOffsetSum = 0.0, offsetDelta = 0.0;
		double evenPoleAvgOffset = 0.0, oddPoleAvgOffset = 0.0;
		int evenPoleCnt = 0, oddPoleCnt = 0;
		
		for(Integer idx:linesMap.keySet()){
			currLine = linesMap.get(idx);
			lastLine = linesMap.get(idx-1);
			
			if(null!=currLine && null!=lastLine){
				offsetDelta = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				offsetDelta = offsetDelta-lastLine.getLineIntercept()-lastLine.getLineInterceptDelta();
				if(0==idx%2){
					evenPoleOffsetSum += offsetDelta;
					evenPoleCnt++;
				}else{
					oddPoleOffsetSum += offsetDelta;
					oddPoleCnt++;
				}
			}
		}
		if(evenPoleCnt>0) evenPoleAvgOffset=evenPoleOffsetSum/evenPoleCnt;
		if(oddPoleCnt>0) oddPoleAvgOffset=oddPoleOffsetSum/oddPoleCnt;
		correct = ((currToLastOffsetDeltaIsBigger(2,evenLineLonger)?
				((evenPoleAvgOffset>oddPoleAvgOffset)?true:false):
				((evenPoleAvgOffset<oddPoleAvgOffset)?true:false)));
		
		System.out.println("evenPoleAvgOffset/oddPoleAvgOffset:"
				+"/"+evenPoleAvgOffset+"/"+oddPoleAvgOffset
				+"/"+(correct?"Correct":"Wrong"));
		
		return correct;
	}
	
	private void setLongerPolesLength(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty){
		//Check the logic carefully
		int imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		int[][] tmpGrays = new int[imgWidth][imgHeight];
		for(int k=0; k<imgWidth; k++){
			tmpGrays[k] = imgGrays[k].clone();
		}
		double tmpSlope = 0.0, tmpOffset = 0.0, poleLength = 0.0;
		double oriSlope = tmpSlope, oriOffset = tmpOffset;
		double maxDnChkOffset = 0.0;
		boolean curLinePassed = false;
		int newXAxisStop = -1, wrinkleLineMaxOffset = 0;
		ImgExtractLine tmpLine = null, exLine = null;
		int[] polePosX = getPolePosX(linesMap,evenLineLonger,targetLinesQty);
		if(polePosX[0]<0 || polePosX[1]<0) return;
		
		int refPos = 0, minIdx = -1, oriCol = 0;
		int stopChkPos = 0, nearCol = 0, defaultVal = 255, lineFlag = 0;
		
		double maxPoleAngle = Double.parseDouble(""+criteria.get("maxPoleAngle"));
		double onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		double minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		double maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		
		for(int i=0; i<targetLinesQty; i++){
			if(i>=linesMap.size() || i>=10) break;
			if(!curLineIsLonger(i,evenLineLonger)) continue;
			exLine = linesMap.get(i);
			if(null==exLine || null==linesMap.get(i+1) || null==linesMap.get(i-1)) continue;
			if(i>0 && linesMap.get(i-1).getXAxisStart()-exLine.getXAxisStop()<minDistance) continue;
			if(i+1<linesMap.size() && linesMap.get(i+1).getXAxisStart()-exLine.getXAxisStop()<minDistance) continue;
			refPos = exLine.getXAxisStop();
			if(refPos-polePosX[0]<5) continue;
			
			curLinePassed = false;
			lineFlag = exLine.getLineFlag();
			tmpSlope = exLine.getLineSlope();
			tmpOffset = exLine.getLineIntercept();
			oriSlope = tmpSlope; oriOffset = tmpOffset;
			wrinkleLineMaxOffset = (int)(evenPoleAvgOffset+oddPoleAvgOffset)/2;
			maxDnChkOffset = (evenPoleAvgOffset+oddPoleAvgOffset)/2;
			
			tmpLine = exLine;
			if(null!=linesMap.get(i+2)){
				maxDnChkOffset = linesMap.get(i+2).getLineIntercept()+linesMap.get(i+2).getLineInterceptDelta();
				maxDnChkOffset = maxDnChkOffset - tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
			}else{
				maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i+1).getLineIntercept()-linesMap.get(i+1).getLineInterceptDelta();
				maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
			}
			
			minIdx = -1;
			stopChkPos = refPos - (int)maxDistance;
			if(stopChkPos<0) stopChkPos = 0;
			
			//Check down side
			LinkedHashMap<Double,Double> dnSideWrinkleLine = new LinkedHashMap<Double,Double>();
			dnSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,refPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
			
			double[] dnLineParas = null;
			double dnSideAngle = 0.0;
			if(dnSideWrinkleLine.size()>=5){
				dnLineParas = MathUtils.lineFitting(dnSideWrinkleLine);
				dnSideAngle = 90.0;
				if(-1!=tmpSlope*dnLineParas[0]){
					dnSideAngle = Math.abs((tmpSlope-dnLineParas[0])/(1+tmpSlope*dnLineParas[0]));
					dnSideAngle = Math.toDegrees(Math.atan(dnSideAngle));
				}
			}else{
				continue;
			}
			
			if(dnSideAngle>0){
				if(dnSideAngle<=maxPoleAngle){
					storeLayerAngle(evenLineLonger, i, dnSideAngle, 0);
					minIdx = imgWidth;
					for(double k:dnSideWrinkleLine.keySet()){
						if(k<minIdx) minIdx=(int)k;
					}
					newXAxisStop = minIdx;
					for(int k=refPos; k>=minIdx; k--){
						nearCol = (int)(k*tmpSlope+tmpOffset);
						for(int n=(int)maxDnChkOffset;n>0;n--){
							if(nearCol+n>=0 && nearCol+n<imgHeight){
								if(imgGrays[k][nearCol+n]<defaultVal){
									if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
										tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
									}
								}
							}
						}
					}
				}else{
					newXAxisStop = (int)((tmpOffset-dnLineParas[1])/(dnLineParas[0]-tmpSlope));
				}
			}
			
			if(newXAxisStop>=0){
				tmpLine.setXAxisStop(newXAxisStop);
				if(tmpLine.getXAxisStart()<newXAxisStop) tmpLine.setXAxisStart(newXAxisStop);
				tmpLine.setPolePosition(newXAxisStop);
				if(curLineIsLonger(i,evenLineLonger)){
					linesMap.put(i, tmpLine);
				}else{
					linesMap.put(i-1, tmpLine);
				}
				
				poleLength = linesMap.get(i-1).getXAxisStart()-tmpLine.getXAxisStop();
				if(poleLength>=minDistance && poleLength<=maxDistance) curLinePassed = true;
				
				if(!curLinePassed){
					lineFlag = 4;
				}else{
					lineFlag = lineIndexBase + i;
				}
				if(null!=dnLineParas && dnSideAngle<=maxPoleAngle){
					tmpSlope = dnLineParas[0];
					tmpOffset = dnLineParas[1];
					tmpLine.setCrossX(refPos);
					for(int k=newXAxisStop; k<=refPos; k++){
						nearCol = (int)(k*tmpSlope+tmpOffset);
						oriCol = (int)(k*oriSlope+oriOffset);
						if(nearCol<oriCol) nearCol = oriCol;
						if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
					}
				}
			}
		}
	}
	
	private boolean curLineIsLonger(int lineIdx, boolean evenLineLonger){
		boolean curLineLonger = false;
		if(0==lineIdx%2 && evenLineLonger || 1==lineIdx%2 && !evenLineLonger) curLineLonger = true;
		return curLineLonger;
	}
	
	private boolean currToLastOffsetDeltaIsBigger(int lineIdx, boolean evenLineLonger){
		boolean bigger = false;
		
		if(0==lineIdx%2 && firstPoleIsThicker || 1==lineIdx%2 && !firstPoleIsThicker){
			if(firstPoleIsLonger && evenLineLonger 
				|| !firstPoleIsLonger && !evenLineLonger) bigger=true;
		}
		
		return bigger;
	}
	
	private int[] getWeightChkRange(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap,LinkedHashMap<Integer, ImgExtractLine> newLinesMap,int oriLineIdx,int newLineIdx){
		int[] chkRange = new int[2];
		//Get the max range(Max start and Min stop) of the near three lines
		ImgExtractLine curLine = oriLinesMap.get(oriLineIdx);
		ImgExtractLine lastLine = newLinesMap.get(newLineIdx-1);
		ImgExtractLine nextLine = oriLinesMap.get(oriLineIdx+1);
		
		chkRange[0] = curLine.getXAxisStart();
		chkRange[1] = curLine.getXAxisStop();
		if(null!=lastLine){
			if(lastLine.getXAxisStart()>chkRange[0]) chkRange[0] = lastLine.getXAxisStart();
			if(lastLine.getXAxisStop()<chkRange[1]) chkRange[1] = lastLine.getXAxisStop();
		}
		if(null!=nextLine){
			if(nextLine.getXAxisStart()>chkRange[0]) chkRange[0] = nextLine.getXAxisStart();
			if(nextLine.getXAxisStop()<chkRange[1]) chkRange[1] = nextLine.getXAxisStop();
		}
		
		return chkRange;
	}
	
	private int[] shiftLineIndex(int[] oriLineIdx,int startIdx,int stopIdx,int shiftVal){
		int start = 0, stop = 0, baseVal = 0;
		if(startIdx<0) startIdx = 0;
		if(startIdx>=oriLineIdx.length) startIdx = oriLineIdx.length - 1;
		if(stopIdx<0) stopIdx = 0;
		if(stopIdx>=oriLineIdx.length) stopIdx = oriLineIdx.length - 1;
		
		if(startIdx>stopIdx){
			start = stopIdx;
			stop = startIdx;
		}else{
			start = startIdx;
			stop = stopIdx;
		}
		
		if(shiftVal<0){
			for(int k=start;k<=stop;k++){
				oriLineIdx[k] = oriLineIdx[k] + shiftVal;
			}
		}else{
			baseVal = oriLineIdx[start];
			for(int k=start;k<=stop;k++){
				baseVal = baseVal + shiftVal;
				if(oriLineIdx[k]<baseVal) oriLineIdx[k] = oriLineIdx[k] + shiftVal;
			}
		}
		
		return oriLineIdx;
	}
	
	private int shiftCurrentLineNext(ImgExtractLine currLine, ImgExtractLine lastLine, ImgExtractLine nextLine, int currLineIdx, int targetLinesQty, 
										double[] weightCurLine, double[] weightLastLine, double[] weightNextLine, boolean curLineIsLonger, int[][] imgGrays,
										LinkedHashMap<Integer, ImgExtractLine> linesMap, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean curLineIsThicker = false, curLineOffsetIsOK = false, curLineLengthIsOK = false, overhangFailed = false;
		boolean lastLineLengthIsOK = false, nextLineLengthIsOK = false;
		double curLineOffset = 0.0, lastLineOffset = 0.0, nextLineOffset = 0.0;
		double offsetChgR0 = 0.0, offsetChgR1 = 0.0, weightDiff = 0.0;
		int maxValidPtsLineIdxDelta = 0, shiftFlag = 0, peakFlag = 0;
		
		shiftFlag = 0;//Default is no need to shift current line
		curLineOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
		if(null!=lastLine){
			lastLineOffset = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
		}else{
			return shiftFlag;
		}
		
		if(1==currLineIdx%2){
			offsetChgR0 = (curLineOffset - lastLineOffset) / oddPoleAvgOffset;
		}else{
			offsetChgR0 = (curLineOffset - lastLineOffset) / evenPoleAvgOffset;
		}
		
		if(null!=nextLine){
			nextLineOffset = nextLine.getLineIntercept()+nextLine.getLineInterceptDelta();
			if(0==(currLineIdx+1)%2){
				offsetChgR1 = (nextLineOffset - curLineOffset) / evenPoleAvgOffset;
			}else{
				offsetChgR1 = (nextLineOffset - curLineOffset) / oddPoleAvgOffset;
			}
		}
		
		curLineLengthIsOK = (curLineIsLonger && weightCurLine[0]>=0.5 || !curLineIsLonger && weightCurLine[0]<0.5);
		curLineOffsetIsOK = (offsetChgR0>minOffsetChgRate && offsetChgR0<maxOffsetChgRate);
		
		lastLineLengthIsOK = (curLineIsLonger && weightLastLine[0]<0.5 || !curLineIsLonger && weightLastLine[0]>=0.5);
		if(null!=nextLine){
			nextLineLengthIsOK = (curLineIsLonger && weightNextLine[0]<0.5 || !curLineIsLonger && weightNextLine[0]>=0.5);
			weightDiff = Math.abs(weightCurLine[0]-weightNextLine[0]);
		}
		
		//Pre-screen conditions
		if(curLineLengthIsOK && lastLineLengthIsOK && nextLineLengthIsOK) return shiftFlag;
		
		if(curLineLengthIsOK && curLineOffsetIsOK){
			if(null!=nextLine && currLineIdx==targetLinesQty-2){
				if(offsetChgR0>maxOffsetChgRate*0.8 || offsetChgR1>maxOffsetChgRate || offsetChgR1<minOffsetChgRate){
					peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
					if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
					if(0==peakFlag){
						shiftFlag = 1;//Current line shift next
					}else if(!curLineIsLonger && weightNextLine[0]>weightCurLine[0] && weightDiff>0.2){
						//Suppose current line is correct
					}else if(offsetChgR0>maxOffsetChgRate*0.8){
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
						if(overhangFailed && weightDiff>0.2){
							maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
									-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
							if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
						}
					}
				}
			}
		}else{
			if(curLineLengthIsOK && offsetChgR0<=minOffsetChgRate){
				return shiftFlag;
			}else if(curLineLengthIsOK && offsetChgR0>=maxOffsetChgRate || !curLineLengthIsOK && curLineOffsetIsOK){//Possibly need to shift next
				if(currLineIdx!=targetLinesQty-2){
					if(thereIsPoleBtw(imgGrays,currLine,lastLine,true)){
						shiftFlag = 1;//Current line shift next
					}else{
						return shiftFlag;
					}
				}else{
					curLineIsThicker = lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0);
					if(firstPoleIsThicker && curLineIsThicker) return shiftFlag;
					
					if(null!=nextLine){
						if(curLineOffsetIsOK && lastLineLengthIsOK && nextLineLengthIsOK && offsetChgR1>minOffsetChgRate && offsetChgR1<maxOffsetChgRate
							&& !curLineIsLonger && weightNextLine[0]-weightCurLine[0]>0.2){
							//Suppose current line is correct
						}else{
							overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
							if(overhangFailed){
								peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
								if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
								if(offsetChgR1>maxOffsetChgRate || offsetChgR1<minOffsetChgRate){//Next line is out of expectation
									if(0==peakFlag){
										shiftFlag = 1;//Current line shift next
									}else{
										if(!curLineLengthIsOK){
											if(weightDiff>0.2) shiftFlag = 1;//Current line shift next(Give it a try)
										}
									}
								}else{
									if(curLineLengthIsOK){
										if(0==peakFlag) shiftFlag = 1;//Current line shift next
									}else{
										if(weightDiff>0.2) shiftFlag = 1;//Current line shift next(Give it a try)
									}
								}
							}else{
								if(!curLineLengthIsOK){
									if(offsetChgR0>maxOffsetChgRate*0.72){
										if(weightDiff>0.2){
											shiftFlag = 1;//Current line shift next(Give it a try)
										}else{
											maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
													-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
											if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
										}
									}
								}
							}
						}
					}else{
						maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
								-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx-1,lastLine,currLine,weightLastLine[0],weightCurLine[0]);
						if(0==maxValidPtsLineIdxDelta && overhangFailed){//There is no potential line after current line and overhang is NG btw current line and last line
							shiftFlag = 1;//Current line shift next(Give it a try)
						}
					}
				}
			}else if(!curLineLengthIsOK && offsetChgR0<=minOffsetChgRate){//Current line is too closed to last line, should be skipped
				shiftFlag = -1;//Skip current line
			}else if(!curLineLengthIsOK && offsetChgR0>=maxOffsetChgRate){//Possibly need to shift next
				if(currLineIdx==targetLinesQty-2){
					curLineIsThicker = lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0);
					if(firstPoleIsThicker && curLineIsThicker) return shiftFlag;
					
					peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
					if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
					if(0==peakFlag){
						shiftFlag = 1;//Current line shift next
					}else if(offsetChgR0>maxOffsetChgRate*0.8 && null!=nextLine){
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
						if(overhangFailed && weightDiff>0.2){
							if(offsetChgR0>maxOffsetChgRate && weightDiff>0.5){
								shiftFlag = 1;
							}else{
								maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
										-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
								if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
							}
						}
					}
				}
			}
		}
		
		return shiftFlag;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> doubleCheckAllLinesNew(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap, int[][] peakVals, int[][] initVals, int[][] imgGrays, boolean evenLineLonger, int targetLinesQty, double evenPoleAvgOffset, double oddPoleAvgOffset, double linesTendency_Slope, double linesTendency_Offset){
		LinkedHashMap<Integer, ImgExtractLine> linesMap = new LinkedHashMap<Integer, ImgExtractLine>();
		LinkedHashMap<Integer, ImgExtractLine> newLinesMap = new LinkedHashMap<Integer, ImgExtractLine>();
		ImgExtractLine currLine = null, nextLine = null, lastLine = null;
		
		for(int i=0; i<targetLinesQty; i++){
			if(null!=oriLinesMap.get(i)) linesMap.put(i, oriLinesMap.get(i));
		}
		int[] newLineIdx = new int[linesMap.size()];
		int[] oriLineIdx = new int[linesMap.size()];
		
		int idx = -1, lineIdx = -1, shiftFlag = 0, maxValidPtsLineIdxDelta = 0;
		int[] weightChkRange = null;
		boolean curLineIsLonger = false, curLineIsConfirmed = false, overhangFailed = false;
		boolean curLineLengthIsOK = false, curLineOffsetIsOK = false;
		boolean lastLineLengthIsOK = false, nextLineLengthIsOK = false;
		double[] weightCurLine = null, weightLastLine = null, weightNextLine = null, weight3 = null;
		double offsetChgR0 = 0.0, offsetChgR1 = 0.0, offsetChgR2 = 0.0;
		double nextLineOffset = 0.0, lastLineOffset = 0.0, curLineOffset = 0.0;
		
		for(int key:linesMap.keySet()){
			idx++;
			newLineIdx[idx] = key;//The final line index(will be adjusted in this routine)
			oriLineIdx[idx] = key;//The 1st guessing line index
		}
		
		for(int i=0; i<=idx; i++){
			if(newLineIdx[i]>=targetLinesQty) break;
			offsetChgR0 = 0.0; offsetChgR1 = 0.0; offsetChgR2 = 0.0;
			weightLastLine = null; weightNextLine = null;
			lastLineLengthIsOK = false; nextLineLengthIsOK = false;
			lineIdx = oriLineIdx[i];
			currLine = linesMap.get(lineIdx);//The line to be checked
			lastLine = newLinesMap.get(newLineIdx[i]-1);
			nextLine = linesMap.get(lineIdx+1);
			if(null!=currLine){
				if(currLine.getLineChecked()){
					newLinesMap.put(newLineIdx[i], currLine);
					continue;
				}
				curLineIsLonger = curLineIsLonger(newLineIdx[i],evenLineLonger);
				curLineOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				if(null!=lastLine){
					lastLineOffset = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
				}else{
					lastLineOffset = linesTendency_Slope*(newLineIdx[i]-1)+linesTendency_Offset;
				}
				if(1==newLineIdx[i]%2){
					offsetChgR0 = (curLineOffset - lastLineOffset) / oddPoleAvgOffset;
				}else{
					offsetChgR0 = (curLineOffset - lastLineOffset) / evenPoleAvgOffset;
				}
				if(offsetChgR0<0) continue;
				
				if(null!=nextLine){
					nextLineOffset = nextLine.getLineIntercept()+nextLine.getLineInterceptDelta();
					if(0==(newLineIdx[i]+1)%2){
						offsetChgR1 = (nextLineOffset - curLineOffset) / evenPoleAvgOffset;
						offsetChgR2 = (nextLineOffset - lastLineOffset) / evenPoleAvgOffset;
					}else{
						offsetChgR1 = (nextLineOffset - curLineOffset) / oddPoleAvgOffset;
						offsetChgR2 = (nextLineOffset - lastLineOffset) / oddPoleAvgOffset;
					}
				}
				
				if(12==lineIdx){
					System.out.print("");
				}
				
				weightChkRange = getWeightChkRange(linesMap,newLinesMap,lineIdx,newLineIdx[i]);
				weightCurLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, true, curLineIsLonger(newLineIdx[i],evenLineLonger), false);
				if(null!=lastLine){
					weightLastLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, newLineIdx[i]-1, targetLinesQty, true, curLineIsLonger(newLineIdx[i]-1,evenLineLonger), false);
					lastLineLengthIsOK = (curLineIsLonger && weightLastLine[0]<0.5 || !curLineIsLonger && weightLastLine[0]>=0.5);
				}
				if(null!=nextLine){
					weightNextLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx+1, targetLinesQty, true, curLineIsLonger(newLineIdx[i]+1,evenLineLonger), false);
					nextLineLengthIsOK = (curLineIsLonger && weightNextLine[0]<0.5 || !curLineIsLonger && weightNextLine[0]>=0.5);
				}
				
				curLineLengthIsOK = (curLineIsLonger && weightCurLine[0]>=0.5 || !curLineIsLonger && weightCurLine[0]<0.5);
				curLineOffsetIsOK = (offsetChgR0>minOffsetChgRate && offsetChgR0<maxOffsetChgRate);
				
				curLineIsConfirmed = false;
				//1.Expected case handling - Length of current pole is in expectation
				if(curLineLengthIsOK){
					//Offset variation of the most inner two poles could be bigger
					if(newLineIdx[i]==targetLinesQty-2){
						if(null!=nextLine){
							if(nextLine.getLineChecked()){//The most inner pole has confirmed
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
						//Length of current,left and right poles is in expectation
						if(!curLineIsConfirmed && lastLineLengthIsOK && nextLineLengthIsOK
							&& offsetChgR0>minOffsetChgRate*0.75){ //Pole offset meets the lower limit
							currLine.setLineChecked(true);
							newLinesMap.put(newLineIdx[i], currLine);
							curLineIsConfirmed = true;
						}
						//Offset of current pole is in control limit
						if(!curLineIsConfirmed){
							shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
									weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
									newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
							if(0<=shiftFlag){
								//Shift current line to next line
								if(1==shiftFlag) newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}else if(null!=lastLine && offsetChgR0>minOffsetChgRate*0.75 //Lower offset control limit could be loser while pole length is in expectation
						&& offsetChgR0<=maxOffsetChgRate //Pole offset is in control limit
						|| 0==newLineIdx[i] //Current line represents the most outer pole(the 1st pole)
						|| null!=lastLine && 1==currLine.getLineFlag() //Last line is fixed and current line is in the expected tendency
						|| null!=lastLine && curLineOffsetIsOK //Pole offset is in control limit
							//Current pole is the most inner pole and last pole is fixed
							&& newLineIdx[i]==targetLinesQty-1){
						//Key conditions:
						//(1)Last pole is fixed and offset of current pole is in ctrl limit
						//(2)Last pole is fixed and current pole is in ctrl tendency
						currLine.setLineChecked(true);
						newLinesMap.put(newLineIdx[i], currLine);
						curLineIsConfirmed = true;
					}
				}else if(0==newLineIdx[i] //Current line represents the most outer pole(the 1st pole)
					&& (offsetChgR0<=maxOffsetChgRate //Pole offset is in control criteria
						|| curLineIsLonger && weightCurLine[0]<0.5 //Length of current pole and next pole is very closed
						//Length of the most outer pole is not expected, which is usually caused by a longer
						//pole clings to the most outer short pole which leads to failed detection of short pole
						|| !curLineIsLonger && weightCurLine[0]>=0.5)){
					currLine.setLineChecked(true);
					newLinesMap.put(newLineIdx[i], currLine);
					curLineIsConfirmed = true;
				}else if(evenLineLonger && 1==newLineIdx[i]
					&& weightCurLine[0]>=0.5
					&& offsetChgR0>minOffsetChgRate*0.6){
					currLine.setLineChecked(true);
					newLinesMap.put(newLineIdx[i], currLine);
					curLineIsConfirmed = true;
				}
				
				//2.Common case handling
				if(!curLineIsConfirmed){//Length of current pole is out of expectation
					//2-1.Try to fix last pole first
					if(null==lastLine){ //Last pole is missing
						if(offsetChgR0<minOffsetChgRate //Current pole is too closed to last pole
							//Length of current pole is not expected
							|| offsetChgR0<maxOffsetChgRate*0.85 && !curLineLengthIsOK
							//Current line represents negative pole and last pole is negative pole
							|| offsetChgR0<maxOffsetChgRate*0.85 
								&& lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0) //Current line represents negative pole
								&& lineIsNegPole(newLineIdx[i]-1,evenLineLonger,evenPoleAvgOffset,oddPoleAvgOffset) //Last pole is negative pole
							//Current line represents the most inner pole and last pole is negative pole
							|| offsetChgR0<maxOffsetChgRate*0.75 && newLineIdx[i]==targetLinesQty-1 
								&& lineIsNegPole(newLineIdx[i]-1,evenLineLonger,evenPoleAvgOffset,oddPoleAvgOffset) //Last pole is negative pole
							//Current line represents the most inner pole and length of current pole is not expected
							|| offsetChgR0<maxOffsetChgRate*1.5 && newLineIdx[i]==targetLinesQty-1 
								&& (curLineIsLonger && weightCurLine[0]<0.45 //Length of current pole is not expected
									|| !curLineIsLonger && weightCurLine[0]>=0.5)){
							if(!lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0)
								&& newLineIdx[i]==targetLinesQty-1
								&& curLineIsLonger && weightCurLine[0]>0.5){
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}else{
								//Shift current line to previous line
								newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,-1);
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}else if((offsetChgR0>maxOffsetChgRate || newLineIdx[i]==targetLinesQty-1)//Offset of current pole is bigger or current pole is the most inner pole
							&& (curLineIsLonger && weightCurLine[0]>0.45 //Length of current pole is in expectation
								|| !curLineIsLonger && weightCurLine[0]<0.5)){
								//Offset of current pole exceeds upper limit but length of it is in expectation
								if(newLineIdx[i]==targetLinesQty-1 && curLineIsLonger
									&& weightCurLine[0]>=0.5 && lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0)){
									//Shift current line to previous line
									newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,-1);
								}
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
						}
					}
					//2-2.Refer to next line first since last line is supposed correct
					if(!curLineIsConfirmed && null!=nextLine){
						if(nextLineLengthIsOK){//Length of next pole is in expectation
							if(curLineLengthIsOK && nextLineLengthIsOK){
								//Offset of both current and next poles is on target
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}else{//Length of next pole is out of expectation
							if(offsetChgR1<minOffsetChgRate && offsetChgR2<maxOffsetChgRate){//Next pole is too closed to current pole
								if(newLineIdx[i]==targetLinesQty-2 && nextLine.getLineChecked()){
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}else{
									//Shift next line to current line
									newLineIdx=shiftLineIndex(newLineIdx,i+1,linesMap.size()-1,-1);
									nextLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], nextLine);//Shift next line to current line
								}
								curLineIsConfirmed = true;
							}else if((offsetChgR0>maxOffsetChgRate*0.85 || newLineIdx[i]==targetLinesQty-2 && offsetChgR0>minOffsetChgRate*0.6)//Offset of current pole is in expectation
									//Current pole is longer(expect shorter) than next pole
									&& !curLineIsLonger && weightCurLine[0]-weightNextLine[0]>0.15
							){
								//TODO Verification
								shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
										weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
										newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
								if(0<=shiftFlag){
									//Shift current line to next line
									if(1==shiftFlag) newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
								}
								curLineIsConfirmed = true;
							}else if(offsetChgR0>maxOffsetChgRate){
								maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
										-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
								overhangFailed = twoNearLinesOverhangFailed(newLineIdx[i],currLine,nextLine,weightCurLine[0],weightNextLine[0]);
								if(0==maxValidPtsLineIdxDelta || overhangFailed){
									//Shift current line to next line
									newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
								}
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}else if(offsetChgR0>minOffsetChgRate*0.6 && offsetChgR1<maxOffsetChgRate
								&& 1==currLine.getLineFlag()){
								//Offset of next pole is in expectation
								//Offset of current pole meets the lower limit and it is in expecting tendency
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}
					//2-3.Refer to last line
					if(!curLineIsConfirmed && null!=lastLine){
						if(lastLineLengthIsOK){//Length of last pole is in expectation
							if(newLineIdx[i]==targetLinesQty-2){
								if(offsetChgR0>minOffsetChgRate*0.5){
									shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
											weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
											newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
									if(1==shiftFlag){
										//Shift current line to next line
										newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
									}
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}
							}else if(newLineIdx[i]==targetLinesQty-1 && curLineIsLonger){
								if(weightCurLine[0]>0.5 && currLine.getTendencyRSQ()>minBestRsq){
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}else{
									//Enlarge inner side searching range
									double researchOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta()+3;
									double researchOffsetStop = researchOffset + (evenPoleAvgOffset+oddPoleAvgOffset)/2*3;
									double researchSlope = currLine.getLineSlope();
									ImgExtractLine exLine = null;
									exLine = searchLine(peakVals, initVals, imgGrays, 255, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
									if(null!=exLine){
										linesMap.put(lineIdx+1, exLine);
										weight3 = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx+1, targetLinesQty, true, curLineIsLonger(newLineIdx[i],evenLineLonger), false);
										if(weight3[0]>0.5 && weight3[0]>weightCurLine[0]
											|| weight3[0]>weightCurLine[0] && currLine.getTendencyRSQ()<minBestRsq){
											exLine.setLineChecked(true);
											newLinesMap.put(newLineIdx[i], exLine);
											curLineIsConfirmed = true;
										}
									}
									if(!curLineIsConfirmed){
										currLine.setLineChecked(true);
										newLinesMap.put(newLineIdx[i], currLine);
										curLineIsConfirmed = true;
									}
								}
							}
							
							//Offset of current pole is in a more expecting range
							if(!curLineIsConfirmed && offsetChgR0>minOffsetChgRate*1.1 && offsetChgR0<maxOffsetChgRate){
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}
				}
				
				//3.Abnormal case handling
				if(!curLineIsConfirmed){
					if(null!=lastLine && null!=nextLine){
						//Length of last and next poles is in expectation
						//Offset of last and next poles exceed the upper limit(they are far way from current pole)
						//Length of current pole is out of expectation
						if(offsetChgR0>maxOffsetChgRate && offsetChgR0<maxOffsetChgRate*1.5
							&& offsetChgR1>maxOffsetChgRate && offsetChgR1<maxOffsetChgRate*1.5
							&& (curLineIsLonger && weightCurLine[0]<0.5 
									&& weightLastLine[0]<0.5 && weightNextLine[0]<0.5
								|| !curLineIsLonger && weightCurLine[0]>=0.5
									&& weightLastLine[0]>=0.5 && weightNextLine[0]>=0.5)){
							//Shift current line to next line
							newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
							currLine.setLineChecked(true);
							newLinesMap.put(newLineIdx[i], currLine);
							curLineIsConfirmed = true;
						}
					}
				}
			}
		}
		
		return newLinesMap;
	}
	
	private LinkedHashMap<Double,Double> getWrinklePtsEx(ImgExtractLine curLine, int[][] peakVals, int wrinkleStartChkPos, int wrinkleStopChkPos, int wrinkleLineMaxOffset, int maxChkOffset, boolean chkDownSide){
		LinkedHashMap<Double,Double> wrinklePts = new LinkedHashMap<Double,Double>();
		double tmpSlope = curLine.getLineSlope();
		double tmpOffset = curLine.getLineIntercept()+curLine.getLineInterceptDelta();
		int y = 0, nearCol = 0, imgHeight = peakVals[0].length;
		int minX = wrinkleStartChkPos, startY = (int)(wrinkleStartChkPos*tmpSlope+tmpOffset);
		
		boolean bFound = false;
		String[] pt = null;
		int xDelta = 0, yDelta = 0;
		ArrayList<ArrayList<String>> wrinkleLines = new ArrayList<ArrayList<String>>();
		ArrayList<String> pts = new ArrayList<String>();
		for(int x=wrinkleStartChkPos; x>wrinkleStopChkPos; x--){
			nearCol = (int)(x*tmpSlope+tmpOffset);
			for(int n=0; n<=(int)maxChkOffset; n++){
				if(chkDownSide){
					y = nearCol + n;
				}else{
					y = nearCol - n;
				}
				if(y>=0 && y<imgHeight && peakVals[x][y]>0 && peakVals[x][y]<noiseGrayThr){
					if(minX>x) minX = x;
					if(wrinkleLines.isEmpty()){
						pts.add(x+","+y);
						wrinkleLines.add(pts);
					}else{
						bFound = false;
						for(int i=0; i<wrinkleLines.size(); i++){
							pts = wrinkleLines.get(i);
							pt = pts.get(pts.size()-1).split(",");
							xDelta = Integer.parseInt(pt[0]) - x;
							yDelta = y - Integer.parseInt(pt[1]);
							if(Math.abs(yDelta)<lineScanRange/2 && xDelta<lineScanRange){
								bFound = true;
								pts.add(x+","+y);
								wrinkleLines.remove(i);
								wrinkleLines.add(i, pts);
							}
						}
						if(!bFound){
							pts = new ArrayList<String>();
							pts.add(x+","+y);
							wrinkleLines.add(pts);
						}
					}
				}
			}
		}
		
		double onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		double minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		
		double[] coef = null;
		double tmpAngle = 0.0, crossX = 0.0, maxAngle = -1, delta = 0.0;
		int maxAngleIdx = -1, maxSizeIdx = -1, maxSize = -1;
		ArrayList<LinkedHashMap<Double,Double>> tmpLines = new ArrayList<LinkedHashMap<Double,Double>>();
		if(wrinkleLines.size()>0){
			for(int i=0; i<wrinkleLines.size(); i++){
				pts = wrinkleLines.get(i);
				if(pts.size()>=5){
					LinkedHashMap<Double,Double> tmpLine = new LinkedHashMap<Double,Double>();
					for(int j=0; j<pts.size(); j++){
						pt = pts.get(j).split(",");
						tmpLine.put(Double.parseDouble(pt[0]), Double.parseDouble(pt[1]));
					}
					tmpLines.add(tmpLine);
					if(maxSize<0){
						maxSize = tmpLine.size();
						maxSizeIdx = 0;
					}else if(maxSize<tmpLine.size()){
						maxSize = tmpLine.size();
						maxSizeIdx = tmpLines.size()-1;
					}
					
					yDelta = 0; xDelta = 0;
					pt = pts.get(0).split(",");
					xDelta = wrinkleStartChkPos - Integer.parseInt(pt[0]);
					if(chkDownSide){
						yDelta = Integer.parseInt(pt[1]) - startY;
					}else{
						yDelta = startY - Integer.parseInt(pt[1]);
					}
					
					tmpAngle = -1;
					coef = MathUtils.lineFitting(tmpLine);
					if(-1!=tmpSlope*coef[0]){
						tmpAngle = (tmpSlope-coef[0])/(1+tmpSlope*coef[0]);
						tmpAngle = Math.toDegrees(Math.atan(tmpAngle));
					}
					if(tmpAngle>0){
						crossX = (coef[1]-tmpOffset)/(tmpSlope-coef[0]);
						delta = crossX - wrinkleStartChkPos;
						if(maxAngle<tmpAngle && Math.abs(delta)<lineScanRange*6 
							&& yDelta<lineScanRange*3
							&& !(xDelta>lineScanRange*4 
								&& yDelta>lineScanRange/2
								&& delta<minDistance)
							&& !(tmpLine.size()<lineScanRange*1.5
								&& yDelta>lineScanRange*1.5)){
							//Conditions
							//1.Cross point is close to the curve starting point
							//2.First point of the wrinkle line is close to the checked layer
							maxAngle=tmpAngle;
							maxAngleIdx = tmpLines.size() - 1;
						}
					}
				}
			}
			if(maxAngleIdx>=0){
				wrinklePts = tmpLines.get(maxAngleIdx);
			}else if(maxSizeIdx>=0){
				wrinklePts = tmpLines.get(maxSizeIdx);
				coef = MathUtils.lineFitting(wrinklePts);
				crossX = (coef[1]-tmpOffset)/(tmpSlope-coef[0]);
				delta = crossX - wrinkleStartChkPos;
				if(delta<lineScanRange*(-2) || delta>lineScanRange*2){
					yDelta = 0; xDelta = 0;
					for(Double x:wrinklePts.keySet()){
						xDelta = (int)(wrinkleStartChkPos - x);
						if(chkDownSide){
							yDelta = (int)(wrinklePts.get(x) - startY);
						}else{
							yDelta = (int)(startY - wrinklePts.get(x));
						}
						break;
					}
					
					tmpAngle = -1;
					if(-1!=tmpSlope*coef[0]){
						tmpAngle = (tmpSlope-coef[0])/(1+tmpSlope*coef[0]);
						tmpAngle = Math.toDegrees(Math.atan(tmpAngle));
					}
					
					double x0=0.0,y0=0.0;
					for(Double x:wrinklePts.keySet()){
						x0 = x; y0 = wrinklePts.get(x);
					}
					wrinklePts.clear();
					
					if(tmpAngle>0 && tmpAngle<5 && delta>lineScanRange*2
						&& yDelta<=lineScanRange/2 && xDelta<=lineScanRange/2){
						double x1,y1,newSlope,newOffset,xStep;
						x1=wrinkleStartChkPos;y1=tmpSlope*x1+tmpOffset;
						newSlope=(y1-y0)/(x1-x0);
						newOffset = y1-newSlope*x1;
						xStep = (x1-x0)/10;
						
						for(double x=x0; x<=x1; x=x+xStep){
							wrinklePts.put(x, newSlope*x+newOffset);
						}
					}
				}
			}
		}
		if(wrinklePts.size()>0){
			coef = MathUtils.lineFitting(wrinklePts);
			wrinklePts.put((double)minX, coef[0]*minX+coef[1]);
		}
		
		return wrinklePts;
	}
	
	private String getResultKey(int layerIdx){
		String procRsltKey = "";
		
		if(0==layerIdx%2){
			procRsltKey = "L" + (layerIdx/2) + "_L";
		}else{
			procRsltKey = "L" + ((layerIdx+1)/2) + "_R";
		}
		
		return procRsltKey;
	}
	
	private boolean twoNearLinesOverhangFailed(int curLineIdx, ImgExtractLine curLine, ImgExtractLine nextLine, double curLineWeight, double nextLineWeight){
		boolean failed = true;
		double minDistance = 10;//pixels
		double maxDistance = 116;//pixels
		double onePixelLen = 0.012;
		double overhang = 0.0;
		int refCurrLine = 0, refNextLine = 0;
		
		onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		
		if(null!=curLine && null!=nextLine){
			if(evenPoleIsLonger && 0==curLineIdx%2 || !evenPoleIsLonger && 1==curLineIdx%2){
				refCurrLine = (int)(curLine.getXAxisStop() + (curLine.getXAxisStart()-curLine.getXAxisStop())*(1-curLineWeight));
				refNextLine = (int)(nextLine.getXAxisStart() - (nextLine.getXAxisStart()-nextLine.getXAxisStop())*nextLineWeight);
			}else{
				refCurrLine = (int)(curLine.getXAxisStart() - (curLine.getXAxisStart()-curLine.getXAxisStop())*curLineWeight);
				refNextLine = (int)(nextLine.getXAxisStop() + (nextLine.getXAxisStart()-nextLine.getXAxisStop())*(1-nextLineWeight));
			}
			
			if(firstPoleIsLonger){
				overhang = evenPoleIsLonger?refNextLine - refCurrLine:refCurrLine - refNextLine;
			}else{
				overhang = !evenPoleIsLonger?refCurrLine - refNextLine:refNextLine - refCurrLine;
			}
			if(overhang>=minDistance && overhang<=maxDistance) failed = false;
		}
		
		return failed;
	}
	
	private boolean calculateFinalResult(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger, int[][] imgGrays, int defaultVal, int targetLinesQty, int[][] peakVals, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean bPassed = false, curLinePassed = false;
		double minDistance = 10;//pixels
		double maxDistance = 116;//pixels
		double maxPoleAngle = 25;//degrees
		double maxMissedCheckRate = 0.0, minPassedRate = 1.0, onePixelLen = 0.012;
		int meetCndQty = 0, missedCheckQty = 0;
		double missedCheckRate = 0.0, passedRate = 0.0;
		int imgHeight = imgGrays[0].length;
		String procRsltKey = "";
		
		onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		maxPoleAngle = Double.parseDouble(""+criteria.get("maxPoleAngle"));
		
		int[] distances = new int[targetLinesQty];
		int lineCounter = 0;
		for(int i=0; i<targetLinesQty; i++){
			curLinePassed = false;
			ImgExtractLine exLine = linesMap.get(i);
			if(null!=exLine){
				String grays = "";
				int start = 0, imgWidth = finalData.length, nearCol = 0;
				int lineFlag = lineIndexBase+i;
				double lineSlope = exLine.getLineSlope();
				double lineOffset = exLine.getLineIntercept()+exLine.getLineInterceptDelta();
				if(i>=10){
					start = exLine.getMostSharpChgPos(evenLineLonger,linesMap,i,imgGrays,peakVals,targetLinesQty);
				}else{
					if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
						start = exLine.getXAxisStop();
					}else{
						start = exLine.getXAxisStart();
					}
				}
				exLine.setPolePosition(start);
				if(i>0){
					procRsltKey = getResultKey(i);
					if(null!=linesMap.get(i-1)){
						if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
							distances[i] = linesMap.get(i-1).getPolePosition() - start;
						}else{
							distances[i] = start - linesMap.get(i-1).getPolePosition();
						}
						if(distances[i]>=minDistance && distances[i]<=maxDistance){
							meetCndQty++;
							curLinePassed = true;
						}else if(distances[i]<minDistance && i<10){
							//TODO Double check special case
							int[][] tmpGrays = new int[imgWidth][imgHeight];
							for(int k=0; k<imgWidth; k++){
								tmpGrays[k] = imgGrays[k].clone();
							}
							double tmpSlope = exLine.getLineSlope();
							double tmpOffset = exLine.getLineIntercept();
							double oriSlope = tmpSlope, oriOffset = tmpOffset;
							double maxDnChkOffset = 0.0, maxUpChkOffset = 0.0;
							boolean checkDnSide = false, checkUpSide = false;
							int newXAxisStop = -1, abnXAxisStop = -1, wrinkleLineMaxOffset = 0;
							int upStartChkPos = 0, dnStartChkPos = 0, dnCrossX = -1, upCrossX = -1;
							ImgExtractLine tmpLine = null;
							
							wrinkleLineMaxOffset = (int)(evenPoleAvgOffset+oddPoleAvgOffset)/2;
							maxDnChkOffset = (evenPoleAvgOffset+oddPoleAvgOffset)/2;
							maxUpChkOffset = maxDnChkOffset;
							if(curLineIsLonger(i, evenLineLonger)){
								//Current line is the longer one
								tmpLine = exLine;
								if(null!=linesMap.get(i-1) && null==linesMap.get(i-2)){
									maxUpChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i-1).getLineIntercept()-linesMap.get(i-1).getLineInterceptDelta();
									maxUpChkOffset = Math.abs(maxUpChkOffset)*1.5;
//									checkUpSide = true;
									upStartChkPos = linesMap.get(i-1).getXAxisStart();
								}
								if(null!=linesMap.get(i+1)){
									if(null!=linesMap.get(i+2)){
										maxDnChkOffset = linesMap.get(i+2).getLineIntercept()+linesMap.get(i+2).getLineInterceptDelta();
										maxDnChkOffset = maxDnChkOffset - tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
									}else{
										maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i+1).getLineIntercept()-linesMap.get(i+1).getLineInterceptDelta();
										maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
									}
									checkDnSide = true;
									dnStartChkPos = linesMap.get(i+1).getXAxisStart();
								}
							}else{
								//Last line is the longer one
								tmpLine = linesMap.get(i-1);
								tmpSlope = tmpLine.getLineSlope();
								tmpOffset = tmpLine.getLineIntercept();
								oriSlope = tmpSlope; oriOffset = tmpOffset;
								if(null!=linesMap.get(i-2) && null==linesMap.get(i-3)){
									maxUpChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i-2).getLineIntercept()-linesMap.get(i-2).getLineInterceptDelta();
									maxUpChkOffset = Math.abs(maxUpChkOffset)*1.5;
//									checkUpSide = true;
									upStartChkPos = linesMap.get(i-2).getXAxisStart();
								}
								if(null!=linesMap.get(i+1)){
									maxDnChkOffset = linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta();
									maxDnChkOffset = maxDnChkOffset-tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
								}else{
									maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-exLine.getLineIntercept()-exLine.getLineInterceptDelta();
									maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
								}
								checkDnSide = true;
								dnStartChkPos = exLine.getXAxisStart();
								if(1==tmpLine.getWrinkleFlag() || 3==tmpLine.getWrinkleFlag()){
									checkDnSide = false;
								}
							}
							
							int refPos = tmpLine.getPolePosition();
							int upSideGray = 0, dnSideGray = 0, scanLines = 3, minIdx = -1;
							int startChkPos = refPos - distances[i];
							if(startChkPos<0) startChkPos = 0;
							int stopChkPos = startChkPos - (int)maxDistance;
							if(stopChkPos<0) stopChkPos = 0;
							
							LinkedHashMap<Double,Double> dnSideWrinkleLine = new LinkedHashMap<Double,Double>();
							LinkedHashMap<Double,Double> upSideWrinkleLine = new LinkedHashMap<Double,Double>();
							//Check up side
							if(checkUpSide){
//								upSideWrinkleLine = getWrinklePts(tmpLine,peakVals,upStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxUpChkOffset,false);
//								upSideWrinkleLine = getWrinkleLineEx(tmpLine,upSideWrinkleLine,upStartChkPos,-maxUpChkOffset,maxPoleAngle,peakVals);
								upSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,upStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxUpChkOffset,false);
							}
							
							//Check down side
							if(checkDnSide){
//								dnSideWrinkleLine = getWrinklePts(tmpLine,peakVals,dnStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
//								dnSideWrinkleLine = getWrinkleLineEx(tmpLine,dnSideWrinkleLine,startChkPos,maxDnChkOffset,maxPoleAngle,peakVals);
								dnSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,dnStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
							}
							
							double[] dnLineParas = null, upLineParas = null;
							double dnSideAngle = 0.0, upSideAngle = 0.0;
							if(dnSideWrinkleLine.size()>=5){
								dnLineParas = MathUtils.lineFitting(dnSideWrinkleLine);
								dnSideAngle = 90.0;
								if(-1!=tmpSlope*dnLineParas[0]){
									dnSideAngle = Math.abs((tmpSlope-dnLineParas[0])/(1+tmpSlope*dnLineParas[0]));
									dnSideAngle = Math.toDegrees(Math.atan(dnSideAngle));
									dnCrossX = (int)((tmpOffset-dnLineParas[1])/(dnLineParas[0]-tmpSlope));
									System.out.println("Dn Side Angle:"+dnSideAngle);
								}
								tmpLine.setWrinkleFlag(1);
							}
							if(upSideWrinkleLine.size()>=5){
								upLineParas = MathUtils.lineFitting(upSideWrinkleLine);
								upSideAngle = 90.0;
								if(-1!=tmpSlope*upLineParas[0]){
									upSideAngle = Math.abs((tmpSlope-upLineParas[0])/(1+tmpSlope*upLineParas[0]));
									upSideAngle = Math.toDegrees(Math.atan(upSideAngle));
									upCrossX = (int)((tmpOffset-upLineParas[1])/(upLineParas[0]-tmpSlope));
									System.out.println("Up Side Angle:"+upSideAngle);
								}
								if(dnSideWrinkleLine.size()>=5){
									tmpLine.setWrinkleFlag(3);
								}else{
									tmpLine.setWrinkleFlag(2);
								}
							}
							if(!curLineIsLonger(i, evenLineLonger) && !checkDnSide){
								if(null!=imgProcResultAngle.get(procRsltKey) && imgProcResultAngle.get(procRsltKey)>maxPoleAngle){
									newXAxisStop = tmpLine.getXAxisStop();
								}
							}
							
							if(dnSideAngle>0 || upSideAngle>0){
								storeLayerAngle(evenLineLonger, i, dnSideAngle, upSideAngle);
								if(dnSideAngle>maxPoleAngle || upSideAngle>maxPoleAngle){
									if(0==i%2 && evenLineLonger || 1==i%2 &&!evenLineLonger){
										if(checkUpSide && upSideAngle>maxPoleAngle){
											abnXAxisStop = imgWidth;
											for(double k:upSideWrinkleLine.keySet()){
												if(k<abnXAxisStop) abnXAxisStop=(int)k;
											}
										}
									}else{
										if(checkDnSide && dnSideAngle>maxPoleAngle){
											abnXAxisStop = imgWidth;
											for(double k:dnSideWrinkleLine.keySet()){
												if(k<abnXAxisStop) abnXAxisStop=(int)k;
											}
										}
									}
									newXAxisStop = dnCrossX>upCrossX?dnCrossX:upCrossX;
									
									if(abnXAxisStop<0){
										dnSideAngle = 0; upSideAngle = 0;
									}
								}else{
									if(dnSideAngle>0 && dnSideAngle<=maxPoleAngle){
										upSideGray = dnSideGray + 1;
										minIdx = imgWidth;
										for(double k:dnSideWrinkleLine.keySet()){
											if(k<minIdx) minIdx=(int)k;
										}
										newXAxisStop = minIdx;
										for(int k=refPos; k>=minIdx; k--){
											nearCol = (int)(k*tmpSlope+tmpOffset);
											for(int n=(int)maxDnChkOffset;n>0;n--){
												if(nearCol+n>=0 && nearCol+n<imgHeight){
													if(imgGrays[k][nearCol+n]<defaultVal){
														if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
															tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
														}
													}
												}
											}
										}
									}else if(upSideAngle>0 && upSideAngle<=maxPoleAngle){
										dnSideGray = upSideGray + 1;
										minIdx = imgWidth;
										for(double k:upSideWrinkleLine.keySet()){
											if(k<minIdx) minIdx=(int)k;
										}
										if(newXAxisStop<0) newXAxisStop = minIdx;
										if(newXAxisStop>minIdx) newXAxisStop = minIdx;
										for(int k=(refPos+5); k>=minIdx; k--){
											nearCol = (int)(k*tmpSlope+tmpOffset);
											for(int n=(int)maxUpChkOffset;n>0;n--){
												if(nearCol-n>=0 && nearCol-n<imgHeight){
													if(imgGrays[k][nearCol-n]<defaultVal){
														if(tmpGrays[k][nearCol]>imgGrays[k][nearCol-n]){
															tmpGrays[k][nearCol]=imgGrays[k][nearCol-n];
														}
													}
												}
											}
										}
									}
								}
							}
							
							if(!(dnSideAngle>0 || upSideAngle>0) && -1==newXAxisStop){
								for(int k=refPos; k>0; k--){
									nearCol = (int)(k*tmpSlope+tmpOffset);
									if(nearCol>=1 && nearCol<imgHeight){
										upSideGray += imgGrays[k][nearCol-1];
										dnSideGray += imgGrays[k][nearCol+1];
									}
								}
								if(upSideGray>dnSideGray){//Check down side
									for(int k=refPos; k>0; k--){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=0 && nearCol<(imgHeight-scanLines)){
											for(int n=0; n<=scanLines; n++){
												if(imgGrays[k][nearCol+n]<defaultVal){
													if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
														tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
													}
												}
											}
										}
									}
								}else if(upSideGray<dnSideGray){//Check up side
									for(int k=refPos; k>0; k--){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=scanLines && nearCol<imgHeight){
											for(int n=0; n<=scanLines; n++){
												if(imgGrays[k][nearCol-n]<defaultVal){
													if(tmpGrays[k][nearCol]>imgGrays[k][nearCol-n]){
														tmpGrays[k][nearCol] = imgGrays[k][nearCol-n];
													}
												}
											}
										}
									}
								}
							}
							
							int oriRefPos = tmpLine.getPolePosition();
							int startPos = 0, stopPos = 0, oriCol = 0;
							boolean bDnSideWrinkle = false;
							if(upSideGray>dnSideGray || dnSideGray>upSideGray || -1!=newXAxisStop){
								System.out.println("Ori start/stop:"+tmpLine.getXAxisStart()+"/"+tmpLine.getXAxisStop());
								if(newXAxisStop<0){
									tmpLine = setLineBoundary(tmpLine, tmpGrays, defaultVal);
								}else{
									tmpLine.setXAxisStop(newXAxisStop);
									if(tmpLine.getXAxisStart()<newXAxisStop) tmpLine.setXAxisStart(newXAxisStop);
								}
								System.out.println("Cur start/stop:"+tmpLine.getXAxisStart()+"/"+tmpLine.getXAxisStop());
								tmpLine.setPolePosition(tmpLine.getXAxisStop());//tmpLine is the longer pole
								
								if(curLineIsLonger(i, evenLineLonger)){
									linesMap.put(i, tmpLine);//Current line is the longer one
								}else{
									linesMap.put(i-1, tmpLine);//Last line is the longer one
								}
								
								if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
									distances[i] = linesMap.get(i-1).getPolePosition() - linesMap.get(i).getPolePosition();
								}else{
									distances[i] = linesMap.get(i).getPolePosition() - linesMap.get(i-1).getPolePosition();
								}
								//distances[i] = Math.abs(linesMap.get(i).getPolePosition() - linesMap.get(i-1).getPolePosition());
								if(distances[i]>=minDistance && distances[i]<=maxDistance){
									meetCndQty++;
									curLinePassed = true;
								}
								
								if(!curLinePassed) lineFlag = 4;
								refPos = tmpLine.getXAxisStop();
								if(refPos > oriRefPos){
									startPos = oriRefPos;
									stopPos = refPos;
								}else{
									startPos = refPos;
									stopPos = oriRefPos;
								}
								
								bDnSideWrinkle = false;
								if(dnSideAngle>0 || upSideAngle>0){
									if(dnSideAngle>upSideAngle){
										tmpSlope = dnLineParas[0];
										tmpOffset = dnLineParas[1];
										bDnSideWrinkle = true;
									}else{
										tmpSlope = upLineParas[0];
										tmpOffset = upLineParas[1];
									}
									for(int k=startPos; k<=stopPos; k++){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										oriCol = (int)(k*oriSlope+oriOffset);
										if(bDnSideWrinkle && nearCol<oriCol) nearCol = oriCol;
										if(!bDnSideWrinkle && nearCol>oriCol) nearCol = oriCol;
										if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
									}
								}else{
									for(int k=startPos; k<=stopPos; k++){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
									}
								}
							}
							
							if(null!=dnLineParas || null!=upLineParas){
								bDnSideWrinkle = false;
								if(null!=dnLineParas){
									tmpSlope = dnLineParas[0];
									tmpOffset = dnLineParas[1];
									bDnSideWrinkle = true;
									if(abnXAxisStop<0){
										abnXAxisStop = imgWidth;
										for(double k:dnSideWrinkleLine.keySet()){
											if(k<abnXAxisStop) abnXAxisStop=(int)k;
										}
									}
								}else{
									tmpSlope = upLineParas[0];
									tmpOffset = upLineParas[1];
									if(abnXAxisStop<0){
										abnXAxisStop = imgWidth;
										for(double k:upSideWrinkleLine.keySet()){
											if(k<abnXAxisStop) abnXAxisStop=(int)k;
										}
									}
								}
								for(int k=abnXAxisStop; k<=oriRefPos; k++){
									nearCol = (int)(k*tmpSlope+tmpOffset);
									oriCol = (int)(k*oriSlope+oriOffset);
									if(bDnSideWrinkle && nearCol<oriCol) nearCol = oriCol;
									if(!bDnSideWrinkle && nearCol>oriCol) nearCol = oriCol;
									if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
								}
							}
						}
						if(!curLinePassed) lineFlag = 4;//Draw the failed line
						imgProcResultLength.put(procRsltKey, distances[i]*onePixelLen);
						imgProcResultOK.put(procRsltKey, curLinePassed);
					}else{
						missedCheckQty++;
						imgProcResultLength.put(procRsltKey, 0.0);
						imgProcResultOK.put(procRsltKey, false);
					}
				}
				
				if(exLine.getCrossX()>0) start = exLine.getCrossX();
				for(int k=0; k<start; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					grays += "," + imgGrays[k][nearCol];
				}
				for(int k=start; k<imgWidth; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					finalData[k][nearCol] = lineFlag;
					grays += "," + imgGrays[k][nearCol];
				}
				
				lineCounter++;
				if(logEnabled){
					LogUtils.rawLog("sortLineParas_", exLine.printLineParas(i,1==lineCounter?true:false));
					LogUtils.rawLog("sortLineGrays_", "G"+i+grays);
				}
			}else{
				if(i>0) missedCheckQty++;
			}
		}
		
		//Most outer line special handling
		if(!evenLineLonger && null!=imgProcResultLength.get("L1_R") && null!=imgProcResultLength.get("L1_L")){
			double layer1R = imgProcResultLength.get("L1_R");
			double layer1L = imgProcResultLength.get("L1_L");
			if(layer1R>0 && layer1R<(minDistance*onePixelLen)
				&& layer1L>0 && layer1L>(minDistance*onePixelLen)){
				meetCndQty++;
			}
		}
		
		//Double check the result
		for(String key:imgProcResultOK.keySet()){
			if(!imgProcResultOK.get(key) && key.endsWith("_R")){
				if(null!=imgProcResultAngle.get(key.replace("_R", "_L"))){
					meetCndQty++;
					imgProcResultOK.put(key, true);
					imgProcResultLength.put(key, imgProcResultLength.get(key.replace("_R", "_L")));
				}
			}
		}
		
		missedCheckRate = (double)missedCheckQty / (targetLinesQty - 1);
		passedRate = (double)meetCndQty / (targetLinesQty - 1 - missedCheckQty);
		if(missedCheckRate<=maxMissedCheckRate && passedRate>=minPassedRate){
			bPassed = true;
		}
		
		return bPassed;
	}

	private void storeLayerAngle(boolean evenLineLonger, int layerIdx, double dnSideAngle, double upSideAngle) {
		if(dnSideAngle>0 || upSideAngle>0){
			String angleKey = "";
			if(curLineIsLonger(layerIdx, evenLineLonger)){
				if(0==layerIdx%2){
					angleKey = "L" + (layerIdx/2);
				}else{
					angleKey = "L" + ((layerIdx+1)/2);
				}
			}else{
				if(0==(layerIdx-1)%2){
					angleKey = "L" + ((layerIdx-1)/2);
				}else{
					angleKey = "L" + (layerIdx/2);
				}
			}
			angleKey = angleKey + (dnSideAngle>upSideAngle?"_L":"_R");
			imgProcResultAngle.put(angleKey, (dnSideAngle>upSideAngle?dnSideAngle:upSideAngle));
		}
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> searchMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap,
			ImgExtractLine myBaseline,int[][] peakVals, int[][] initVals, int[][]imgGrays, 
			int defaultVal, double[] slope, double[] offset, int bestRsqIdx,
			double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty, boolean chkMinOffset){
		
		double diff1,diff2,offsetChgR,addLineSlope,addLineOffset,off1,off2,curOffset;
		double researchSlope = myBaseline.getLineSlope(), researchOffset = myBaseline.getLineIntercept();
		double researchOffsetStop = 0;
		
		for(int i=0; i<targetLinesQty; i++){
			ImgExtractLine exLine = linesMap.get(i);
			if(null==exLine){
				if(null!=linesMap.get(i-1)){
					researchOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta();
				}else{
					researchOffset = slope[bestRsqIdx]*(i-1)+offset[bestRsqIdx];
				}
				
				if(null!=linesMap.get(i+1)){
					researchOffsetStop = linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta();
				}else{
					researchOffsetStop = slope[bestRsqIdx]*(i+1)+offset[bestRsqIdx];
				}
				off1 = researchOffset; off2 = researchOffsetStop;
				addLineSlope = researchSlope; addLineOffset = (researchOffset+researchOffsetStop)/2;
				if(0==i%2){
					researchOffset += evenPoleAvgOffset*0.9;
					researchOffsetStop -= (oddPoleAvgOffset*0.9>lineScanRange?lineScanRange:oddPoleAvgOffset*0.9);
					if(i==(targetLinesQty-1)) researchOffsetStop = researchOffset + oddPoleAvgOffset*1.5;
				}else{
					researchOffset += oddPoleAvgOffset*0.9;
					researchOffsetStop -= (evenPoleAvgOffset*0.9>lineScanRange?lineScanRange:evenPoleAvgOffset*0.9);
					if(i==(targetLinesQty-1)) researchOffsetStop = researchOffset + evenPoleAvgOffset*1.5;
				}
				if(researchOffsetStop-researchOffset<lineScanRange){
					researchOffset = (researchOffsetStop+researchOffset)/2-lineScanRange/2-1;
					researchOffsetStop = researchOffset+lineScanRange+1;
				}
				
				exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
				if(null!=exLine){
					if(null!=linesMap.get(i-2) && null!=linesMap.get(i-3)){
						diff1 = exLine.getLineIntercept()+exLine.getLineInterceptDelta()-researchOffset;
						diff2 = linesMap.get(i-2).getLineIntercept()-linesMap.get(i-3).getLineIntercept();
						diff2 += linesMap.get(i-2).getLineInterceptDelta()-linesMap.get(i-3).getLineInterceptDelta();
						offsetChgR = diff1/diff2;
						if(offsetChgR>maxOffsetChgRate){
							researchOffsetStop = exLine.getLineIntercept()+exLine.getLineInterceptDelta() - lineScanRange/2;
							exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
						}
						else if(chkMinOffset && offsetChgR<minOffsetChgRate){
							curOffset = exLine.getLineIntercept()+exLine.getLineInterceptDelta();
							if(off2-curOffset<curOffset-off1){
								exLine = addFixedLine(peakVals,imgGrays,defaultVal,addLineSlope,addLineOffset);
							}
						}
					}
					if(null!=exLine){
						exLine.setLineFlag(3);
						linesMap.put(i, exLine);
					}
				}
				System.out.println((null==exLine?"Missing:":"Insert:")+i);
			}else{
				researchSlope = linesMap.get(i).getLineSlope();
			}
		}
		
		return linesMap;
	}
	
	private boolean thereIsMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap, int targetLinesQty){
		boolean missing = false;
		
		for(int i=0; i<targetLinesQty; i++){
			if(null == linesMap.get(i)){
				missing = true;
				break;
			}
		}
		return missing;
	}
	
	private boolean lineIsNegPole(int lineIdx, boolean evenLineLonger, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean isNegPole = false;
		
		if(0==lineIdx%2 && !evenLineLonger || 1==lineIdx%2 && evenLineLonger){
			if(evenPoleAvgOffset>oddPoleAvgOffset) isNegPole = true;
		}
		
		return isNegPole;
	}
	
	private ImgExtractLine getMostClosedLine(double offset, double tolerance){
		ImgExtractLine line = null;
		int idx = -1;
		for(int i=0; i<allPossibleLines.size(); i++){
			if(allPossibleLines.get(i).getLineIntercept()>=offset){
				idx = i;
				break;
			}
		}
		if(idx>=0){
			if(allPossibleLines.get(idx).getLineIntercept()-offset<=tolerance){
				line = allPossibleLines.get(idx);
			}else if(idx>0 && allPossibleLines.get(idx-1).getLineIntercept()-offset<=tolerance){
				line = allPossibleLines.get(idx-1);
			}
		}
		
		return line;
	}
	
	private int getLineMeanGray(ImgExtractLine currLine, int[][] imgGrays, int startIdx, int stopIdx){
		if(null==currLine) return -1;
		
		double slope = currLine.getLineSlope(), sumGray = 0.0;
		double offset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
		int nearCol = 0, imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		int meanGray = -1, counter = 0;
		if(startIdx>stopIdx){
			nearCol = startIdx;
			startIdx = stopIdx;
			stopIdx = nearCol;
		}
		if(startIdx<0) startIdx = 0;
		if(stopIdx+1>imgWidth) stopIdx=imgWidth-1;
		
		for(int i=startIdx; i<=stopIdx; i++){
			nearCol = (int)(slope * i + offset);
			if(nearCol>=0 && nearCol<imgHeight){
				sumGray += imgGrays[i][nearCol];
				counter++;
			}
		}
		if(counter>0) meanGray = (int)(sumGray/counter);
		
		return meanGray;
	}
	
	private boolean thereIsPoleBtw(int[][] imgGrays, ImgExtractLine currLine, ImgExtractLine lastLine, boolean supposed){
		boolean poleExisting = supposed;
		
		if(null!=currLine && null!=lastLine){
			poleExisting = false;
			ImgExtractLine tmpLine = null;
			double offset1 = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
			double offset2 = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
			poleExisting = offsetInPeakRegion(allPossibleLines,(offset1+offset2)/2);
			
			//If out of expectation
			int gray0 = 0, gray1 = 0, gray2 = 0;
			if(!poleExisting && supposed){
				tmpLine = getMostClosedLine((offset1+offset2)/2,lineScanRange/2);
				if(null!=tmpLine){
					gray0 = getLineMeanGray(tmpLine,imgGrays,imgGrays.length/2,imgGrays.length);
					gray1 = getLineMeanGray(currLine,imgGrays,imgGrays.length/2,imgGrays.length);
					gray2 = getLineMeanGray(lastLine,imgGrays,imgGrays.length/2,imgGrays.length);
					if((double)(gray0-gray1+gray0-gray2)/2+0.5<3){
						poleExisting = supposed;
					}else{
						poleExisting = !supposed;
					}
				}
			}
		}
		
		return poleExisting;
	}
	
	private boolean lineIsThicker(double[] weightOfLine, int[][] imgGrays, ImgExtractLine currLine, ImgExtractLine lastLine, double offsetChgR){
		boolean thicker = false;
		//Total lines appear in Up or Dn side checking region is more than 3
		if(weightOfLine[6]>=0.6 && weightOfLine[8]>=5 
			|| weightOfLine[5]>=0.6 && weightOfLine[7]>=5
			|| weightOfLine[5]*weightOfLine[7]+weightOfLine[6]*weightOfLine[8]>=5){
			if(null==currLine){
				thicker = true;
			}else{
				double slope = currLine.getLineSlope();
				double offsetCurrLine = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				double offsetLastLine = offsetCurrLine-10;
				if(null!=lastLine) offsetLastLine = lastLine.getLineIntercept() + lastLine.getLineInterceptDelta()-3;
				int scanRange = (int)(offsetCurrLine - offsetLastLine);
				if(scanRange<0) scanRange = 10;
				int stDelta = -5;
				int[] grays = new int[scanRange+1-stDelta];
				int innerAvgGray = 0, outerAvgGray = 0, innerCnt = 0, outerCnt = 0;
				double innerGray = 0.0, outerGray = 0.0;
				
				for(int i=stDelta; i<=scanRange; i++){
					grays[i-stDelta] = currLine.getLineAvgGray(imgGrays, currLine.getXAxisStop(), slope, offsetCurrLine-i);
					if(i<scanRange/2){
						innerGray += grays[i-stDelta];
						innerCnt++;
					}else{
						outerGray += grays[i-stDelta];
						outerCnt++;
					}
				}
				outerAvgGray = (int)(outerGray/outerCnt);
				innerAvgGray = (int)(innerGray/innerCnt);
				
				if(outerAvgGray-innerAvgGray>3 
					|| outerAvgGray-innerAvgGray>=3 && weightOfLine[5]*weightOfLine[7]+weightOfLine[6]*weightOfLine[8]>=5
				){
					thicker = true;
				}
			}
		}
		
		return thicker;
	}
	
	private boolean evenLineIsLonger(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays){
		boolean evenLineLonger = false;
		int[] refGrayIndex = new int[targetLinesQty];
		double[] refGrays = new double[targetLinesQty];
		int longPoleFirstQty = 0, imgHeight = imgGrays[0].length;
		double weightOfEvenLineLonger = 0.0;
		
		for(int i=0; i<targetLinesQty; i++){
			ImgExtractLine exLine = linesMap.get(i);
			if(null!=exLine){
				if(0==i%2){
					refGrayIndex[i] = exLine.getXAxisStart();
				}else{
					refGrayIndex[i] = refGrayIndex[i-1];
				}
				
				double refGray = 0.0;
				double lineSlope = exLine.getLineSlope();
				double lineOffset = exLine.getLineIntercept();
				int nearCol = 0;
				for(int k=0; k<=refGrayIndex[i]; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					refGray += imgGrays[k][nearCol];
				}
				exLine.setRefGray(refGray);
				refGrays[i] = refGray;
				
				if(0!=i%2){
					if(refGrays[i]>refGrays[i-1]) longPoleFirstQty++;
				}
			}
		}
		weightOfEvenLineLonger = (double)longPoleFirstQty*2 / targetLinesQty;
		if(weightOfEvenLineLonger>0.5) evenLineLonger = true;
		
		return evenLineLonger;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> addMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap,
			ImgExtractLine myBaseline,int[][] peakVals, int[][] initVals, int[][]imgGrays, 
			int defaultVal, double[] slope, double[] offset, int bestRsqIdx,
			double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty){
		
		double addLineSlope = 0.0, addLineOffset = 0.0;
		double researchOffset = 0.0, researchOffsetStop = 0.0, researchSlope = 0.0;
		
		for(int i=1; i<targetLinesQty; i++){
			if(null==linesMap.get(i) && null!=linesMap.get(i-1)){
				ImgExtractLine exLine = null;
				addLineSlope = 0.0; addLineOffset = 0.0;
				if(null!=linesMap.get(i+1)){
					addLineSlope = (linesMap.get(i-1).getLineSlope()+linesMap.get(i+1).getLineSlope())/2;
					addLineOffset = (linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()
							+linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta())/2;
				}else if(i==(targetLinesQty-1)){
					researchSlope = linesMap.get(i-1).getLineSlope();
					researchOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()+(evenPoleAvgOffset+oddPoleAvgOffset)/2;
					researchOffsetStop = researchOffset + (evenPoleAvgOffset+oddPoleAvgOffset)/2*3;
					exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
					if(null!=exLine){
						exLine.setLineFlag(3);
					}else{
						addLineSlope = linesMap.get(i-1).getLineSlope();
						addLineOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()
								+(evenPoleAvgOffset+oddPoleAvgOffset)/2;
					}
				}
				if(addLineOffset>0) exLine = addFixedLine(peakVals,imgGrays,defaultVal,addLineSlope,addLineOffset);
				if(null!=exLine) linesMap.put(i, exLine);
			}
		}
		
		return linesMap;
	}
	
	private ImgExtractLine addFixedLine(int[][] peakVals, int[][]imgGrays, 
			int defaultVal, double addLineSlope, double addLineOffset){
		
		ImgExtractLine exLine = null;
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int nearCol = 0, scanRng = lineScanRange/2, colOffset = 0, maxCnt = 0;
		int[] dataCounters = new int[scanRng*2+1];
		exLine = new ImgExtractLine();
		
		for(int j=(imgWidth-1); j>=0; j--){
			nearCol = (int)(j*addLineSlope+addLineOffset);
			for(int k=-scanRng; k<=scanRng; k++){
				if(nearCol+k>=0 && nearCol+k<imgHeight){
					if(peakVals[j][nearCol+k]<lineFitGrayThr){
						dataCounters[k+scanRng] = dataCounters[k+scanRng]+1;
					}
				}
			}
		}
		
		for(int k=0; k<dataCounters.length; k++){
			if(maxCnt<dataCounters[k]){
				maxCnt = dataCounters[k];
				colOffset = k;
			}
		}
		
		colOffset = colOffset - scanRng;
		for(int j=(imgWidth-1); j>=0; j--){
			nearCol = (int)(j*addLineSlope+addLineOffset);
			if(nearCol+colOffset>=0 && nearCol+colOffset<imgHeight){
				if(peakVals[j][nearCol+colOffset]<lineFitGrayThr){
					exLine.addPoint(j, nearCol, imgGrays[j][nearCol]);
				}
			}
		}
		
		exLine.getLineCoef(false);
		exLine.setLineFlag(3);
		exLine = setLineBoundary(exLine, imgGrays, defaultVal);
		
		return exLine;
	}
	
	private void initLineFitGrayThreshold(){
		lineFitGrayThr = 255 * 0.8;
	}
	
	private void adjustLineFitGrayThreshold(int[][] imgGrays, ImgExtractLine myBaseline, int scanOffset){
		double slope = myBaseline.getLineSlope();
		double offset = myBaseline.getLineIntercept();
		int nearRow = 0, imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		double grayAvg = 0.0;
		int counter = 0;
		
		for(int col=0; col<imgWidth; col++){
			nearRow = (int)(slope*col+offset);
			if(nearRow<0 || nearRow+scanOffset>imgHeight) continue;
			for(int row=0; row<scanOffset; row++){
				if(imgGrays[col][nearRow+row]<noiseGrayThr){
					counter++;
					grayAvg += imgGrays[col][nearRow+row];
				}
			}
		}
		
		if(counter>0){
			grayAvg = grayAvg / counter * 1.05;
			System.out.println("Line fit threshold:"+lineFitGrayThr+"/"+grayAvg);
			if(grayAvg>lineFitGrayThr) lineFitGrayThr = grayAvg;
		}
	}
	
	private ArrayList<ImgExtractLine> searchLines(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, ImgExtractLine myBaseline){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int validCnt = 0, nearCol = 0, noisePoints = 0, realPoints = 0;
		int invalidCnt = 0, minValidCol = imgWidth*2, maxValidCol = -1;
		int startChkX = (int)(imgWidth*0.4), lastValidX = 0;
		int maxBlankX = (int)(imgWidth*0.05);
		double noiseRate = 0.0, slopeDelta = 0.0, validRate = 0.0;
		double lastLineOffset = 0.0, lastLineSlope = 0.0;
		double offsetDelta1 = 0.0, offsetDelta2 = 0.0, offsetDelta3 = 0.0, offsetDelta = 0.0;
		double invalidRatio = 0.0, maxColDelta = 3.0;
		int startSearchingOffset = 0, currentLineOffset = 0, finalSearchingOffset = 0;
		int lineSearchingRng = lineScanRange / 2;//Two sides searching
		
		int fittingMinPoints = (int)(imgWidth * minValidRatio);
		boolean bLineFound = false;
		
		int[][] sortData = new int[imgWidth][imgHeight];
		int[][] searchingLinesData = new int[imgWidth][imgHeight];
		finalData = new int[imgWidth][imgHeight];
		for(int i=0; i<imgWidth; i++){
			sortData[i] = initVals[i].clone();
			finalData[i] = initVals[i].clone();
			searchingLinesData[i] = peakVals[i].clone();
		}
		double myBaselineSlope = myBaseline.getLineSlope();
		double myBaselineOffset = myBaseline.getLineIntercept();
		startSearchingOffset = (int)(myBaselineSlope*(imgWidth-1)+myBaselineOffset);
		if(startSearchingOffset<0) startSearchingOffset = 0;
		lastLineOffset = -1;
		initLineFitGrayThreshold();
		adjustLineFitGrayThreshold(imgGrays,myBaseline,30);
		
		double[] lineCoef = null;
		ArrayList<ImgExtractLine> extractLines = new ArrayList<ImgExtractLine>();
		ImgExtractLine lastPossibleLine = null;
		ImgExtractLine extractLine = new ImgExtractLine();
		ImgExtractLine.setMinRSQ(0.7f);
		
		if(imgWidth > fittingMinPoints && imgHeight > lineSearchingRng){
			for(int i=startSearchingOffset; i<imgHeight; i++){
				bLineFound = false;
				minValidCol = imgWidth*2; maxValidCol = -1;
				extractLine.clearLineData();
				for(int j=(imgWidth-1); j>=0; j--){
					if(j<startChkX){
						lineSearchingRng = 1;
					}else{
						lineSearchingRng = lineScanRange / 2;
					}
					nearCol = (int)(j*myBaselineSlope+myBaselineOffset);
					if((nearCol-lineSearchingRng)>=0 && nearCol<(imgHeight-lineSearchingRng)){
						for(int k=-lineSearchingRng; k<lineSearchingRng; k++){
							if(peakVals[j][nearCol+k]<lineFitGrayThr){
								if(j>=startChkX || j<startChkX && lastValidX-j<maxBlankX){
									extractLine.addPoint(j, nearCol+k, peakVals[j][nearCol+k]);
									if((nearCol+k)<minValidCol) minValidCol = nearCol+k;
									if((nearCol+k)>maxValidCol) maxValidCol = nearCol+k;
									if(Math.abs(k)<=1) extractLine.addRealPoints(j, nearCol+k, 1);
									lastValidX = j;
								}
							}
							if(imgGrays[j][nearCol+k]>=noiseGrayThr) extractLine.addInvalidPoints(1);
						}
					}
				}
				
				validCnt = extractLine.getValidPoints();
				realPoints = extractLine.getRealPoints();
				invalidCnt = extractLine.getInvalidPoints();
				invalidRatio = (double)invalidCnt / (lineSearchingRng*2+1) / imgWidth;
				
				if(extractLines.size()<=0){
					saveSearchingLines(searchingLinesData,myBaselineSlope,myBaselineOffset,i,"debug");
					if(i-startSearchingOffset>(lineScanRange*3)){
						System.out.println("Fail to get 1st layer");
						break;
					}
				}else if(2==extractLines.size()){
//					if(249==i)
//					System.out.println("debug:"+i);
				}
				
				if((validCnt>=fittingMinPoints || realPoints>=fittingMinPoints*0.8) && invalidRatio<maxInvalidRatio){
					lineCoef = extractLine.getLineCoef(false);
					currentLineOffset = (int)(lineCoef[0]*(imgWidth-1)+lineCoef[1]);
					slopeDelta = Math.abs(myBaselineSlope-extractLine.getLineSlope());
					if(-1==lastLineOffset){
						offsetDelta1 = minOffsetDelta*1.1;
						offsetDelta2 = offsetDelta1; offsetDelta3 = offsetDelta1;
					}else{
						offsetDelta1 = lineCoef[1]-lastLineOffset;
						offsetDelta2 = (lineCoef[0]-lastLineSlope)*imgWidth/2+lineCoef[1]-lastLineOffset;
						offsetDelta3 = (lineCoef[0]-lastLineSlope)*(imgWidth-1)+lineCoef[1]-lastLineOffset;
					}
					offsetDelta = (offsetDelta1+offsetDelta2+offsetDelta3)/3;
					
					if(maxValidCol-minValidCol>maxColDelta){
						validRate = extractLine.getValidRateByYAxis((maxValidCol+minValidCol)/2-1, (maxValidCol+minValidCol)/2+1);
					}else{
						validRate = 1.0;
					}
					
					if(null!=lineCoef && (ImgExtractLine.getMinRSQ()<=lineCoef[2] 
							|| (maxValidCol-minValidCol)<=maxColDelta 
							|| validRate>minValidRate) 
							&& (extractLines.size()>0 && currentLineOffset > 0
								|| extractLines.isEmpty() && currentLineOffset>=0)
							&& slopeDelta<maxSlopeDelta 
							&& offsetDelta1>minOffsetDelta/3 
							&& offsetDelta2>minOffsetDelta/3 
							&& offsetDelta3>minOffsetDelta/3
							&& offsetDelta>minOffsetDelta){
						for(int k=0; k<imgWidth; k++){
							nearCol = (int)(k*lineCoef[0]+lineCoef[1]);
							if(nearCol>noiseScanRng && nearCol<(imgHeight-noiseScanRng)){
								noisePoints = 0;
								for(int n=-noiseScanRng; n<=noiseScanRng; n++){
									if(peakVals[k][nearCol+n]<noiseGrayThr){
										if(Math.abs(n)>1){
											noisePoints++;
										}else{
											extractLine.addOnlinePoint();
										}
									}
								}
								if(noisePoints>0) extractLine.addSideNoise(noisePoints);
							}else{
								break;
							}
						}
						
						noiseRate = maxNoiseRate + 1.0;
						if(extractLine.getOnlinePoints()>0) noiseRate = (double)extractLine.getNoisePoints() / extractLine.getOnlinePoints();
						
						if(extractLine.getOnlinePoints()>=(fittingMinPoints*0.8) 
							&& (noiseRate<maxNoiseRate 
							|| noiseRate>=maxNoiseRate 
							&& validRate>=1.0 
							&& ImgExtractLine.getMinRSQ()<=lineCoef[2])){
							
							if(extractLines.isEmpty()) extractLine.getLineCoef(true);
							lastLineSlope = extractLine.getLineSlope();
							lastLineOffset = extractLine.getLineIntercept();
							
							saveSearchingLines(searchingLinesData,myBaselineSlope,myBaselineOffset,extractLines.size(),"found");
							
							myBaselineSlope = extractLine.getLineSlope();
							myBaselineOffset = extractLine.getLineIntercept()+1;
							
							currentLineOffset = (int)(myBaselineSlope*(imgWidth-1)+myBaselineOffset);
							i = currentLineOffset+lineSearchingRng;
							bLineFound = true;
							extractLine = setLineBoundary(extractLine, imgGrays, defaultVal);
							extractLines.add(extractLine.clone());
							if(targetLinesQty==extractLines.size()) finalSearchingOffset = i;
							System.out.println("Line found:"+myBaselineSlope+"/"+myBaselineOffset);
						}
					}
				}
				if(!bLineFound) myBaselineOffset = myBaselineOffset+1;
				
				if(allPossibleLines.size()>0) lastPossibleLine = allPossibleLines.get(allPossibleLines.size()-1);
				if(!bLineFound && validCnt>5 && 0==extractLine.getLineIntercept()) extractLine.getLineCoef(false);
				if(allPossibleLines.size()>0 && validCnt==lastPossibleLine.getValidPoints()
					&& extractLine.getLineIntercept()-lastPossibleLine.getLineIntercept()<5){
					if(bLineFound || extractLine.getLineRSQ()>lastPossibleLine.getLineRSQ()){
						if(!bLineFound) bLineFound = (3==lastPossibleLine.getLineFlag()?true:false);
						allPossibleLines.remove(allPossibleLines.size()-1);
						if(allPossibleLines.size()>0){
							lastPossibleLine = allPossibleLines.get(allPossibleLines.size()-1);
						}else{
							lastPossibleLine = null;
						}
					}
				}
				if(allPossibleLines.isEmpty() || allPossibleLines.size()>0
					&& (validCnt!=lastPossibleLine.getValidPoints()
						|| extractLine.getLineIntercept()-lastPossibleLine.getLineIntercept()>=5)){
					if(bLineFound) extractLine.setLineFlag(3);
					allPossibleLines.add(extractLine.clone());
				}
				
				if(targetLinesQty==extractLines.size()){
					if(i>=finalSearchingOffset+lineScanRange*6) break;
				}
			}
		}
		
		if(extractLines.size()>0) extractLines = adjustAllSearchedLines(allPossibleLines,extractLines,imgGrays,defaultVal);
		saveImgData("graysSortLines_",sortData);
		return extractLines;
	}
	
	private double[] getPoleOffset(ArrayList<ImgExtractLine> lines, int targetLinesQty){
		double[] poleOffset = new double[]{0.0,0.0};
		double oddPoleOffset = 0.0, evenPoleOffset = 0.0, tmpOffset = 0.0;
		double oddMin = 0.0, oddMax = 0.0, evenMin = 0.0, evenMax = 0.0;
		int oddPoleCnt = 1, evenPoleCnt = 1;
		
		if(null!=lines && lines.size()>2){
			oddPoleOffset = lines.get(1).getLineIntercept() - lines.get(0).getLineIntercept();
			evenPoleOffset = lines.get(2).getLineIntercept() - lines.get(1).getLineIntercept();
			oddMin = oddPoleOffset; oddMax = oddMin;
			evenMin = evenPoleOffset; evenMax = evenMin;
			if(lines.size()>3){
				for(int i=3; i<lines.size(); i++){
					tmpOffset = lines.get(i).getLineIntercept() - lines.get(i-1).getLineIntercept();
					if(1==i%2){
						oddPoleCnt++;
						oddPoleOffset += tmpOffset;
						if(oddMin>tmpOffset) oddMin = tmpOffset;
						if(oddMax<tmpOffset) oddMax = tmpOffset;
					}else{
						evenPoleCnt++;
						evenPoleOffset += tmpOffset;
						if(evenMin>tmpOffset) evenMin = tmpOffset;
						if(evenMax<tmpOffset) evenMax = tmpOffset;
					}
				}
			}
			if(oddPoleCnt>2){
				oddPoleOffset = (oddPoleOffset-oddMin-oddMax)/(oddPoleCnt-2);
			}else{
				oddPoleOffset = oddPoleOffset/oddPoleCnt;
			}
			if(evenPoleCnt>2){
				evenPoleOffset = (evenPoleOffset-evenMin-evenMax)/(evenPoleCnt-2);
			}else{
				evenPoleOffset = evenPoleOffset/evenPoleCnt;
			}
			poleOffset[0] = evenPoleOffset;
			poleOffset[1] = oddPoleOffset;
		}
		
		return poleOffset;
	}
	
	private double[] twoLinesAvgOffset(double slope1, double offset1, double slope2, double offset2, double startX, double stopX){
		double sumOffset = 0.0, avgOffset = 0.0, stepX = (startX+stopX)/10, dblTemp = 0.0;
		double minOffset = 0.0, maxOffset = 0.0, offsetFactor = 1.0;
		int counter = 0;
		
		if(startX>stopX){
			dblTemp = startX;
			startX = stopX;
			stopX = dblTemp;
		}
		
		if(0==stepX) stepX = 1.0;
		if(offset2>offset1) offsetFactor = -1.0;
		minOffset = Math.abs(offset2-offset1); maxOffset = minOffset;
		for(double x = startX; x<=stopX; x+=stepX){
			dblTemp = (slope1*x+offset1 - (slope2*x+offset2))*offsetFactor;
			sumOffset += dblTemp;
			counter++;
			if(minOffset>dblTemp) minOffset = dblTemp;
			if(maxOffset<dblTemp) maxOffset = dblTemp;
		}
		
		avgOffset = sumOffset / counter;
		
		return new double[]{avgOffset,minOffset,maxOffset};
	}
	
	private ArrayList<ImgExtractLine> adjustAllSearchedLines(ArrayList<ImgExtractLine> allPossibleLines,ArrayList<ImgExtractLine> extractLines,int[][] imgGrays,int defaultVal){
		double ratio = 0.0, bestRsq = 0.0, offsetDelta = 0.0, off2 = 0.0, ratio2 = 0.0, ratio3 = 0.0;
		double refOffset = 0.0, lastOffset = 0.0, nextOffset = -1.0, tmpOffset = 0.0;
		int bestIdx = 0, refValidPts = 0, lastFoundIdx = -1, size = 0, nextIdx = 0;
		int scanRng = lineScanRange/2, offsetCmpFlag = 0;
		boolean swapPoleOffset = false;
		ArrayList<ImgExtractLine> adjLines1 = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjLines2 = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjustLines = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjLines = new ArrayList<ImgExtractLine>();
		ImgExtractLine tmpLine = null, lastLine = null;
		
		//Step_1:Adjust the first found lines
		for(int idx=0; idx<allPossibleLines.size(); idx++){
			if(3!=allPossibleLines.get(idx).getLineFlag()) continue;
			refValidPts = allPossibleLines.get(idx).getValidPoints();
			refOffset = allPossibleLines.get(idx).getLineIntercept();
			bestRsq = allPossibleLines.get(idx).getLineRSQ();
			bestIdx = idx;
			for(int i=-scanRng; i<=scanRng; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(null!=tmpLine && Math.abs(refOffset-tmpLine.getLineIntercept())<5){
					ratio = (double)tmpLine.getValidPoints()/refValidPts;
					if(ratio>0.95 && bestRsq<tmpLine.getLineRSQ()){
						bestRsq = tmpLine.getLineRSQ();
						bestIdx = idx+i;
					}
				}
			}
			tmpLine = allPossibleLines.get(bestIdx);
			offsetDelta = tmpLine.getLineIntercept();
			if(null!=lastLine){
				offsetDelta -= lastLine.getLineIntercept();
				if(offsetDelta<=5){
					adjLines1.remove(adjLines1.size()-1);
					lastLine = null;
				}
			}
			if(null==lastLine || null!=lastLine && offsetDelta>5){
				if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, defaultVal);
				adjLines1.add(tmpLine);
				lastLine = tmpLine;
			}
		}
		
		//Step_2:Get all potential lines via peak searching method
		adjLines2 = adjustAllSearchedLinesEx(allPossibleLines,imgGrays,defaultVal);
		adjLines2 = doubleCheckAllPotentialLines(adjLines2,allPossibleLines);
		double[] poleOffset = getPoleOffset(adjLines2,targetLinesQty);
		
		//Step_3:Combine all lines from Step_1 and Step_2
		lastFoundIdx = -1;
		if(adjLines2.isEmpty()){
			for(int i=0; i<adjLines1.size(); i++){
				adjustLines.add(adjLines1.get(i));
			}
		}else{
			for(int i=0; i<adjLines1.size(); i++){//First found lines are more reliable(they are the base)
				bestIdx = -1;
				tmpLine = adjLines1.get(i);
				refOffset = tmpLine.getLineIntercept();
				
				if(12==adjustLines.size()){
					System.out.print("");
				}
				
				for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
					//Double confirm in all potential lines
					if(Math.abs(refOffset-adjLines2.get(j).getLineIntercept())<3){
						bestIdx = j;
						break;
					}
					if(adjLines2.get(j).getLineIntercept()-refOffset>3) break;
				}
				
				//TODO Verification
				if(bestIdx<0 && adjustLines.isEmpty() && adjLines2.size()>0){
					//Double check the most outer line
					double[] offs = twoLinesAvgOffset(tmpLine.getLineSlope(),tmpLine.getLineIntercept(),adjLines2.get(0).getLineSlope(),adjLines2.get(0).getLineIntercept(),0.0,imgGrays.length);
					if(offs[0]<3 && offs[1]<1) continue;
				}
				
				if(bestIdx>=0){
					if(lastFoundIdx<0 && bestIdx>0){//Suppose adjLines2 is reliable
						for(int j=0; j<bestIdx; j++){
							adjustLines.add(adjLines2.get(j));
							lastFoundIdx = j;
						}
					}
					
					//Found in potential lines
					if(lastFoundIdx>=0 && bestIdx-lastFoundIdx>1){
						//Confirm the missed potential lines
						if(adjustLines.size()>0) refOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
						for(int k=(lastFoundIdx+1);k<bestIdx;k++){
							if(adjLines2.get(k).getLineIntercept()<refOffset) continue;
							lastOffset = refOffset;
							if(k>0) lastOffset = adjLines2.get(k-1).getLineIntercept();
							offsetDelta = adjLines2.get(k+1).getLineIntercept()-adjLines2.get(k).getLineIntercept();
							if((adjLines2.get(k).getLineIntercept()-lastOffset>=5 || k<2 && adjLines2.get(k).getLineIntercept()-lastOffset>=3)
								&& offsetDelta>=5){
								ratio = (double)adjLines2.get(k).getValidPoints()/imgGrays.length;
								if(ratio>=minValidRatio){
									adjustLines.add(adjLines2.get(k));
								}else{
									off2 = adjLines2.get(k).getLineIntercept()-lastOffset;
									ratio = offsetDelta/off2;
									if(ratio<minOffsetChgRate || ratio>maxOffsetChgRate
										|| offsetDelta>5 && off2>5) adjustLines.add(adjLines2.get(k));
								}
							}
						}
					}
					lastFoundIdx = bestIdx;
					tmpLine = adjLines2.get(bestIdx);
				}else if(adjustLines.size()>0 && refOffset>adjLines2.get(0).getLineIntercept()){
					//Not found in potential lines(after the 1st found line)
					if(lastFoundIdx+1<adjLines2.size()){
						offsetDelta = refOffset-adjLines2.get(lastFoundIdx+1).getLineIntercept();
						if(offsetDelta>5){//First found line is behind the potential lines
							for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
								if(refOffset-adjLines2.get(j).getLineIntercept()>5){
									adjustLines.add(adjLines2.get(j));
									lastFoundIdx = j;
								}else{
									break;
								}
							}
						}else if(offsetDelta<=5){//First found line is very closed to the potential lines
							for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
								if(refOffset>adjLines2.get(j).getLineIntercept()){//Fetch the potential lines
									adjustLines.add(adjLines2.get(j));
									lastFoundIdx = j;
								}else{
									break;
								}
							}
						}
					}
					
					//Get next potential line
					nextOffset = -1.0; nextIdx = -1;
					for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
						if(adjLines2.get(j).getLineIntercept()>refOffset){
							nextOffset = adjLines2.get(j).getLineIntercept();
							nextIdx = j;
							break;
						}
					}
					
					//Offset change rate of the first found line
					ratio = -1.0; lastOffset = 0.0; ratio2 = -1.0;
					size = adjustLines.size();
					if(size>0){
						lastOffset = adjustLines.get(size-1).getLineIntercept();
						if(size>2){//Refer to previous data
							ratio = (refOffset - lastOffset)/(adjustLines.get(size-2).getLineIntercept()-adjustLines.get(size-3).getLineIntercept());
							ratio2 = (nextOffset - lastOffset)/(adjustLines.get(size-2).getLineIntercept()-adjustLines.get(size-3).getLineIntercept());
						}else if(nextIdx>0 && nextIdx+3<adjLines2.size()){
							ratio = (refOffset - lastOffset)/(adjLines2.get(nextIdx+3).getLineIntercept()-adjLines2.get(nextIdx+2).getLineIntercept());
							ratio2 = (nextOffset - lastOffset)/(adjLines2.get(nextIdx+3).getLineIntercept()-adjLines2.get(nextIdx+2).getLineIntercept());
						}else{
							if(1==adjustLines.size()%2){//Supposed the first found line is a missing potential line
								if(poleOffset[1]>0){
									ratio = (refOffset - lastOffset)/poleOffset[1];
									ratio2 = (nextOffset - lastOffset)/poleOffset[1];
								}
							}else{
								if(poleOffset[0]>0){
									ratio = (refOffset - lastOffset)/poleOffset[0];
									ratio2 = (nextOffset - lastOffset)/poleOffset[0];
								}
							}
						}
					}
					
					swapPoleOffset = true;
					offsetCmpFlag = offsetInSamePeak(allPossibleLines,refOffset,nextOffset,lastOffset);
					
					if(-1==offsetCmpFlag){
						continue;//Skip because the first found line is not in a valid peak region
					}else if(2==offsetCmpFlag){
						continue;//Skip because the first found line is in the valid peak region of last line
					}else if(1==offsetCmpFlag){
						tmpLine = adjLines2.get(nextIdx);//Replace the first found line with next potential line
						lastFoundIdx = nextIdx;
						swapPoleOffset = false;
					}else if(0==offsetCmpFlag){
						if(!(adjustLines.size()>2 && ratio>minOffsetChgRate)){
							ratio3 = (double)tmpLine.getValidPoints()/imgGrays.length;
							if(ratio3<minValidRatio) continue;
						}
						if(ratio<maxOffsetChgRate*0.6 && ratio2>0 && ratio2<maxOffsetChgRate) continue;
					}
					
					if(swapPoleOffset){
						tmpOffset = poleOffset[0];
						poleOffset[0] = poleOffset[1];
						poleOffset[1] = tmpOffset;
					}
				}
				if(adjustLines.isEmpty()) tmpLine.setLineChecked(true);//Fixed the 1st found layer
				adjustLines.add(tmpLine);
			}
		}
		
		//Step_4:Check whether all layers are found
		if(adjustLines.size()<targetLinesQty){
			refOffset = 0.0;
			if(adjustLines.size()>0) refOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
			for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
				if(adjLines2.get(j).getLineIntercept()>refOffset && adjustLines.size()<targetLinesQty){
					adjustLines.add(adjLines2.get(j));
				}
			}
		}
		
		LinkedHashMap<Double,Double> tendency = new LinkedHashMap<Double,Double>();
		double[] coef = null;
		for(int i=0; i<adjustLines.size(); i++){
			tmpLine = adjustLines.get(i);
			tmpLine.setLineIndex(i);
			tendency.put((double)i, tmpLine.getLineIntercept());
			if(tendency.size()<3){
				tmpLine.setTendencyRSQ(1.0);
			}else{
				coef = MathUtils.lineFitting(tendency);
				tmpLine.setTendencyRSQ(coef[2]);
			}
			if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, 255);
			
			//TODO Verification
			if(i<(targetLinesQty-3)) tmpLine.setLineChecked(true);
			
			adjLines.add(tmpLine);
			allPotentialLines.add(tmpLine);
		}
		
		//Add all potential lines
		if(adjLines2.size()>lastFoundIdx+1){
			refOffset = allPotentialLines.get(allPotentialLines.size()-1).getLineIntercept();
			for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
				if(adjLines2.get(j).getLineIntercept()>refOffset){
					allPotentialLines.add(adjLines2.get(j));
				}
			}
		}
		
		if(logEnabled){
			for(int i=0; i<adjustLines.size(); i++){
				tmpLine = adjustLines.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,0==i?true:false));
			}
			for(int i=0; i<adjLines2.size(); i++){
				tmpLine = adjLines2.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,false));
			}
			for(int i=0; i<extractLines.size(); i++){
				tmpLine = extractLines.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,false));
			}
			for(int i=0; i<allPossibleLines.size(); i++){
				tmpLine = allPossibleLines.get(i);
				LogUtils.rawLog("searchLineParas_", tmpLine.printLineParas(tmpLine.getLineFlag(),0==i?true:false));
			}
			logSelectedLinesGray(adjustLines,imgGrays,5);
		}
		
		return adjLines;
	}
	
	private void logSelectedLinesGray(ArrayList<ImgExtractLine> selectedLines, int[][] imgGrays, int grayScanRng){
		ImgExtractLine tmpLine = null;
		int imgWidth = imgGrays.length, imgHeight = imgGrays[0].length, col = 0;
		double lineSlope = 0.0, lineOffset = 0.0;
		String title = "LineIdx,Offset,Col,Edge1,Edge2,X", data = "";
		
		if(null!=selectedLines && selectedLines.size()>0){
			for(int i=0; i<imgWidth; i++){
				title += "," + i;
			}
			LogUtils.rawLog("selectedLinesXY_",title);
			for(int i=0; i<selectedLines.size(); i++){
				tmpLine = selectedLines.get(i);
				lineSlope = tmpLine.getLineSlope(); lineOffset = tmpLine.getLineIntercept();
				for(int j=-grayScanRng; j<=grayScanRng; j++){
					data = i + "," + lineOffset + "," + j + "," + tmpLine.getXAxisStop() + "," + tmpLine.getXAxisStart() + ",Y";
					for(int k=0; k<imgWidth; k++){
						col = (int)(lineSlope * k + lineOffset + j);
						if(col>=0 && col<imgHeight){
							data += "," + imgGrays[k][col];
						}else{
							data += ",255";
						}
					}
					LogUtils.rawLog("selectedLinesXY_",data);
				}
			}
		}
	}
	
	private boolean offsetInPeakRegion(ArrayList<ImgExtractLine> allPossibleLines, double chkOffset){
		boolean inPeakRegion = false;
		double minDelta = 0.0, offsetDelta = 0.0, ratio = 0.0;
		int mostCloseIdx = -1, scanRng = lineScanRange/2, counter = 0, minValidPts = 0;
		int size = allPossibleLines.size(), peakIdx = -1, maxValidPts = 0;
		
		if(size>0){
			//Get the index of chkOffset in allPossibleLines
			minDelta = Math.abs(allPossibleLines.get(0).getLineIntercept()-chkOffset);
			mostCloseIdx = 0;
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-chkOffset);
				if(minDelta>offsetDelta){
					minDelta = offsetDelta;
					mostCloseIdx = i;
				}
			}
			
			//Fine-tune the index of chkOffset
			peakIdx = -1; maxValidPts = 0;
			for(int i=-scanRng; i<=scanRng; i++){
				if(mostCloseIdx+i>=0 && mostCloseIdx+i<size){
					offsetDelta = Math.abs(allPossibleLines.get(mostCloseIdx+i).getLineIntercept()-chkOffset);
					if(offsetDelta<3){
						if(maxValidPts<allPossibleLines.get(mostCloseIdx+i).getValidPoints()){
							maxValidPts = allPossibleLines.get(mostCloseIdx+i).getValidPoints();
							peakIdx = mostCloseIdx+i;
						}
					}
				}
			}
			
			if(peakIdx>=0){
				//Possibility of being in the peak region
				counter = 0;
				for(int i=scanRng; i>0; i--){
					if(peakIdx-i>=0 && peakIdx+i<size){
						if(allPossibleLines.get(peakIdx).getValidPoints()>=allPossibleLines.get(peakIdx-i).getValidPoints()
							&& allPossibleLines.get(peakIdx).getValidPoints()>=allPossibleLines.get(peakIdx+i).getValidPoints()){
							counter++;
						}
					}
				}
				ratio = (double)counter/scanRng;
				if(ratio>0.66){
					//Check whether current peakIdx represents a valid peak or not
					maxValidPts = allPossibleLines.get(peakIdx).getValidPoints();
					minValidPts = maxValidPts;
					ratio = 0.0;
					//Get the base&max value in last 10 points
					for(int i=peakIdx; i>(peakIdx-10); i--){
						if(i<0) break;
						if(maxValidPts<allPossibleLines.get(i).getValidPoints()) maxValidPts = allPossibleLines.get(i).getValidPoints();
						if(minValidPts>allPossibleLines.get(i).getValidPoints()) minValidPts = allPossibleLines.get(i).getValidPoints();
					}
					if(maxValidPts>minValidPts) ratio = (double)(allPossibleLines.get(peakIdx).getValidPoints()-minValidPts)/(maxValidPts-minValidPts);
					if(ratio>0.2) inPeakRegion = true;
				}
			}
		}
		return inPeakRegion;
	}
	
	private int offsetInSamePeak(ArrayList<ImgExtractLine> allPossibleLines, double chkOffset, double nextOffset, double lastOffset){
		int rsltFlag = -1;
		double minDelta0 = 0.0, offsetDelta = 0.0, minDelta1 = 0.0, minDelta2 = 0.0;
		int chkIdx = -1, nextIdx = -1, lastIdx = -1;
		int size = allPossibleLines.size();
		int[] validPts = null, idx1 = null, idx2 = null;
		
		if(size>0 && chkOffset>0 && (nextOffset>0 || lastOffset>0)){
			minDelta0 = Math.abs(allPossibleLines.get(0).getLineIntercept()-chkOffset);
			minDelta1 = Math.abs(allPossibleLines.get(0).getLineIntercept()-nextOffset);
			minDelta2 = Math.abs(allPossibleLines.get(0).getLineIntercept()-lastOffset);
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-chkOffset);
				if(minDelta0>offsetDelta){
					minDelta0 = offsetDelta;
					chkIdx = i;
				}
				
				if(nextOffset>0){
					offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-nextOffset);
					if(minDelta1>offsetDelta){
						minDelta1 = offsetDelta;
						nextIdx = i;
					}
				}
				
				if(lastOffset>0){
					offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-lastOffset);
					if(minDelta2>offsetDelta){
						minDelta2 = offsetDelta;
						lastIdx = i;
					}
				}
			}
			
			validPts = getPossibleLinesValidDtPts(allPossibleLines);
			idx1 = MathUtils.getPeakCenterIndex(validPts, chkIdx, lineScanRange, true);
			if(idx1[0]>=0){
				rsltFlag = 0;
				if(nextIdx>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, nextIdx, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 1;
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(allPossibleLines.get(idx2[0]).getLineIntercept()-allPossibleLines.get(idx1[0]).getLineIntercept()<=lineScanRange/2) rsltFlag = 1;
						}
					}
				}
				if(0==rsltFlag && lastIdx>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, lastIdx, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 2;
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(allPossibleLines.get(idx1[0]).getLineIntercept()-allPossibleLines.get(idx2[0]).getLineIntercept()<=lineScanRange/2) rsltFlag = 2;
						}
					}
				}
			}
		}
		return rsltFlag;
	}
	
	private int offsetInSamePeakEx(ArrayList<ImgExtractLine> allPossibleLines, double offset1, double offset2){
		int rsltFlag = -1;//Not found in all possible lines
		double minDelta0 = 0.0, offsetDelta = 0.0, minDelta1 = 0.0;
		int index1 = -1, index2 = -1;
		int size = allPossibleLines.size();
		int[] validPts = null, idx1 = null, idx2 = null;
		
		if(size>0 && offset1>0 && offset2>0){
			minDelta0 = Math.abs(allPossibleLines.get(0).getLineIntercept()-offset1);
			minDelta1 = Math.abs(allPossibleLines.get(0).getLineIntercept()-offset2);
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-offset1);
				if(minDelta0>offsetDelta){
					minDelta0 = offsetDelta;
					index1 = i;
				}
				
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-offset2);
				if(minDelta1>offsetDelta){
					minDelta1 = offsetDelta;
					index2 = i;
				}
			}
			
			validPts = getPossibleLinesValidDtPts(allPossibleLines);
			idx1 = MathUtils.getPeakCenterIndex(validPts, index1, lineScanRange, true);
			if(idx1[0]>=0){
				rsltFlag = 0;//offset1 is found
				if(index2>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, index2, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 1;//offset1 and offset2 is in same peak
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(Math.abs(allPossibleLines.get(idx2[0]).getLineIntercept()-allPossibleLines.get(idx1[0]).getLineIntercept())<=lineScanRange/2) rsltFlag = 1;
						}
						
						if(0==rsltFlag && Math.abs(idx2[1]-idx1[1])<=2){
							rsltFlag = 2;//Left edge of offset1 and offset2 is the same
						}
					}
				}
			}
		}
		return rsltFlag;
	}
	
	private int[] getPossibleLinesValidDtPts(ArrayList<ImgExtractLine> allPossibleLines){
		int[] lineValidDataPts = new int[allPossibleLines.size()];
		for(int i=0; i<allPossibleLines.size(); i++){
			lineValidDataPts[i] = allPossibleLines.get(i).getValidPoints();
		}
		return lineValidDataPts;
	}
	
	private ArrayList<ImgExtractLine> roughCheckAllPotentialLines(ArrayList<ImgExtractLine> potentialLines){
		ArrayList<ImgExtractLine> newPotentialLines = new ArrayList<ImgExtractLine>();
		double currOffset = 0.0, nextOffset = 0.0;
		
		if(null!=potentialLines && potentialLines.size()>0){
			if(potentialLines.size()>1){
				for(int i=0; i<potentialLines.size()-1; i++){
					currOffset = potentialLines.get(i).getLineIntercept();
					nextOffset = potentialLines.get(i+1).getLineIntercept();
					if(currOffset>0 && currOffset<nextOffset){
						newPotentialLines.add(potentialLines.get(i));
					}
				}
				if(currOffset>0 && currOffset<nextOffset){
					newPotentialLines.add(potentialLines.get(potentialLines.size()-1));
				}
			}else{
				newPotentialLines = potentialLines;
			}
		}
		
		return newPotentialLines;
	}
	
	private ArrayList<ImgExtractLine> doubleCheckAllPotentialLines(ArrayList<ImgExtractLine> potentialLines, ArrayList<ImgExtractLine> allPossibleLines){
		ArrayList<ImgExtractLine> newPotentialLines = new ArrayList<ImgExtractLine>();
		
		potentialLines = roughCheckAllPotentialLines(potentialLines);
		if(null!=potentialLines && potentialLines.size()>0){
			int size = potentialLines.size(), newSize = 0;
			int currLineIdx = 0, lastLineIdx = 0;
			int peakFlags = -1;
			double ratio = 0.0;
			ImgExtractLine exLine = null;
			if(size<=1){
				newPotentialLines = potentialLines;
			}else{
				newPotentialLines.add(potentialLines.get(0));
				for(int i=1; i<size; i++){
					newSize = newPotentialLines.size();
					if(13==newSize){
						System.out.print("");
					}
					lastLineIdx = getLineIndex(allPossibleLines,newPotentialLines.get(newSize-1).getLineIntercept());
					currLineIdx = getLineIndex(allPossibleLines,potentialLines.get(i).getLineIntercept());
					if(lastLineIdx>0 && currLineIdx>lastLineIdx){
						if(newSize>2){//Check offset change rate of current line - see whether need to skip current line
							ratio = potentialLines.get(i).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
							ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
							if(ratio<maxOffsetChgRate*0.6){//Current line is very closed to last line
								ratio = (double)potentialLines.get(i).getValidPoints()/newPotentialLines.get(newSize-1).getValidPoints();
								if(ratio<0.2) continue;//Valid data points of current line is out of expectation
								
								peakFlags = offsetInSamePeakEx(allPossibleLines,newPotentialLines.get(newSize-1).getLineIntercept(),potentialLines.get(i).getLineIntercept());
								if(peakFlags>=1) continue;//Current line and last line is in the same peak
								
								if(i+1<size && newSize>2){//Double check next line
									ratio = potentialLines.get(i+1).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
									ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
									if(ratio<maxOffsetChgRate){
										if(ratio<maxOffsetChgRate*0.6){
											continue;//Next line is very close to last line, so skip current line
										}else if(newSize>4){
											ratio = potentialLines.get(i+1).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
											ratio = ratio/(newPotentialLines.get(newSize-4).getLineIntercept()-newPotentialLines.get(newSize-5).getLineIntercept());
											if(ratio<maxOffsetChgRate) continue;//Offset change rate btw next and last line lower than upper control limit is true
										}
									}
								}
							}
						}
						
						//Check whether there is line btw current and last line
						exLine = getPotentialLineBtw(allPossibleLines,lastLineIdx,currLineIdx,newPotentialLines.get(newSize-1).getValidPoints());
						
						if(null!=exLine){
							ratio = 1.0;
							if(newSize>2){
								ratio = exLine.getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
								ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
							}
							if(ratio>minOffsetChgRate) newPotentialLines.add(exLine);
						}
					}
					newPotentialLines.add(potentialLines.get(i));
				}
			}
		}
		
		return newPotentialLines;
	}
	
	private ImgExtractLine getPotentialLineBtw(ArrayList<ImgExtractLine> allPossibleLines,int startIdx,int stopIdx,int refValidDataPts){
		ImgExtractLine exLine = null;
		int validPts = 0, maxValidPts = -1, maxIdx = -1, peakFlag = 0;
		double ratio = 0.0, startOffset = 0.0, stopOffset = 0.0, foundOffset = 0.0;
		boolean startCheck = false, lineFound = false;
		if(null!=allPossibleLines && startIdx>0 && stopIdx>startIdx && stopIdx<allPossibleLines.size() && refValidDataPts>0){
			startOffset = allPossibleLines.get(startIdx).getLineIntercept();
			stopOffset = allPossibleLines.get(stopIdx).getLineIntercept();
			
			for(int i=startIdx; i<=stopIdx; i++){
				validPts = allPossibleLines.get(i).getValidPoints();
				ratio = (double)validPts/refValidDataPts;
				if(ratio<0.15){
					if(!startCheck){
						startCheck = true;
						maxValidPts = validPts;
						maxIdx = i;
					}else{
						ratio = (double)maxValidPts/refValidDataPts;
						if(ratio>0.2){
							lineFound = true;
							break;
						}
					}
				}
				if(startCheck){
					if(maxValidPts<validPts){
						maxValidPts = validPts;
						maxIdx = i;
					}
				}
			}
			
			if(lineFound){
				foundOffset = allPossibleLines.get(maxIdx).getLineIntercept();
				peakFlag = offsetInSamePeakEx(allPossibleLines,startOffset,foundOffset);
				if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,foundOffset,stopOffset);
				if(0==peakFlag) exLine = allPossibleLines.get(maxIdx);
			}
		}
		
		return exLine;
	}
	
	private int getLineIndex(ArrayList<ImgExtractLine> allPossibleLines, double lineOffset){
		int idx = -1;
		double offsetDelta = 0.0, minDelta = 10000.0;
		if(null!=allPossibleLines && allPossibleLines.size()>0){
			for(int i=0; i<allPossibleLines.size(); i++){
				offsetDelta = allPossibleLines.get(i).getLineIntercept() - lineOffset;
				if(offsetDelta<-5) continue;
				if(offsetDelta>5) break;
				
				offsetDelta = Math.abs(offsetDelta);
				if(minDelta>offsetDelta){
					minDelta = offsetDelta;
					idx = i;
				}
			}
		}
		return idx;
	}
	
	private int getMaxValidDataPtsLineIndex(ArrayList<ImgExtractLine> allPossibleLines, double startOffset, double stopOffset){
		int idx = -1, maxPts = 0;
		double lineOffset = 0.0;
		if(null!=allPossibleLines && allPossibleLines.size()>0){
			for(int i=0; i<allPossibleLines.size(); i++){
				lineOffset = allPossibleLines.get(i).getLineIntercept();
				if(lineOffset>stopOffset) break;
				if(lineOffset<startOffset) continue;
				if(maxPts<allPossibleLines.get(i).getValidPoints()){
					maxPts = allPossibleLines.get(i).getValidPoints();
					idx = i;
				}
			}
		}
		
		return idx;
	}
	
	private ArrayList<ImgExtractLine> adjustAllSearchedLinesEx(ArrayList<ImgExtractLine> allPossibleLines,int[][] imgGrays,int defaultVal){
		double ratio = 0.0, bestRsq = 0.0, refOffset = 0.0, lastOffset = 0.0, baseLine = 0.0, baseThr = 0.0;
		int bestIdx = 0, scanRng = lineScanRange/2, scanStart = -scanRng, scanStop = scanRng, maxVPts = 0, tmpVPts = 0;
		int lastBestIdx = 0, minValidPts = 0, basePts = 0, peakFlag = 0;
		ArrayList<ImgExtractLine> adjustLines = new ArrayList<ImgExtractLine>();
		ArrayList<Integer> maxValidPts = new ArrayList<Integer>();
		ArrayList<Integer> possLinesIdx = new ArrayList<Integer>();
		ImgExtractLine tmpLine = null;
		int[] lineValidDataPts = getPossibleLinesValidDtPts(allPossibleLines);
		
		LinkedHashMap<Integer,Integer> peaks = MathUtils.getPeakValsEx(lineValidDataPts, lineScanRange, true);
		
		for(int idx:peaks.keySet()){
			refOffset = allPossibleLines.get(idx).getLineIntercept();
			bestRsq = allPossibleLines.get(idx).getLineRSQ();
			maxVPts = allPossibleLines.get(idx).getValidPoints();
			bestIdx = idx;
			
			//Get peak index fine tune range
			for(int i=-scanRng; i>=0; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(0==tmpLine.getLineRSQ()) scanStart = i;
			}
			for(int i=0; i<=scanRng; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(0==tmpLine.getLineRSQ()) scanStop = i;
			}
			
			//Fine tune the peak index
			for(int i=scanStart; i<=scanStop; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(null!=tmpLine && Math.abs(refOffset-tmpLine.getLineIntercept())<5){
					tmpVPts = tmpLine.getValidPoints();
					ratio = (double)tmpVPts/peaks.get(idx);
					if(ratio>0.95 && bestRsq<tmpLine.getLineRSQ()){
						bestRsq = tmpLine.getLineRSQ();
						bestIdx = idx+i;
					}
					if(maxVPts<tmpVPts) maxVPts = tmpVPts;
				}
			}
			tmpLine = allPossibleLines.get(bestIdx);
			
			if(11==adjustLines.size()){
				System.out.print("");
			}
			
			ratio = 1.0;
			if(adjustLines.size()>1){
				lastOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
				tmpVPts = maxValidPts.get(maxValidPts.size()-1);
				if(tmpVPts>0){
					lastBestIdx = possLinesIdx.get(possLinesIdx.size()-1);
					minValidPts = tmpLine.getValidPoints();
					for(int k=lastBestIdx; k<=bestIdx; k++){
						if(minValidPts>allPossibleLines.get(k).getValidPoints()) minValidPts=allPossibleLines.get(k).getValidPoints();
					}
					if(tmpVPts!=minValidPts){
						baseThr = (tmpVPts-minValidPts)*0.2+minValidPts;
						baseLine = 0.0; basePts = 0;
						for(int k=lastBestIdx; k<=bestIdx; k++){
							if(allPossibleLines.get(k).getValidPoints()<baseThr){
								baseLine += allPossibleLines.get(k).getValidPoints();
								basePts++;
							}
						}
						if(basePts>0){
							baseLine = baseLine / basePts;
							ratio = (double)(tmpLine.getValidPoints()-baseLine)/(tmpVPts-baseLine);
						}else{
							ratio = (double)(tmpLine.getValidPoints()-minValidPts)/(tmpVPts-minValidPts);
						}
					}
				}
			}
			
			if(0==lastOffset || lastOffset>0 && tmpLine.getLineIntercept()-lastOffset>=5){
				if(lastOffset>0 && ratio<=0.2){
					peakFlag = offsetInSamePeakEx(allPossibleLines,lastOffset,refOffset);
					if(peakFlag>=1){
						continue;
					}else if(adjustLines.size()>3){
						ratio = (refOffset-lastOffset)/(adjustLines.get(adjustLines.size()-2).getLineIntercept()-adjustLines.get(adjustLines.size()-3).getLineIntercept());
						if(ratio<minOffsetChgRate) continue;
					}
				}
				if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, defaultVal);
				adjustLines.add(tmpLine);
				maxValidPts.add(maxVPts);
				possLinesIdx.add(bestIdx);
			}
		}
		
		return adjustLines;
	}
	
	private ImgExtractLine searchLine(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, double startSearchOffset, double stopSearchOffset, double mySearchSlope, int maxSearchRange){
		ImgExtractLine finalLine = null;
//		finalLine = getLineBtw(startSearchOffset,stopSearchOffset);
//		if(null!=finalLine){
//			if(0==finalLine.getXAxisStart()) finalLine = setLineBoundary(finalLine, imgGrays, defaultVal);
//			return finalLine;
//		}
		
		boolean bLineFound = false;
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int validCnt = 0, nearCol = 0, noisePoints = 0, realPoints = 0;
		int invalidCnt = 0, minValidCol = imgWidth*2, maxValidCol = -1;
		double noiseRate = 0.0, slopeDelta = 0.0, validRate = 0.0;
		double offsetDelta1 = 0.0, offsetDelta2 = 0.0, offsetDelta3 = 0.0, offsetDelta = 0.0;
		double invalidRatio = 0.0, maxColDelta = 3.0;
		int searchMinCol = 0, searchMaxCol = 0;
		int lineSearchingRng = lineScanRange / 2;//Two sides searching
		if(maxSearchRange<lineScanRange) lineSearchingRng = maxSearchRange/2;
		if(lineSearchingRng<=0) return null;
		
		int[][] searchingLinesData = new int[imgWidth][imgHeight];
		for(int i=0; i<imgWidth; i++){
			searchingLinesData[i] = peakVals[i].clone();
		}
		
		int fittingMinPoints = (int)(imgWidth * minValidRatio * 0.8);
		double[] lineCoef = null;
		finalLine = new ImgExtractLine();
		
		LinkedHashMap<Integer,ImgExtractLine> possibleLines = new LinkedHashMap<Integer,ImgExtractLine>();
		int possibleLineIdx = -1, bestValidRateIdx = -1;
		double bestValidRate = 0.0;
		
		if(stopSearchOffset>imgHeight) stopSearchOffset=imgHeight;
		if(imgWidth > fittingMinPoints && imgHeight > lineSearchingRng){
			for(int i=lineSearchingRng; i<=(maxSearchRange-lineSearchingRng); i++){
				minValidCol = imgWidth*2; maxValidCol = -1;
				ImgExtractLine extractLine = new ImgExtractLine();
				ImgExtractLine.setMinRSQ(0.7f);
				
				for(int j=(imgWidth-1); j>=0; j--){
					nearCol = (int)(j*mySearchSlope+startSearchOffset)+i;
					searchMinCol = (int)(j*mySearchSlope+startSearchOffset);
					searchMaxCol = (int)(j*mySearchSlope+stopSearchOffset);
					if(searchMinCol<0 || searchMinCol>(imgHeight-1)) continue;
					if(searchMaxCol<0 || searchMaxCol>(imgHeight-1)) continue;
					
					if((nearCol-lineSearchingRng)>=0 && nearCol<=(searchMaxCol-lineSearchingRng)){
						for(int k=-lineSearchingRng; k<=lineSearchingRng; k++){
							if(peakVals[j][nearCol+k]<lineFitGrayThr){
								extractLine.addPoint(j, nearCol+k, peakVals[j][nearCol+k]);
								if((nearCol+k)<minValidCol) minValidCol = nearCol+k;
								if((nearCol+k)>maxValidCol) maxValidCol = nearCol+k;
								if(Math.abs(k)<=1) extractLine.addRealPoints(j, nearCol+k, 1);
							}
							if(imgGrays[j][nearCol+k]>=noiseGrayThr) extractLine.addInvalidPoints(1);
						}
					}
				}
				
				if(i>=lineSearchingRng){
//					saveSearchingLines(searchingLinesData,mySearchSlope,startSearchOffset,i+500);
				}
				
				validCnt = extractLine.getValidPoints();
				realPoints = extractLine.getRealPoints();
				invalidCnt = extractLine.getInvalidPoints();
				invalidRatio = (double)invalidCnt / (lineSearchingRng*2+1) / imgWidth;
				if((validCnt>=fittingMinPoints 
						|| maxSearchRange<=3 
						|| realPoints>=fittingMinPoints*0.8) 
						&& invalidRatio<maxInvalidRatio){
					lineCoef = extractLine.getLineCoef(false);
					slopeDelta = Math.abs(mySearchSlope-extractLine.getLineSlope());
					offsetDelta1 = lineCoef[1] - startSearchOffset;
					offsetDelta2 = (lineCoef[0]-mySearchSlope)*imgWidth/2+lineCoef[1]-startSearchOffset;
					offsetDelta3 = (lineCoef[0]-mySearchSlope)*(imgWidth-1)+lineCoef[1]-startSearchOffset;
					offsetDelta = (offsetDelta1+offsetDelta2+offsetDelta3)/3;
					
					if(maxValidCol-minValidCol>maxColDelta){
						validRate = extractLine.getValidRateByYAxis((maxValidCol+minValidCol)/2-1, (maxValidCol+minValidCol)/2+1);
					}else{
						validRate = 1.0;
					}
					
					if(slopeDelta<maxSlopeDelta 
							&& offsetDelta1>0 && offsetDelta2>0 && offsetDelta3>0 
							&& offsetDelta>minOffsetDelta*0.5){
						possibleLineIdx++;
						possibleLines.put(possibleLineIdx, extractLine);
						if(bestValidRate<validRate){
							bestValidRate = validRate;
							bestValidRateIdx = possibleLineIdx;
						}
					}
					
					if(null!=lineCoef && (ImgExtractLine.getMinRSQ()<=lineCoef[2] 
							|| (maxValidCol-minValidCol)<=maxColDelta 
							|| validRate>minValidRate) 
							&& slopeDelta<maxSlopeDelta 
							&& offsetDelta1>0 && offsetDelta2>0 && offsetDelta3>0
							&& offsetDelta>minOffsetDelta*0.5){
						for(int k=0; k<imgWidth; k++){
							nearCol = (int)(k*lineCoef[0]+lineCoef[1]);
							if(nearCol>noiseScanRng && nearCol<(imgHeight-noiseScanRng)){
								noisePoints = 0;
								for(int n=-noiseScanRng; n<=noiseScanRng; n++){
									if(peakVals[k][nearCol+n]<noiseGrayThr){
										if(Math.abs(n)>1){
											noisePoints++;
										}else{
											extractLine.addOnlinePoint();
										}
									}
								}
								if(noisePoints>0) extractLine.addSideNoise(noisePoints);
							}else{
								break;
							}
						}
						
						noiseRate = (double)extractLine.getNoisePoints() / extractLine.getOnlinePoints();
						if(extractLine.getOnlinePoints()>=(fittingMinPoints*0.8) 
							&& noiseRate<maxNoiseRate){
							
							extractLine = setLineBoundary(extractLine, imgGrays, defaultVal);
							finalLine = extractLine;
							bLineFound = true;
							break;
						}
					}
				}
			}
		}
		
		if(!bLineFound){
			if(possibleLines.size()>0 && bestValidRateIdx>=0){
				finalLine = possibleLines.get(bestValidRateIdx);
				finalLine = setLineBoundary(finalLine, imgGrays, defaultVal);
			}else{
				finalLine = null;
			}
		}
		
		if(null!=finalLine){
			if(logEnabled){
				LogUtils.rawLog("researchLineParas_", finalLine.printLineParas(0,true));
			}
		}
		
		return finalLine;
	}
	
	private LinkedHashMap<Integer,Double> getSharpChgPosition(double[] chgs){
		LinkedHashMap<Integer, Double> sharpChgPos = new LinkedHashMap<Integer, Double>();
		
		int col = chgs.length;
		int scanPoints = 4;//Two sides scanning
		int meatCndCnt = 0;
		if(col>8){
			for(int j=scanPoints; j<(col-scanPoints); j++){
				meatCndCnt = 0;
				for(int k=scanPoints; k>0; k--){
					if(0!=chgs[j] && chgs[j]<=chgs[j-k] && chgs[j]<=chgs[j+k]){
						meatCndCnt++;
					}
				}
				if(meatCndCnt==scanPoints){
					sharpChgPos.put(j, chgs[j]);
					j += scanPoints;
				}
			}
		}
		
		return sharpChgPos;
	}
	
	private void setLinesSharpChgPosition(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, int targetLinesQty){
		ImgExtractLine extLine = null;
		double lineSlope, lineOffset, stdevRatio = 0.0;
		double[] Xs = new double[10], Ys = new double[10], chgs = null, tmp = null;
		int firstChgPos = 0, nearCol = 0, imgHeight = imgGrays[0].length, size = 0;
		int start = -1, stop = -1, chgStopPos = 0;
		int[] grays = null;
		String str1 = "", str2 = "";
		String[] sGrays = new String[11];
		
		for(int lineIdx:linesMap.keySet()){
			extLine = linesMap.get(lineIdx);
			if(null!=extLine){
				lineSlope = extLine.getLineSlope();
				lineOffset = extLine.getLineIntercept()+extLine.getLineInterceptDelta();
				firstChgPos = extLine.getXAxisStart()+10;
				chgStopPos = extLine.getXAxisStop();
				chgs = new double[firstChgPos];
				grays = new int[firstChgPos];
				str1 = ""; str2 = "";
				for(int k=0; k<11; k++){
					sGrays[k] = "";
				}
				
				for(int i=firstChgPos; i>0;i--){
					size = 0;
					for(int k=0; k<10; k++){
						nearCol = (int)(k*lineSlope+lineOffset);
						if(nearCol>=0 && nearCol<imgHeight){
							try {
								Xs[k] = i + k;
								Ys[k] = imgGrays[(int)Xs[k]][nearCol];
								size++;
							} catch (Exception e) {
								System.out.println(Xs[k]+":"+i+"/"+k);
							}
						}
					}
					tmp = MathUtils.lineFitting(Xs, Ys, size);
					chgs[i-1] = tmp[0];
					nearCol = (int)(i*lineSlope+lineOffset);
					if(nearCol>=0 && nearCol<imgHeight){
						if(i<imgGrays.length) grays[i-1] = imgGrays[i][nearCol];
					}
					for(int k=-5; k<=5; k++){
						if((nearCol+k)>=0 && (nearCol+k)<imgHeight && i<imgGrays.length){
							sGrays[k+5] += "," + imgGrays[i][nearCol+k];
						}else{
							sGrays[k+5] += ",0";
						}
					}
					
					str1 += "," + i;
					str2 += "," + chgs[i-1];
				}
				
				LinkedHashMap<Integer,Double> sharpChgPos = getSharpChgPosition(chgs);
				LinkedHashMap<Integer,LinkedHashMap<SharpChgItems,Double>> sharpChgPosParas = new LinkedHashMap<Integer,LinkedHashMap<SharpChgItems,Double>>();
				size = -1;
				for(int key:sharpChgPos.keySet()){
					size++;
					if(start<0){
						start = key;
						continue;
					}else{
						stop = key;
					}
					LinkedHashMap<SharpChgItems,Double> statisticParas = new LinkedHashMap<SharpChgItems,Double>();
					tmp = extLine.getLineStatisticParas(linesMap, start, (start+stop)/2, imgGrays, lineIdx, evenLineLonger);
					stdevRatio = tmp[3];
					if(1==size){
						LinkedHashMap<SharpChgItems,Double> sttParas = new LinkedHashMap<SharpChgItems,Double>();
						double[] weightOfBeingLine = extLine.weightOfBeingLine(linesMap,firstChgPos-10, chgStopPos, 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, true, curLineIsLonger(lineIdx,evenLineLonger), false);
						sttParas.put(SharpChgItems.STDEV, tmp[3]);
						sttParas.put(SharpChgItems.STDEVRATIO, weightOfBeingLine[0]);
						sttParas.put(SharpChgItems.AREARATIO, tmp[4]);
						
						tmp = extLine.getLineStatisticParas(linesMap, firstChgPos-10, chgStopPos, imgGrays, lineIdx, evenLineLonger);
						sttParas.put(SharpChgItems.INNERGRAYRATIO, tmp[5]);
						sharpChgPosParas.put(start, sttParas);
					}
					tmp = extLine.getLineStatisticParas(linesMap, (start+stop)/2, stop, imgGrays, lineIdx, evenLineLonger);
					stdevRatio = tmp[3] / stdevRatio;
					
					statisticParas.put(SharpChgItems.STDEV, tmp[3]);
					statisticParas.put(SharpChgItems.STDEVRATIO, stdevRatio);
					statisticParas.put(SharpChgItems.AREARATIO, tmp[4]);
					statisticParas.put(SharpChgItems.INNERGRAYRATIO, tmp[5]);
					sharpChgPosParas.put(key, statisticParas);
					start = key;
				}
				extLine.setSharpChgPos(sharpChgPos);
				extLine.setSharpChgPosParas(sharpChgPosParas);
				
				if(logEnabled){
					LogUtils.rawLog("sharpChgGrays_", "X"+lineIdx+str1);
					LogUtils.rawLog("sharpChgGrays_", "S"+lineIdx+str2);
					for(int k=-5; k<=5; k++){
						LogUtils.rawLog("sharpChgGrays_", "G"+lineIdx+"("+k+")"+sGrays[k+5]);
					}
					LogUtils.rawLog("sharpChgPos_", extLine.printSharpChgPos(lineIdx));
				}
			}
		}
	}
	
	private double boundaryNewThreshold(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal, int boundaryIdx, int dblCfmDataPts){
		int imgWidth = imgGrays.length;
		int imgHeight = imgGrays[0].length;
		int counter1 = 0, nearCol = 0;
		
		double sumGray1 = 0.0, grayThr1 = lineFitGrayThr;
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		
		for(int k=boundaryIdx; k<imgWidth; k++){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(k<0 || nearCol<0 || nearCol>=imgHeight) continue;
			if(imgGrays[k][nearCol]<noiseGrayThr){
				counter1++;
				sumGray1 += imgGrays[k][nearCol];
			}
			if(counter1>=dblCfmDataPts) break;
		}
		if(counter1>0){
			grayThr1 = sumGray1 / counter1;
			grayThr1 = grayThr1 + (defaultVal - grayThr1)*0.25;
		}
		
		return grayThr1;
	}
	
	private boolean boundaryIsOK(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal, int boundaryIdx, int backwardPts, double grayThr1){
		boolean ok = false;
		int imgHeight = imgGrays[0].length;
		int nearCol = 0, continueCnt1 = 0;
		
		double minGray = 0.0;
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		
		for(int k=boundaryIdx; k>=boundaryIdx-backwardPts; k--){
			if(k<0) break;
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			
			//Check +/-1 tracks
			minGray = imgGrays[k][nearCol];
			if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
			if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
			
			if(minGray<grayThr1){
				if(continueCnt1<5) continueCnt1 = 0;
			}else{
				continueCnt1++;
			}
		}
		
		if(continueCnt1>=5) ok = true;
		return ok;
	}
	
	private ImgExtractLine setLineBoundary(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal){
		int imgWidth = imgGrays.length;
		int imgHeight = imgGrays[0].length;
		int start = (int)(imgWidth*0.5);
		int counter1 = 0, counter2 = 0, nearCol = 0, contCntThr = 5;
		int continueCnt1 = 0, continueCnt2 = 0, minGray = 0, continueCnt3 = 0;
		double sumGray1 = 0.0, grayThr1 = lineFitGrayThr, newGrayThr1 = grayThr1;
		double sumGray2 = 0.0, grayThr2 = lineFitGrayThr, meanGray2 = 150.0, grayThr3 = noiseGrayThr2;
		
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		for(int k=start; k<imgWidth; k++){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			if(imgGrays[k][nearCol]<noiseGrayThr){
				counter1++;
				sumGray1 += imgGrays[k][nearCol];
			}
		}
		if(counter1>0){
			grayThr1 = sumGray1 / counter1;
			grayThr1 = grayThr1 + (defaultVal - grayThr1)*0.25;
		}
		
		for(int k=start; k>=0; k--){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			
			//Check +/-1 tracks
			minGray = imgGrays[k][nearCol];
			if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
			if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
			
			if(minGray<grayThr1){
				if(continueCnt1<contCntThr) continueCnt1 = 0;//Reset only when the X Axis Start is not found
			}else{
				continueCnt1++;
			}
			if(contCntThr==continueCnt1){
				newGrayThr1 = boundaryNewThreshold(extractLine,imgGrays,defaultVal,k+contCntThr,30);//Renew the threshold for a double confirmation
				if(boundaryIsOK(extractLine,imgGrays,defaultVal,k+contCntThr,contCntThr+2,newGrayThr1)){
					extractLine.setXAxisStart(k+contCntThr);
					extractLine.setMeanGray((int)grayThr1);
				}else{
					grayThr1 = newGrayThr1;
					continueCnt1 = 0;
				}
			}
			
			//To find X Axis Stop after X Axis Start is found
			if(contCntThr<=continueCnt1){
				counter2++;
				sumGray2 += imgGrays[k][nearCol];
				meanGray2 = sumGray2 / counter2;
				grayThr2 = (meanGray2 + defaultVal) / 2;
				
				minGray = imgGrays[k][nearCol];
				if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
				if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
				
				if(minGray>=grayThr2){
					continueCnt2++;
				}else{
					if(continueCnt2<contCntThr) continueCnt2=0;
				}
				
				if(minGray>=grayThr3){
					continueCnt3++;
				}else{
					if(continueCnt3<contCntThr) continueCnt3=0;
				}
				
				if(contCntThr<=continueCnt2 || contCntThr<=continueCnt3){
					extractLine.setXAxisStop(k+contCntThr);
					break;
				}
			}
		}
		
		return extractLine;
	}
	
	private ImgExtractLine getBaseLine(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int continueCnt = 0, minHeight = imgHeight, maxHeight = 0;
		int startY = 0, stopY = 0, contCntThr = 5, baseAvgPts = 10;
		int[][] startLine = new int[imgWidth][imgHeight];
		double baseGVal = 0.0, baseFactor = 0.9;
		String title = "", data = "";
		
		for(int i=0; i<imgWidth; i++){
			startLine[i] = imgGrays[i].clone();
		}
		
		int nearCol = 0;
		ImgExtractLine extractLine = new ImgExtractLine();
		LinkedHashMap<Integer,Integer> baseLineXY = new LinkedHashMap<Integer,Integer>();
		
		for(int i=(imgWidth-1); i>(int)(imgWidth*0.45); i-=10){
			continueCnt = 0; baseGVal = 0.0;
			for(int j=0; j<baseAvgPts; j++){
				baseGVal += imgGrays[i][j];
			}
			baseGVal = baseGVal / baseAvgPts * baseFactor;
			
			for(int j=baseAvgPts; j<imgHeight; j++){
				if(imgGrays[i][j]<baseGVal){
					continueCnt++;
				}else{
					baseGVal = 0.0;
					for(int k=j; k>j-baseAvgPts; k--){
						baseGVal += imgGrays[i][k];
					}
					baseGVal = baseGVal / baseAvgPts * baseFactor;
					continueCnt = 0;
				}
				if(continueCnt>=contCntThr){
					if(minHeight>(j-contCntThr)) minHeight = j-contCntThr;
					if(maxHeight<(j-contCntThr)) maxHeight = j-contCntThr;
					extractLine.addPoint(i, j-contCntThr, imgGrays[i][j-contCntThr]);
					baseLineXY.put(i, j-contCntThr);
					break;
				}
			}
		}
		extractLine.getLineCoef(false);
		
		//Fetch base line raw data
		if(logEnabled){
			if(baseLineXY.size()>0){
				startY = minHeight - 20;
				stopY = maxHeight + 30;
				if(startY<0) startY = 0;
				if(stopY>=imgHeight) stopY = imgHeight - 1;
				
				title = "x,y,rawY";
				for(int y=startY; y<=stopY; y++){
					title += "," + y;
				}
				LogUtils.rawLog("baseLineXY_",title);
				for(Integer key:baseLineXY.keySet()){
					data = key + "," + baseLineXY.get(key) + ",gray";
					for(int y=startY; y<=stopY; y++){
						data += "," + imgGrays[key][y];
					}
					LogUtils.rawLog("baseLineXY_",data);
				}
			}
			
			double startLineSlope = extractLine.getLineSlope();
			double startLineOffset = extractLine.getLineIntercept();
			for(int k=0; k<imgWidth; k++){
				nearCol = (int)(k*startLineSlope+startLineOffset);
				if(nearCol>=0 && nearCol<imgHeight) startLine[k][nearCol] = 0;
			}
			saveImgData("graysStartLine_",startLine);
		}
		
		return extractLine;
	}
	
	private ImgExtractLine getBaseLineBackup(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int continueCnt = 0, minHeight = imgHeight, maxHeight = 0;
		int startY = 0, stopY = 0;
		int[][] startLine = new int[imgWidth][imgHeight];
		String title = "", data = "";
		
		for(int i=0; i<imgWidth; i++){
			startLine[i] = imgGrays[i].clone();
		}
		
		int nearCol = 0;
		ImgExtractLine extractLine = new ImgExtractLine();
		LinkedHashMap<Integer,Integer> baseLineXY = new LinkedHashMap<Integer,Integer>();
		
		for(int i=(imgWidth-1); i>(int)(imgWidth*0.45); i-=10){
			continueCnt = 0;
			for(int j=0; j<imgHeight; j++){
				if(imgGrays[i][j]<noiseGrayThr2){
					continueCnt++;
				}else{
					continueCnt = 0;
				}
				if(continueCnt>10){
					if(minHeight>(j-10)) minHeight = j-10;
					if(maxHeight<(j-10)) maxHeight = j-10;
					extractLine.addPoint(i, j-10, imgGrays[i][j-10]);
					baseLineXY.put(i, j-10);
					break;
				}
			}
		}
		
		//Fetch base line raw data
		if(baseLineXY.size()>0){
			startY = minHeight - 20;
			stopY = maxHeight + 30;
			if(startY<0) startY = 0;
			if(stopY>=imgHeight) stopY = imgHeight - 1;
			
			title = "x,y,rawY";
			for(int y=startY; y<=stopY; y++){
				title += "," + y;
			}
			LogUtils.rawLog("baseLineXY_",title);
			for(Integer key:baseLineXY.keySet()){
				data = key + "," + baseLineXY.get(key) + ",gray";
				for(int y=startY; y<=stopY; y++){
					data += "," + imgGrays[key][y];
				}
				LogUtils.rawLog("baseLineXY_",data);
			}
		}
		
		extractLine.getLineCoef(false);
		double startLineSlope = extractLine.getLineSlope();
		double startLineOffset = extractLine.getLineIntercept();
		for(int k=0; k<imgWidth; k++){
			nearCol = (int)(k*startLineSlope+startLineOffset);
			if(nearCol>=0 && nearCol<imgHeight) startLine[k][nearCol] = 0;
		}
		saveImgData("graysStartLine_",startLine);
		
		return extractLine;
	}
	
	private int[][] getPeakVals(int[][] imgGrays, int[][] initVals){
		int[][] peakVals = null;
		if(null != imgGrays){
			int row = imgGrays.length;
			int col = imgGrays[0].length;
			int scanPoints = 3;//Two sides scanning
			int positiveCnt = 0, negativeCnt = 0;
			peakVals = new int[row][col];
			if(col>5){
				for(int i=0; i<row; i++){
					peakVals[i] = initVals[i].clone();
					for(int j=scanPoints; j<col; j++){
						if((j+scanPoints)<col){
							positiveCnt = 0;
							negativeCnt = 0;
							for(int k=scanPoints; k>0; k--){
								if(imgGrays[i][j]>imgGrays[i][j-k] && imgGrays[i][j]>imgGrays[i][j+k]){
									positiveCnt++;
								}
								
								if(imgGrays[i][j]<imgGrays[i][j-k] && imgGrays[i][j]<imgGrays[i][j+k]){
									negativeCnt++;
								}
							}
							if(negativeCnt==scanPoints){
								peakVals[i][j] = imgGrays[i][j];
								j += scanPoints;
							}
							if(positiveCnt==scanPoints) j += scanPoints;
						}else{
							break;
						}
					}
				}
			}
		}
		
		if(null!=peakVals) saveImgData("graysPeakVals_",peakVals);
		return peakVals;
	}
	
	private void saveImgData(String filePrefix, int[][] data){
		if(logEnabled){
			int width = data.length;
			int height = data[0].length;
			String str = "";
			
	    	for (int i = 0; i < width; i++) {
	        	str = "";
	            for (int j = (height-1); j >= 0; j--) {
	                str += data[i][j]+",";
	            }
	            LogUtils.rawLog(filePrefix,str);
	        }
		}
	}
	
	private void saveSearchingLines(int[][] data, double slope, double offset, int index, String flag){
		if(logEnabled){
			int imgWidth = data.length, imgHeight = data[0].length, nearCol = 0;
			for(int k=0; k<imgWidth; k++){
				nearCol = (int)(k*slope+offset);
				if(nearCol>=0 && nearCol<imgHeight){
					if(data[k][nearCol]>230) data[k][nearCol] = 0;
				}
			}
			saveImgData("graysSeachingLine_"+flag+"_"+index+"_",data);
		}
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:46.436
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:46.436
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:46.436
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:46.439
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:46.439
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:46.458
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:46.460
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:46.493
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:597)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:46.496
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:597)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:46.935
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:46.938
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-31 15:09:48.962
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.sto.utils;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashMap;

import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.stream.ImageOutputStream;

import com.sto.base.PolePositionItems;
import com.sto.base.SharpChgItems;
import com.sto.data.ImgExtractLine;
import com.sto.data.ProductSpec;

public class ImageUtils {
	//Judge Criteria
	private final double minValidRatio = 0.15;//Very depending on the image quality
	private final double minValidRate = 0.7;//Check it in +/-1 line
	private final double maxInvalidRatio = 0.4;//There should be no much white area around the line
	private final double maxSlopeDelta = 0.1;//The lines should be parallel
	private final double minOffsetDelta = 3.0;//There should be some distance between two near line
	private final double maxNoiseRate = 0.4;//There should be no much noise around the line
	private final double maxOffsetChgRate = 1.4;//Check whether some line is missed
	private final double minOffsetChgRate = 0.7;//Check whether there is noise line
	private final int noiseScanRng = 2;//Two sides scanning
	private final int lineScanRange = 6;//One side scanning
	private int targetLinesQty = 16;//The total lines to extract
	private double lineFitGrayThr = 255 * 0.8;
	private final double noiseGrayThr = 255 * 0.9;
	private final double noiseGrayThr2 = 255 * 0.95;
	private final double noiseGrayThr3 = 255 * 0.15;
	private final double minBestRsq = 0.991;
	private final int lineIndexBase = 100;
	private boolean firstPoleIsLonger = false;
	private boolean firstPoleIsThicker = true;
	
	private int[][] finalData = null;
	private boolean logEnabled = true;
	private boolean evenPoleIsLonger = false;
	private long imgProcTime = 0;
	private long imgStartSavingT = 0;
	
	private ProductSpec productSpec = ProductSpec.getInstance();
	private LinkedHashMap<String, Object> criteria = null;
	
	private ArrayList<ImgExtractLine> allPossibleLines = new ArrayList<ImgExtractLine>();
	private ArrayList<ImgExtractLine> allPotentialLines = new ArrayList<ImgExtractLine>();
	private LinkedHashMap<String, Double> imgProcResultLength = new LinkedHashMap<String, Double>();
	private LinkedHashMap<String, Boolean> imgProcResultOK = new LinkedHashMap<String, Boolean>();
	private LinkedHashMap<String, Double> imgProcResultAngle = new LinkedHashMap<String, Double>();
	private LinkedHashMap<String, String> imgProcResultStr = new LinkedHashMap<String, String>();
	
	private void clearMemory(){
		allPossibleLines.clear();
		allPotentialLines.clear();
		imgProcResultLength.clear();
		imgProcResultOK.clear();
		imgProcResultAngle.clear();
	}
	
	public void setLogEnabled(boolean enabled){
		logEnabled = enabled;
	}
	
	public long getImgProcTime(){
		return imgProcTime;
	}
	
	public long getImgStartSavingTime(){
		return imgStartSavingT;
	}
	
	private PolePositionItems getPolePositionInImage(BufferedImage BI){
		PolePositionItems polePosition = PolePositionItems.TOPLEFT;
		int imgWidth = BI.getWidth(), imgHeight = BI.getHeight();
		int[] fourCornersGray = new int[4];
        int pixel = 0, minGray = 0, minGrayIdx = 0;
        
        int start = (int)(imgHeight*0.25), stop = start-10;
        int width = (int)(imgWidth*0.25);
        for(int height=start; height>stop; height--){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[0] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.25); stop = start-10;
        width = (int)(imgWidth*0.75);
        for(int height=start; height>stop; height--){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[1] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.75); stop = start+10;
        width = (int)(imgWidth*0.75);
        for(int height=start; height<stop; height++){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[2] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.75); stop = start+10;
        width = (int)(imgWidth*0.25);
        for(int height=start; height<stop; height++){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[3] += (pixel & 0xffffff - 0xffff00);
        }
		
        minGray = fourCornersGray[0];
        minGrayIdx = 0;
        for(int i=0; i<fourCornersGray.length; i++){
        	if(fourCornersGray[i]<minGray){
        		minGray = fourCornersGray[i];
        		minGrayIdx = i;
        	}
        }
        
        switch(minGrayIdx){
        case 0:
        	polePosition = PolePositionItems.TOPLEFT;
        	break;
        case 1:
        	polePosition = PolePositionItems.TOPRIGHT;
        	break;
        case 2:
        	polePosition = PolePositionItems.BOTTOMRIGHT;
        	break;
        case 3:
        	polePosition = PolePositionItems.BOTTOMLEFT;
        	break;
        }
        
		return polePosition;
	}
	
	private LinkedHashMap<PolePositionItems,Integer> getLayersQty(){
		LinkedHashMap<PolePositionItems,Integer> layers = new LinkedHashMap<PolePositionItems,Integer>();
		
		layers.put(PolePositionItems.BOTTOMRIGHT, 
				Integer.parseInt(""+criteria.get("lowerRightCornerLayers")));
		
		layers.put(PolePositionItems.BOTTOMLEFT, 
				Integer.parseInt(""+criteria.get("lowerLeftCornerLayers")));
		
		layers.put(PolePositionItems.TOPRIGHT, 
				Integer.parseInt(""+criteria.get("topRightCornerLayers")));
		
		layers.put(PolePositionItems.TOPLEFT, 
				Integer.parseInt(""+criteria.get("topLeftCornerLayers")));
		
		return layers;
	}
	
	private void setFirstPoleConfig(){
		String c1 = (String) criteria.get("firstPoleIsShorter");
		String c2 = (String) criteria.get("firstPoleIsThicker");
		
		if(null!=c1) firstPoleIsLonger = (1==Integer.parseInt(c1)?false:true);
		if(null!=c2) firstPoleIsThicker = (1==Integer.parseInt(c2)?true:false);
	}
	
	private ArrayList<Object> edgeFoundParas(BufferedImage BI, PolePositionItems polePosition, double baseFactor, int layersQty, boolean searchWidth, int grapWidthStart, int grapWidthStop
		, int i, int baseAvgPts, int searchStart, int searchStop, int searchPos, int continueCnt1
		, int continueCntThr, int backOffPixels
		, double currGray, double baseGVal, double searchLineFactor, double grapFactor, int[] heightRng
		, ArrayList<Double> slopes, double[] searchParas){
		
		ArrayList<Object> edgeParas = new ArrayList<Object>();
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int edgeStart = 0, edgeStop = 0, maxLen = 0;
        boolean edgeFound = false, forwardSearch = searchStart>searchStop?false:true;
        
		if(currGray<baseGVal){
    		continueCnt1++;
    		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
    			if(searchStart<=i+continueCntThr){
    				searchLineFactor = searchLineFactor*(forwardSearch?0.8:1.25);
    				if(searchWidth){
    					searchStart = (int)(imgWidth*searchLineFactor);
    				}else{
    					searchStart = (int)(imgHeight*searchLineFactor);
    				}
    				if(forwardSearch && searchStart<imgWidth-baseAvgPts || !forwardSearch && searchStart>baseAvgPts){
    					i = searchStart;
    					searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, forwardSearch);
    					baseGVal = searchParas[1] * baseFactor;
    					slopes.clear();
    					slopes.add(searchParas[2]);
        				continueCnt1=0;
    				}
    			}
    			
    			if(forwardSearch){
	    			edgeStart = i + backOffPixels;
	    			if(edgeStart>maxLen) edgeStart = maxLen;
	    			if(searchWidth){
	    				edgeStop = edgeStart - (int)(imgWidth*grapFactor);
	    			}else{
	    				edgeStop = edgeStart - (int)(imgHeight*grapFactor);
	    			}
	    			if(edgeStop<0) edgeStop = 0;
    			}else{
    				edgeStart = i - backOffPixels;
        			if(edgeStart<0) edgeStart = 0;
        			if(searchWidth){
        				edgeStop = edgeStart + (int)(imgWidth*grapFactor);
        			}else{
        				edgeStop = edgeStart + (int)(imgHeight*grapFactor);
        			}
        			if(edgeStop>maxLen) edgeStop = maxLen;
    			}
    			
    			edgeFound = true;
    		}
    		if(searchWidth && currGray<noiseGrayThr3 && null==heightRng){//Already enter the very dark region(almost search to the picture edge)
    			heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
				searchPos = (heightRng[0]+heightRng[1])/2;
				searchStart = (int)(imgWidth*searchLineFactor);
				i = searchStart;
				searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
				baseGVal = searchParas[1] * baseFactor;
				slopes.clear();
				slopes.add(searchParas[2]);
				continueCnt1=0;
    		}
    	}else{
    		baseGVal = searchParas[1] * baseFactor;
    		continueCnt1=0;
    	}
		
		edgeParas.add(0, continueCnt1);
		edgeParas.add(1, searchStart);
		edgeParas.add(2, edgeStart);
		edgeParas.add(3, edgeStop);
		edgeParas.add(4, baseGVal);
		
		return edgeParas;
	}
	
	private int[] getImgProcEdges(BufferedImage BI, PolePositionItems polePosition, double baseFactor, int layersQty, boolean searchWidth, int grapWidthStart, int grapWidthStop){
		int edgeStart = 0, edgeStop = 0, backOffPixels = 50, baseAvgPts = 10, searchPos = 0;
		int continueCnt1 = 0, continueCntThr = 5, maxLen = 0, searchStart = 0, searchStop = 0;
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int[] heightRng = null;
		double baseGVal = 0.0, grapFactor = 0.0, searchLineFactor = 0.0, currGray = 0.0;
		double[] searchParas = null;
		ArrayList<Double> slopes = new ArrayList<Double>();
		ArrayList<Object> edgeParas = null;
		
		if(searchWidth){
			maxLen = imgWidth - 1;
			grapFactor = 0.375;
			if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
	        	searchLineFactor = 0.85;
	        	if(polePosition==PolePositionItems.TOPRIGHT) searchLineFactor = 0.15;
	        	searchPos = (int)(imgHeight*searchLineFactor);
	        	searchStart = baseAvgPts; searchStop = imgWidth-1;
	        	edgeStart = searchStart;
				edgeStop = searchStart + (int)(imgWidth*grapFactor);
			}else{
				searchLineFactor = 0.15;
	        	if(polePosition==PolePositionItems.BOTTOMLEFT) searchLineFactor = 0.85;
	        	searchPos = (int)(imgHeight*searchLineFactor);
	        	searchStart = imgWidth-baseAvgPts; searchStop = 0;
	        	edgeStart = searchStart;
				edgeStop = searchStart - (int)(imgWidth*grapFactor);
			}
		}else{
			maxLen = imgHeight - 1;
			if(layersQty<=8){
				grapFactor = 0.25;
	        }else{
	        	grapFactor = 0.28 / 8.0 * layersQty;
	        }
			
			if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.BOTTOMLEFT){
	        	searchLineFactor = 0.75;
	        	if(polePosition==PolePositionItems.BOTTOMLEFT) searchLineFactor = 0.25;
	        	if(grapWidthStart<0 || grapWidthStop<0){
	        		searchPos = (int)(imgWidth*searchLineFactor);
	        	}else{
	        		searchPos = (grapWidthStart + grapWidthStop)/2;
	        	}
	        	searchStart = baseAvgPts; searchStop = imgHeight-1;
	        	edgeStart = searchStart;
				edgeStop = searchStart + (int)(imgHeight*grapFactor);
			}else{
				searchLineFactor = 0.25;
				if(polePosition==PolePositionItems.TOPRIGHT) searchLineFactor = 0.75;
				if(grapWidthStart<0 || grapWidthStop<0){
	        		searchPos = (int)(imgWidth*searchLineFactor);
	        	}else{
	        		searchPos = (grapWidthStart + grapWidthStop) / 2;
	        	}
	        	searchStart = imgHeight-baseAvgPts; searchStop = 0;
	        	edgeStart = searchStart;
				edgeStop = searchStart - (int)(imgHeight*grapFactor);
			}
		}
		
		searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
		currGray = searchParas[0];
		baseGVal = searchParas[1] * baseFactor;
		slopes.add(searchParas[2]);
		
		if(searchStart>searchStop){
        	for(int i=searchStart; i>=searchStop; i--){
        		searchParas = getEdgeSearchParas(BI, i, baseAvgPts, searchPos, searchWidth, false);
        		currGray = searchParas[0];
        		slopes.add(searchParas[2]);
        		
        		if(currGray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){
            			if(searchStart>=i-continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            				searchLineFactor = searchLineFactor*1.25;
            				if(searchWidth){
            					searchStart = (int)(imgWidth*searchLineFactor);
            				}else{
            					searchStart = (int)(imgHeight*searchLineFactor);
            				}
            				if(searchStart>baseAvgPts){
            					i = searchStart;
            					searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
            					baseGVal = searchParas[1] * baseFactor;
            					slopes.clear();
            					slopes.add(searchParas[2]);
	            				continueCnt1=0;
	            				continue;
            				}
            			}
            			edgeStart = i - backOffPixels;
            			if(edgeStart<0) edgeStart = 0;
            			if(searchWidth){
            				edgeStop = edgeStart + (int)(imgWidth*grapFactor);
            			}else{
            				edgeStop = edgeStart + (int)(imgHeight*grapFactor);
            			}
            			if(edgeStop>maxLen) edgeStop = maxLen;
            			break;
            		}
            		
            		if(searchWidth && currGray<noiseGrayThr3 && null==heightRng){//Already enter the very dark region(almost search to the picture edge)
            			heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
        				searchPos = (heightRng[0]+heightRng[1])/2;
        				searchStart = (int)(imgWidth*searchLineFactor);
        				i = searchStart;
        				searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
    					baseGVal = searchParas[1] * baseFactor;
    					slopes.clear();
    					slopes.add(searchParas[2]);
        				continueCnt1=0; 
        				continue;
            		}
            	}else{
            		baseGVal = searchParas[1] * baseFactor;
            		continueCnt1=0;
            	}
        	}
        }else{
        	for(int i=searchStart; i<=searchStop; i++){
        		searchParas = getEdgeSearchParas(BI, i, baseAvgPts, searchPos, searchWidth, true);
        		currGray = searchParas[0];
        		slopes.add(searchParas[2]);
        		
        		edgeParas = edgeFoundParas(BI, polePosition, baseFactor, layersQty, searchWidth, grapWidthStart, grapWidthStop
        				, i, baseAvgPts, searchStart, searchStop, searchPos, int continueCnt1
        				, int continueCntThr, int backOffPixels
        				, double currGray, double baseGVal, double searchLineFactor, double grapFactor, int[] heightRng
        				, ArrayList<Double> slopes, double[] searchParas);
        	}
        }
        
		return new int[]{edgeStart, edgeStop};
	}
	
	private double[] getEdgeSearchParas(BufferedImage BI, int currIdx, int baseAvgPts, int searchPos, boolean searchWidth, boolean forwardSearch){
		ArrayList<Integer> xAxis = new ArrayList<Integer>();
		ArrayList<Integer> yAxis = new ArrayList<Integer>();
		int pixel = 0, gray = 0, start = 0, stop = 0, currGray = 0;
		double avgGray = 0.0;
		double[] coef = null;
		
		if(forwardSearch){
			start = currIdx - baseAvgPts + 1; stop = currIdx;
		}else{
			start = currIdx; stop = currIdx + baseAvgPts - 1;
		}
		
		if(searchWidth){
			pixel = BI.getRGB(currIdx, searchPos);
			currGray = (pixel & 0xffffff - 0xffff00);
		}else{
			pixel = BI.getRGB(searchPos, currIdx);
			currGray = (pixel & 0xffffff - 0xffff00);
		}
		
		for(int i=start; i<=stop; i++){
			if(searchWidth){
    			pixel = BI.getRGB(i, searchPos);
            	gray = (pixel & 0xffffff - 0xffff00);
    		}else{
    			pixel = BI.getRGB(searchPos, i);
            	gray = (pixel & 0xffffff - 0xffff00);
    		}
			xAxis.add(i);
			yAxis.add(gray);
			avgGray += gray;
		}
		
		avgGray = avgGray / baseAvgPts;
		coef = MathUtils.lineFitting(xAxis, yAxis);
		
		return new double[]{(double)currGray,avgGray,coef[0]*coef[0]};
	}
	
	private int[] getImgProcWidthRng(BufferedImage BI, PolePositionItems polePosition, int layersQty){
		int[] widthRng = new int[2];
		int[] heightRng = null;
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int grapWidthStart = 0, grapWidthStop = 0, backOffPixels = 50, baseAvgPts = 10;
        int continueCnt1 = 0, start = 0, stop = 0, pixel = 0, gray = 0, continueCntThr = 5;
        double heightFactor = 0.0, widthFactor = 0.0, baseGVal = 0.0, baseFactor = 0.95;
		String strX = "X", strG = "G";
		
        if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
        	heightRng = null;
        	widthFactor = 0.25; heightFactor = 0.85;
        	if(polePosition==PolePositionItems.TOPRIGHT) heightFactor = 0.15;
        	start = (int)(imgWidth*widthFactor); stop = imgWidth-1;
        	int h = (int)(imgHeight*heightFactor);
        	
        	grapWidthStart = start;
			grapWidthStop = grapWidthStart + (int)(imgWidth*0.375);
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start-baseAvgPts; k<start; k++){
	        		pixel = BI.getRGB(k, h);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		widthFactor = widthFactor*0.8;
    				start = (int)(imgWidth*widthFactor);
    				if(start<=baseAvgPts){
    					start = baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int w=start; w<stop; w++){
        		pixel = BI.getRGB(w, h);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strX += "," + w;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){
            			if(start>=w-continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            				widthFactor = widthFactor*0.8;
            				start = (int)(imgWidth*widthFactor);
            				if(start>baseAvgPts){
            					w = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start-baseAvgPts; k<start; k++){
	            	        		pixel = BI.getRGB(k, h);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapWidthStart = w - backOffPixels;
            			if(grapWidthStart<0) grapWidthStart = 0;
            			grapWidthStop = grapWidthStart + (int)(imgWidth*0.375);
            			if(grapWidthStop>=imgWidth) grapWidthStop = imgWidth - 1;
            			break;
            		}
            		if(gray<noiseGrayThr3){//Already enter the very dark region(almost search to the picture edge)
            			if(null!=heightRng){
            				//If the height range is fixed, fixed the width range by guessing
	            			grapWidthStart = (int)(imgWidth*0.75);
	            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
	            			break;
            			}else{
            				heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
            				h = (heightRng[0]+heightRng[1])/2;
            				widthFactor = 0.25;
            				start = (int)(imgWidth*widthFactor);
            				w = start; continueCnt1=0; continue;
            			}
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=w; k>w-baseAvgPts; k--){
                		pixel = BI.getRGB(k, h);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(polePosition==PolePositionItems.TOPLEFT || polePosition==PolePositionItems.BOTTOMLEFT){
        	heightRng = null;
        	widthFactor = 0.75; heightFactor = 0.15;
        	if(polePosition==PolePositionItems.BOTTOMLEFT) heightFactor = 0.85;
        	start = (int)(imgWidth*widthFactor); stop = 0;
        	int h = (int)(imgHeight*heightFactor);
        	
        	grapWidthStart = start;
			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start+baseAvgPts; k>start; k--){
	        		pixel = BI.getRGB(k, h);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		widthFactor = widthFactor*1.25;
    				start = (int)(imgWidth*widthFactor);
    				if(start>=imgWidth-baseAvgPts){
    					start = imgWidth-baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int w=start; w>stop; w--){
        		pixel = BI.getRGB(w, h);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strX += "," + w;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start<=w+continueCntThr){
            				widthFactor = widthFactor*1.25;
            				start = (int)(imgWidth*widthFactor);
            				if(start<imgWidth-baseAvgPts){
            					w = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start+baseAvgPts; k>start; k--){
	            	        		pixel = BI.getRGB(k, h);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapWidthStart = w + backOffPixels;
            			if(grapWidthStart>=imgWidth) grapWidthStart = imgWidth - 1;
            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
            			if(grapWidthStop<0) grapWidthStop = 0;
            			break;
            		}
            		if(gray<noiseGrayThr3){//Already enter the very dark region(almost search to the picture edge)
            			if(null!=heightRng){
            				//If the height range is fixed, fixed the width range by guessing
	            			grapWidthStart = (int)(imgWidth*0.75);
	            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
	            			break;
            			}else{
            				heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
            				h = (heightRng[0]+heightRng[1])/2;
            				widthFactor = 0.75;
            				start = (int)(imgWidth*widthFactor);
            				w = start; continueCnt1=0; continue;
            			}
            		}
            	}else{
            		baseGVal = 0.0;
    	        	for(int k=start; k<start+baseAvgPts; k++){
    	        		pixel = BI.getRGB(k, h);
    	            	gray = (pixel & 0xffffff - 0xffff00);
    	        		baseGVal += gray;
    	        	}
    	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
    	        	
            		continueCnt1=0;
            	}
        	}
        }
		
        if(logEnabled){
        	LogUtils.rawLog("imgProcRegion_", strX);
        	LogUtils.rawLog("imgProcRegion_", strG);
        }
        
        widthRng[0] = grapWidthStart;
        widthRng[1] = grapWidthStop;
		return widthRng;
	}
	
	private int[] getImgProcHeightRng(BufferedImage BI, PolePositionItems polePosition, int layersQty, int grapWidthStart, int grapWidthStop){
		int[] heightRng = new int[2];
		int imgHeight = BI.getHeight();
		int imgWidth = BI.getWidth();
        int grapHeightStart = 0, grapHeightStop = 0, backOffPixels = 30, baseAvgPts = 10;
        int width = 0, continueCnt1 = 0, start = 0, stop = 0, pixel = 0, gray = 0, continueCntThr = 5;
        double heightFactor = 0.0, grapHeightFactor = 0.5, baseGVal = 0.0, baseFactor = 0.95;
        String strY = "Y", strG = "G";
        
        if(layersQty<=8){
        	grapHeightFactor = 0.25;
        }else{
        	grapHeightFactor = 0.28 / 8.0 * layersQty;
        }
		
        if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.BOTTOMLEFT){
        	heightFactor = 0.375;
        	start = (int)(imgHeight*heightFactor); stop = imgHeight-1;
        	
        	grapHeightStart = start;
			grapHeightStop = grapHeightStart + (int)(imgHeight*grapHeightFactor);
        	
        	if(grapWidthStart<0 || grapWidthStop<0){
        		if(polePosition==PolePositionItems.BOTTOMRIGHT) width = (int)(imgWidth*0.75);
        		if(polePosition==PolePositionItems.BOTTOMLEFT) width = (int)(imgWidth*0.25);
        	}else{
        		width = (grapWidthStart + grapWidthStop)/2;
        	}
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start-baseAvgPts; k<start; k++){
	        		pixel = BI.getRGB(width, k);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		heightFactor = heightFactor*0.8;
    				start = (int)(imgHeight*heightFactor);
    				if(start<=baseAvgPts){
    					start = baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int height=start; height<stop; height++){
        		pixel = BI.getRGB(width, height);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strY += "," + height;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start>=height-continueCntThr){
            				heightFactor = heightFactor*0.8;
            				start = (int)(imgHeight*heightFactor);
            				if(start>baseAvgPts){
            					height = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start-baseAvgPts; k<start; k++){
	            	        		pixel = BI.getRGB(width, k);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapHeightStart = height - backOffPixels;
            			if(grapHeightStart<0) grapHeightStart = 0;
            			grapHeightStop = grapHeightStart + (int)(imgHeight*grapHeightFactor);
            			if(grapHeightStop >= imgHeight){
            				grapHeightStart = grapHeightStart - (grapHeightStop-imgHeight);
            				grapHeightStop = imgHeight - 1;
            			}
            			break;
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=start; k>start-baseAvgPts; k--){
                		pixel = BI.getRGB(width, k);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(polePosition==PolePositionItems.TOPRIGHT || polePosition==PolePositionItems.TOPLEFT){
        	heightFactor = 0.625;
        	start = (int)(imgHeight*heightFactor); stop = 0;
        	
        	grapHeightStart = start;
			grapHeightStop = grapHeightStart - (int)(imgHeight*grapHeightFactor);
        	
        	if(grapWidthStart<0 || grapWidthStop<0){
        		if(polePosition==PolePositionItems.TOPRIGHT) width = (int)(imgWidth*0.75);
        		if(polePosition==PolePositionItems.TOPLEFT) width = (int)(imgWidth*0.25);
        	}else{
        		width = (grapWidthStart + grapWidthStop) / 2;
        	}
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start+baseAvgPts; k>start; k--){
	        		pixel = BI.getRGB(width, k);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		heightFactor = heightFactor*1.25;
    				start = (int)(imgHeight*heightFactor);
    				if(start>=imgHeight-baseAvgPts){
    					start = imgHeight - baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int height=start; height>stop; height--){
        		pixel = BI.getRGB(width, height);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strY += "," + height;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start<=height+continueCntThr){
            				heightFactor = heightFactor*1.25;
            				start = (int)(imgHeight*heightFactor);
            				if(start<imgHeight-baseAvgPts){
            					height = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start+baseAvgPts; k>start; k--){
	            	        		pixel = BI.getRGB(width, k);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapHeightStart = height + backOffPixels;
            			if(grapHeightStart>=imgHeight) grapHeightStart = imgHeight - 1;
            			grapHeightStop = grapHeightStart - (int)(imgHeight*grapHeightFactor);
            			if(grapHeightStop<0){
            				grapHeightStart = grapHeightStart - grapHeightStop;
            				grapHeightStop = 0;
            			}
            			break;
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=start; k<start+baseAvgPts; k++){
                		pixel = BI.getRGB(width, k);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(logEnabled){
        	LogUtils.rawLog("imgProcRegion_", strY);
        	LogUtils.rawLog("imgProcRegion_", strG);
        }
        
        heightRng[0] = grapHeightStart;
        heightRng[1] = grapHeightStop;
		return heightRng;
	}
	
	private int[] getImageProcRegion(BufferedImage BI, PolePositionItems polePosition, int layersQty){
		int[] grapImgStart = new int[4];
		int[] grapImgWidthRng = null, grapImgHeightRng = null;
		
		grapImgWidthRng = getImgProcWidthRng(BI,polePosition,layersQty);
		grapImgHeightRng = getImgProcHeightRng(BI,polePosition,layersQty,grapImgWidthRng[0],grapImgWidthRng[1]);
		
        grapImgStart[0] = grapImgHeightRng[0];
        grapImgStart[1] = grapImgHeightRng[1];
        grapImgStart[2] = grapImgWidthRng[0];
        grapImgStart[3] = grapImgWidthRng[1];
        
		return grapImgStart;
	}
	
	public boolean procImage(String imgRootDir, String imgFileName, boolean outImg, String specifiedSpec){
		boolean imgPassed = false;
		
        try {
			imgPassed = procImageEx(imgRootDir, imgFileName, outImg, specifiedSpec);
			clearMemory();
		} catch (Exception e) {
			LogUtils.errorLog("Process "+imgRootDir+File.separator+imgFileName+" error:"+e.getMessage());
		}
        
        return imgPassed;
	}
	
	private boolean procImageEx(String imgRootDir, String imgFileName, boolean outImg, String specifiedSpec){
		String src = imgRootDir + File.separator + imgFileName;
		criteria = productSpec.getData(imgRootDir);
		if(null==criteria){
			if(null!=specifiedSpec && !"".equals(specifiedSpec.trim())) criteria = productSpec.getData(specifiedSpec);
			if(null==criteria){
				System.out.println("Product Spec for "+imgRootDir+" is not set yet!");
				return false;
			}
		}
		
		long startProcTime = System.currentTimeMillis();
		File file = new File(src);
        BufferedImage BI = null;
        try{
            BI = ImageIO.read(file);
            if(null==BI){
            	System.out.println("Read "+src+" failed");
            	return false;
            }
        }catch(Exception e){
            e.printStackTrace();
            return false;
        }
        
        int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int grapHeightStart = 0, grapHeightStop = 0, grapHeight = 0;
        int grapWidthStart = 0, grapWidthStop = 0, grapWidth = 0;
        int[][] imgGrays = null, initVals = null, peakVals = null;
        int pixel = 0, gray = 0;
        
        PolePositionItems polePosition = getPolePositionInImage(BI);
        System.out.println("Pole Position:"+polePosition);
        
        LinkedHashMap<PolePositionItems,Integer> layers = getLayersQty();
        targetLinesQty = layers.get(polePosition)*2;
        if(targetLinesQty<=0) return false;
        LogUtils.clearLog(true);
        
        int[] imgProcRegion = getImageProcRegion(BI,polePosition,targetLinesQty/2);
        grapHeightStart = imgProcRegion[0]; grapHeightStop = imgProcRegion[1];
        grapWidthStart = imgProcRegion[2]; grapWidthStop = imgProcRegion[3];
        grapHeight = Math.abs(grapHeightStart-grapHeightStop);
        grapWidth = Math.abs(grapWidthStart-grapWidthStop);
        imgGrays = new int[grapWidth][grapHeight];
    	initVals = new int[imgGrays.length][imgGrays[0].length];
    	
    	if(grapWidthStop > grapWidthStart){
    		if(grapHeightStop > grapHeightStart){
    			//Bottom-right
    			for(int i=grapWidthStart; i<grapWidthStop; i++){
            		for(int j=grapHeightStart; j<grapHeightStop; j++){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[i-grapWidthStart][j-grapHeightStart] = gray;
            			initVals[i-grapWidthStart][j-grapHeightStart] = 255;
            		}
            	}
    		}else{
    			//Top-right
    			for(int i=grapWidthStart; i<grapWidthStop; i++){
            		for(int j=grapHeightStart; j>grapHeightStop; j--){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[i-grapWidthStart][grapHeightStart-j] = gray;
            			initVals[i-grapWidthStart][grapHeightStart-j] = 255;
            		}
            	}
    		}
    	}else{
    		if(grapHeightStop < grapHeightStart){
    			//Top-left
    			for(int i=grapWidthStart; i>grapWidthStop; i--){
            		for(int j=grapHeightStart; j>grapHeightStop; j--){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[grapWidthStart-i][grapHeightStart-j] = gray;
            			initVals[grapWidthStart-i][grapHeightStart-j] = 255;
            		}
            	}
    		}else{
    			//Bottom-left
    			for(int i=grapWidthStart; i>grapWidthStop; i--){
            		for(int j=grapHeightStart; j<grapHeightStop; j++){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[grapWidthStart-i][j-grapHeightStart] = gray;
            			initVals[grapWidthStart-i][j-grapHeightStart] = 255;
            		}
            	}
    		}
    	}
    	
        //Start image processing
        boolean imgPassed = false;
        allPossibleLines.clear();
        allPotentialLines.clear();
        imgProcResultLength.clear();
        imgProcResultOK.clear();
        imgProcResultAngle.clear();
        if(null!=imgGrays){
        	peakVals = getPeakVals(imgGrays,initVals);
            if(null!=peakVals){
            	setFirstPoleConfig();
            	ImgExtractLine baseLine = getBaseLine(peakVals,initVals,imgGrays,255);
            	if(null!=baseLine && baseLine.getLineRSQ()>0){
            		ArrayList<ImgExtractLine> extractLines = searchLines(peakVals,initVals,imgGrays,255,baseLine);
            		if(extractLines.size()>0){
            			imgPassed = checkLines(peakVals,initVals,imgGrays,255,baseLine,extractLines);
            		}
            	}else{
            		System.out.println("getBaseLine failed");
            	}
            }
        }
        
        //Save output image
        if(outImg){
        	BI = createBufferedImage(BI);
        	if(null!=finalData && finalData.length>0){
        		int realX = 0, realY = 0;
        		int firstLen = finalData.length, secondLen = finalData[0].length;
        		for(int i=0; i<firstLen; i++){
        			if(grapWidthStart>grapWidthStop){
    					realX = grapWidthStart - i;
    				}else{
    					realX = grapWidthStart + i;
    				}
        			
        			for(int j=0; j<secondLen; j++){
        				if(grapHeightStart>grapHeightStop){
        					realY = grapHeightStart - j;
        				}else{
        					realY = grapHeightStart + j;
        				}
        				
        				if(finalData[i][j]<255){
        					pixel = BI.getRGB(realX, realY);
        					if(4==finalData[i][j]){
        						BI.setRGB(realX, realY, Color.RED.getRGB());
        					}else{
        						if(evenPoleIsLonger && 0==finalData[i][j]%2 || !evenPoleIsLonger && 1==finalData[i][j]%2){
        							BI.setRGB(realX, realY, Color.ORANGE.getRGB());
        						}else{
        							BI.setRGB(realX, realY, Color.BLACK.getRGB());
        						}
        					}
        				}
        			}
        		}
        	}
        	
	        Iterator<ImageWriter> it = ImageIO.getImageWritersByFormatName("png");//
	        ImageWriter writer = it.next();
	        ImageOutputStream ios;
			try {
				writeProcResultInfo(imgFileName,BI,polePosition,imgPassed,imgWidth,imgHeight,startProcTime);
				if(imgPassed){
					ios = ImageIO.createImageOutputStream(new File(src+".OK.png"));
				}else{
					ios = ImageIO.createImageOutputStream(new File(src+".NG.png"));
				}
				writer.setOutput(ios);
		        writer.write(BI);
		        BI.flush();
		        ios.flush();
		        ios.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
        }
        
        String[] imgProcRslt = getImgProcRsltData(imgFileName);
        imgProcRslt[0] = imgProcRslt[0]+",imgSavingT(ms)";
        imgProcRslt[1] = imgProcRslt[1]+","+(System.currentTimeMillis()-getImgStartSavingTime());
        setImgProcRsltData(imgFileName,imgProcRslt[0],imgProcRslt[1]);
        
        return imgPassed;
	}
	
	private BufferedImage createBufferedImage(BufferedImage baseBI){
		int width = baseBI.getWidth();
		int height = baseBI.getHeight();
		
		BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
        bi.getGraphics().drawImage(baseBI, 0, 0,width, height, null);
        baseBI = null;
        
        return bi;
	}
	
	private void writeProcResultInfo(String imgFileName, BufferedImage BI, PolePositionItems polePosition, boolean imgPassed, int imgWidth, int imgHeight, long startProcTime){
		int txtX = 0, txtY = 0, txtOffset = 25, txtLine = 0, oriY = 0;
		double minL = 1000.0, maxL = -1000.0, curL = 0.0;
		String lenInfo = "", procRsltTitle = "", procRsltData = "";
		DecimalFormat df = new DecimalFormat("0.000");
		DecimalFormat df1 = new DecimalFormat("0.0");
		Graphics g = BI.getGraphics();
		g.setFont(new Font("Serif",Font.BOLD,54));
		g.setColor(imgPassed?Color.DARK_GRAY:Color.RED);
		if(polePosition==PolePositionItems.TOPLEFT || polePosition==PolePositionItems.BOTTOMLEFT){
			txtX = (int)(imgWidth*0.75);
			txtY = (int)(imgHeight*0.25);
		}else if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
			txtX = (int)(imgWidth*0.15);
			txtY = (int)(imgHeight*0.25);
		}
		oriY = txtY;
		
		g.drawString(imgPassed?"OK":"NG", txtX, txtY);
		g.setFont(new Font("Serif",Font.BOLD,18));
		txtLine = 3;
		txtY += txtOffset * txtLine;
		for(String key:imgProcResultLength.keySet()){
			txtY += txtOffset;
			curL = imgProcResultLength.get(key);
			lenInfo = key+" = "+df.format(curL);
			procRsltTitle += ","+key;
			procRsltData += ","+df.format(curL);
			
			if(null!=imgProcResultAngle.get(key)){
				lenInfo += " ["+df1.format(imgProcResultAngle.get(key))+"deg]";
			}
			
			if(imgProcResultOK.get(key)){
				g.setColor(Color.DARK_GRAY);
			}else{
				g.setColor(Color.RED);
			}
			g.drawString(lenInfo, txtX, txtY);
			if(minL>curL) minL = curL;
			if(maxL<curL) maxL = curL;
		}
		imgStartSavingT = System.currentTimeMillis();
		imgProcTime = imgStartSavingT-startProcTime;
		g.setColor(Color.DARK_GRAY);
		g.drawString("PRO_T = "+imgProcTime+" ms", txtX, oriY+txtOffset);
		g.drawString("MIN_L = "+df.format(minL)+" mm", txtX, oriY+txtOffset*2);
		g.drawString("MAX_L = "+df.format(maxL)+" mm", txtX, oriY+txtOffset*3);
		
		procRsltTitle = "procT(ms),MIN_L,MAX_L"+procRsltTitle;
		procRsltData = imgProcTime+","+df.format(minL)+","+df.format(maxL)+procRsltData;
		setImgProcRsltData(imgFileName,procRsltTitle,procRsltData);
	}
	
	public void clearImgProcRsltData(String imgFileName){
		imgProcResultStr.remove(imgFileName);
	}
	
	private void setImgProcRsltData(String imgFileName, String rsltTitle, String rsltData){
		imgProcResultStr.put(imgFileName, rsltTitle+"\r\n"+rsltData);
	}
	
	public String[] getImgProcRsltData(String imgFileName){
		String[] rsltStr = new String[]{"",""};
		String rslt = imgProcResultStr.get(imgFileName);
		if(null!=rslt) rsltStr = rslt.split("\r\n");
		return rsltStr;
	}
	
	private ArrayList<Object> getLinesTendencyParas(ArrayList<ImgExtractLine> extractLines, LinkedHashMap<Integer,ImgExtractLine> linesMap, int targetLinesQty){
		ArrayList<Object> tdcParas = new ArrayList<Object>();
		double[] coef = null, slope = null, offset = null;
		int reliableMaxIdx = 0, evenPoleCnt = 0, oddPoleCnt = 0;
		double evenPoleAvgOffset = 0.0, oddPoleAvgOffset = 0.0, finalRsq = 0.0;
		double evenMinOffset = 0.0, evenMaxOffset = 0.0, oddMinOffset = 0.0, oddMaxOffset = 0.0, curOffset = 0.0;
		
		LinkedHashMap<Double,Double> tendencyDt = new LinkedHashMap<Double,Double>();
		ArrayList<Double> tdcSlope = new ArrayList<Double>();
		ArrayList<Double> tdcOffset = new ArrayList<Double>();
		ArrayList<Double> tdcRsq = new ArrayList<Double>();
		
		if(null!=extractLines && extractLines.size()>0){
			if(null==linesMap){
				linesMap = new LinkedHashMap<Integer,ImgExtractLine>();
			}else if(!linesMap.isEmpty()){
				linesMap.clear();
			}
			
			for(int i=0; i<extractLines.size(); i++){
				if(i<targetLinesQty){
					linesMap.put(i, extractLines.get(i));
					tendencyDt.put((double)i, extractLines.get(i).getLineIntercept());
					if(i<2){
						tdcSlope.add(i,0.0);
						tdcOffset.add(i,0.0);
						tdcRsq.add(i,1.0);
						reliableMaxIdx = i;
					}else{
						coef = MathUtils.lineFitting(tendencyDt);
						tdcSlope.add(i,coef[0]);
						tdcOffset.add(i,coef[1]);
						tdcRsq.add(i,coef[2]);
						if(coef[2]>minBestRsq){
							reliableMaxIdx = i;
							finalRsq = coef[2];
						}
					}
				}else{
					break;
				}
			}
			
			//Recalculate the tendency
			if(reliableMaxIdx>5 && tdcRsq.get(reliableMaxIdx) < minBestRsq){
				LinkedHashMap<Double,Double> fittingDt = new LinkedHashMap<Double,Double>();
				for(int i=1; i<=reliableMaxIdx; i++){
					fittingDt.put((double)i, extractLines.get(i).getLineIntercept());
				}
				coef = MathUtils.lineFitting(fittingDt);
				finalRsq = coef[2];
			}
			
			//Calculate average offset of even & odd pole to its previous most-closed pole
			evenPoleAvgOffset=0.0; oddPoleAvgOffset=0.0;
			for(int i=1; i<=reliableMaxIdx; i++){
				curOffset = linesMap.get(i).getLineIntercept() - linesMap.get(i-1).getLineIntercept();
				if(0==i%2){
					evenPoleCnt++;
					evenPoleAvgOffset += curOffset;
					if(1==evenPoleCnt){
						evenMinOffset = curOffset; evenMaxOffset = curOffset;
					}else{
						if(evenMinOffset>curOffset) evenMinOffset = curOffset;
						if(evenMaxOffset<curOffset) evenMaxOffset = curOffset;
					}
				}else{
					oddPoleCnt++;
					oddPoleAvgOffset += curOffset;
					if(1==oddPoleCnt){
						oddMinOffset = curOffset; oddMaxOffset = curOffset;
					}else{
						if(oddMinOffset>curOffset) oddMinOffset = curOffset;
						if(oddMaxOffset<curOffset) oddMaxOffset = curOffset;
					}
				}
			}
			evenPoleAvgOffset = (evenPoleCnt>2)?(evenPoleAvgOffset-evenMinOffset-evenMaxOffset) / (evenPoleCnt-2):evenPoleAvgOffset / evenPoleCnt;
			oddPoleAvgOffset = (oddPoleCnt>2)?(oddPoleAvgOffset-oddMinOffset-oddMaxOffset) / (oddPoleCnt-2):oddPoleAvgOffset / oddPoleCnt;
		}
		
		tdcParas.add(0,finalRsq);
		tdcParas.add(1,evenPoleAvgOffset);
		tdcParas.add(2,oddPoleAvgOffset);
		tdcParas.add(3,reliableMaxIdx);
		if(tdcSlope.size()>0){
			slope = new double[tdcSlope.size()];
			offset = new double[tdcOffset.size()];
			for(int i=0; i<tdcSlope.size(); i++){
				slope[i] = tdcSlope.get(i);
				offset[i] = tdcOffset.get(i);
			}
		}
		tdcParas.add(4,slope);
		tdcParas.add(5,offset);
		
		return tdcParas;
	}
	
	private boolean checkLines(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, ImgExtractLine myBaseline, ArrayList<ImgExtractLine> extractLines){
		boolean bPassed = false;
		int extLinesQty = 0, bestRsqIdx = 0;
		double oddPoleAvgOffset = 0.0, evenPoleAvgOffset = 0.0;
		double[] slope = null, offset = null;
		
		LinkedHashMap<Integer,ImgExtractLine> linesMap = new LinkedHashMap<Integer,ImgExtractLine>();
		ArrayList<Object> tdcParas = null;
		
		extLinesQty = extractLines.size();
		if(extLinesQty>3){
			tdcParas = getLinesTendencyParas(extractLines, linesMap, targetLinesQty);
			if((double)tdcParas.get(0)<minBestRsq){
				System.out.println("RSQ NG:"+(double)tdcParas.get(0)+"(<"+minBestRsq+")");
				return bPassed;
			}
			evenPoleAvgOffset = (double)tdcParas.get(1);
			oddPoleAvgOffset = (double)tdcParas.get(2);
			bestRsqIdx = (int)tdcParas.get(3);
			slope = (double[]) tdcParas.get(4);
			offset = (double[]) tdcParas.get(5);
			
			//Recalculate the missing lines
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,false);
			}
			
			//Double check all lines
			evenPoleIsLonger = evenLineIsLonger(linesMap,imgGrays);
			System.out.println("bestIdx/evenOffset/oddOffset:"+bestRsqIdx
					+"/"+evenPoleAvgOffset+"/"+oddPoleAvgOffset
					+"/"+((currToLastOffsetDeltaIsBigger(2,evenPoleIsLonger)?
							((evenPoleAvgOffset>oddPoleAvgOffset)?"Correct":"Wrong"):
							((evenPoleAvgOffset<oddPoleAvgOffset)?"Correct":"Wrong"))));
			
			//Check one more layer inside if the first layer is longer
			if(evenPoleIsLonger && !firstPoleIsLonger){
				targetLinesQty = targetLinesQty + 1;
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,true);
			}
			
			//Compensate the longer layers
			linesMap = adjustLongerLines(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty,true);
			
			//Adjust all layers' index
			linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,true);
				linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			}
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = addMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
				linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			}
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = addMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
			}
			
			//Set all lines sharp change position
			linesMap = adjustLongerLines(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty,true);
			setLinesSharpChgPosition(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty);
			
			//Calculate the final result
			twoNearLayersOffsetCorrect(linesMap,evenPoleIsLonger);
			setLongerPolesLength(linesMap,imgGrays,peakVals,evenPoleIsLonger,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
			bPassed = calculateFinalResult(linesMap,evenPoleIsLonger,imgGrays,defaultVal,targetLinesQty,peakVals,evenPoleAvgOffset,oddPoleAvgOffset);
		}else{
			System.out.println("Extract Lines Qty:"+extractLines.size()+" is NG");
		}
		
		saveImgData("graysFinalLines_",finalData);
		System.out.println("Proc Result:"+(bPassed?"OK":"NG"));
		return bPassed;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> adjustLongerLines(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, int targetLinesQty, boolean bNotSetInterceptDelta){
		double[] weightOfLine = null;
		for(int lineIdx=0; lineIdx<targetLinesQty; lineIdx++){
			ImgExtractLine exLine = oriLinesMap.get(lineIdx);
			if(null!=exLine && 0==exLine.getXAxisStart()){
				exLine = setLineBoundary(exLine, imgGrays, 255);
				oriLinesMap.put(lineIdx, exLine);
			}
			
			if(curLineIsLonger(lineIdx,evenLineLonger)){
				if(null!=exLine){
					weightOfLine = exLine.weightOfBeingLine(oriLinesMap, exLine.getXAxisStop(), exLine.getXAxisStart(), 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, bNotSetInterceptDelta, curLineIsLonger(lineIdx,evenLineLonger), false);
					oriLinesMap.put(lineIdx, exLine);
					if(weightOfLine[0]<0.5) System.out.println("Weight of line("+lineIdx+"):"+weightOfLine[0]);
				}
			}
		}
		
		return oriLinesMap;
	}
	
	private int[] getPolePosX(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger, int targetLinesQty){
		double xPositionSum1 = 0.0, xPositionSum2 = 0.0;
		int counter1 = 0, counter2 = 0;
		int[] polePosX = new int[]{-1,-1};
		ImgExtractLine exLine = null;
		for(int lineIdx=0; lineIdx<targetLinesQty; lineIdx++){
			exLine = linesMap.get(lineIdx);
			if(null==exLine) continue;
			if(curLineIsLonger(lineIdx,evenLineLonger)){
				xPositionSum1 += exLine.getXAxisStop();
				counter1++;
			}else{
				xPositionSum2 += exLine.getXAxisStart();
				counter2++;
			}
		}
		if(counter1>0) polePosX[0] = (int)(xPositionSum1/counter1);
		if(counter2>0) polePosX[1] = (int)(xPositionSum2/counter2);
		return polePosX;
	}
	
	private boolean twoNearLayersOffsetCorrect(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger){
		boolean correct = true;
		ImgExtractLine currLine = null, lastLine = null;
		double evenPoleOffsetSum = 0.0, oddPoleOffsetSum = 0.0, offsetDelta = 0.0;
		double evenPoleAvgOffset = 0.0, oddPoleAvgOffset = 0.0;
		int evenPoleCnt = 0, oddPoleCnt = 0;
		
		for(Integer idx:linesMap.keySet()){
			currLine = linesMap.get(idx);
			lastLine = linesMap.get(idx-1);
			
			if(null!=currLine && null!=lastLine){
				offsetDelta = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				offsetDelta = offsetDelta-lastLine.getLineIntercept()-lastLine.getLineInterceptDelta();
				if(0==idx%2){
					evenPoleOffsetSum += offsetDelta;
					evenPoleCnt++;
				}else{
					oddPoleOffsetSum += offsetDelta;
					oddPoleCnt++;
				}
			}
		}
		if(evenPoleCnt>0) evenPoleAvgOffset=evenPoleOffsetSum/evenPoleCnt;
		if(oddPoleCnt>0) oddPoleAvgOffset=oddPoleOffsetSum/oddPoleCnt;
		correct = ((currToLastOffsetDeltaIsBigger(2,evenLineLonger)?
				((evenPoleAvgOffset>oddPoleAvgOffset)?true:false):
				((evenPoleAvgOffset<oddPoleAvgOffset)?true:false)));
		
		System.out.println("evenPoleAvgOffset/oddPoleAvgOffset:"
				+"/"+evenPoleAvgOffset+"/"+oddPoleAvgOffset
				+"/"+(correct?"Correct":"Wrong"));
		
		return correct;
	}
	
	private void setLongerPolesLength(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty){
		//Check the logic carefully
		int imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		int[][] tmpGrays = new int[imgWidth][imgHeight];
		for(int k=0; k<imgWidth; k++){
			tmpGrays[k] = imgGrays[k].clone();
		}
		double tmpSlope = 0.0, tmpOffset = 0.0, poleLength = 0.0;
		double oriSlope = tmpSlope, oriOffset = tmpOffset;
		double maxDnChkOffset = 0.0;
		boolean curLinePassed = false;
		int newXAxisStop = -1, wrinkleLineMaxOffset = 0;
		ImgExtractLine tmpLine = null, exLine = null;
		int[] polePosX = getPolePosX(linesMap,evenLineLonger,targetLinesQty);
		if(polePosX[0]<0 || polePosX[1]<0) return;
		
		int refPos = 0, minIdx = -1, oriCol = 0;
		int stopChkPos = 0, nearCol = 0, defaultVal = 255, lineFlag = 0;
		
		double maxPoleAngle = Double.parseDouble(""+criteria.get("maxPoleAngle"));
		double onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		double minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		double maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		
		for(int i=0; i<targetLinesQty; i++){
			if(i>=linesMap.size() || i>=10) break;
			if(!curLineIsLonger(i,evenLineLonger)) continue;
			exLine = linesMap.get(i);
			if(null==exLine || null==linesMap.get(i+1) || null==linesMap.get(i-1)) continue;
			if(i>0 && linesMap.get(i-1).getXAxisStart()-exLine.getXAxisStop()<minDistance) continue;
			if(i+1<linesMap.size() && linesMap.get(i+1).getXAxisStart()-exLine.getXAxisStop()<minDistance) continue;
			refPos = exLine.getXAxisStop();
			if(refPos-polePosX[0]<5) continue;
			
			curLinePassed = false;
			lineFlag = exLine.getLineFlag();
			tmpSlope = exLine.getLineSlope();
			tmpOffset = exLine.getLineIntercept();
			oriSlope = tmpSlope; oriOffset = tmpOffset;
			wrinkleLineMaxOffset = (int)(evenPoleAvgOffset+oddPoleAvgOffset)/2;
			maxDnChkOffset = (evenPoleAvgOffset+oddPoleAvgOffset)/2;
			
			tmpLine = exLine;
			if(null!=linesMap.get(i+2)){
				maxDnChkOffset = linesMap.get(i+2).getLineIntercept()+linesMap.get(i+2).getLineInterceptDelta();
				maxDnChkOffset = maxDnChkOffset - tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
			}else{
				maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i+1).getLineIntercept()-linesMap.get(i+1).getLineInterceptDelta();
				maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
			}
			
			minIdx = -1;
			stopChkPos = refPos - (int)maxDistance;
			if(stopChkPos<0) stopChkPos = 0;
			
			//Check down side
			LinkedHashMap<Double,Double> dnSideWrinkleLine = new LinkedHashMap<Double,Double>();
			dnSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,refPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
			
			double[] dnLineParas = null;
			double dnSideAngle = 0.0;
			if(dnSideWrinkleLine.size()>=5){
				dnLineParas = MathUtils.lineFitting(dnSideWrinkleLine);
				dnSideAngle = 90.0;
				if(-1!=tmpSlope*dnLineParas[0]){
					dnSideAngle = Math.abs((tmpSlope-dnLineParas[0])/(1+tmpSlope*dnLineParas[0]));
					dnSideAngle = Math.toDegrees(Math.atan(dnSideAngle));
				}
			}else{
				continue;
			}
			
			if(dnSideAngle>0){
				if(dnSideAngle<=maxPoleAngle){
					storeLayerAngle(evenLineLonger, i, dnSideAngle, 0);
					minIdx = imgWidth;
					for(double k:dnSideWrinkleLine.keySet()){
						if(k<minIdx) minIdx=(int)k;
					}
					newXAxisStop = minIdx;
					for(int k=refPos; k>=minIdx; k--){
						nearCol = (int)(k*tmpSlope+tmpOffset);
						for(int n=(int)maxDnChkOffset;n>0;n--){
							if(nearCol+n>=0 && nearCol+n<imgHeight){
								if(imgGrays[k][nearCol+n]<defaultVal){
									if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
										tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
									}
								}
							}
						}
					}
				}else{
					newXAxisStop = (int)((tmpOffset-dnLineParas[1])/(dnLineParas[0]-tmpSlope));
				}
			}
			
			if(newXAxisStop>=0){
				tmpLine.setXAxisStop(newXAxisStop);
				if(tmpLine.getXAxisStart()<newXAxisStop) tmpLine.setXAxisStart(newXAxisStop);
				tmpLine.setPolePosition(newXAxisStop);
				if(curLineIsLonger(i,evenLineLonger)){
					linesMap.put(i, tmpLine);
				}else{
					linesMap.put(i-1, tmpLine);
				}
				
				poleLength = linesMap.get(i-1).getXAxisStart()-tmpLine.getXAxisStop();
				if(poleLength>=minDistance && poleLength<=maxDistance) curLinePassed = true;
				
				if(!curLinePassed){
					lineFlag = 4;
				}else{
					lineFlag = lineIndexBase + i;
				}
				if(null!=dnLineParas && dnSideAngle<=maxPoleAngle){
					tmpSlope = dnLineParas[0];
					tmpOffset = dnLineParas[1];
					tmpLine.setCrossX(refPos);
					for(int k=newXAxisStop; k<=refPos; k++){
						nearCol = (int)(k*tmpSlope+tmpOffset);
						oriCol = (int)(k*oriSlope+oriOffset);
						if(nearCol<oriCol) nearCol = oriCol;
						if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
					}
				}
			}
		}
	}
	
	private boolean curLineIsLonger(int lineIdx, boolean evenLineLonger){
		boolean curLineLonger = false;
		if(0==lineIdx%2 && evenLineLonger || 1==lineIdx%2 && !evenLineLonger) curLineLonger = true;
		return curLineLonger;
	}
	
	private boolean currToLastOffsetDeltaIsBigger(int lineIdx, boolean evenLineLonger){
		boolean bigger = false;
		
		if(0==lineIdx%2 && firstPoleIsThicker || 1==lineIdx%2 && !firstPoleIsThicker){
			if(firstPoleIsLonger && evenLineLonger 
				|| !firstPoleIsLonger && !evenLineLonger) bigger=true;
		}
		
		return bigger;
	}
	
	private int[] getWeightChkRange(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap,LinkedHashMap<Integer, ImgExtractLine> newLinesMap,int oriLineIdx,int newLineIdx){
		int[] chkRange = new int[2];
		//Get the max range(Max start and Min stop) of the near three lines
		ImgExtractLine curLine = oriLinesMap.get(oriLineIdx);
		ImgExtractLine lastLine = newLinesMap.get(newLineIdx-1);
		ImgExtractLine nextLine = oriLinesMap.get(oriLineIdx+1);
		
		chkRange[0] = curLine.getXAxisStart();
		chkRange[1] = curLine.getXAxisStop();
		if(null!=lastLine){
			if(lastLine.getXAxisStart()>chkRange[0]) chkRange[0] = lastLine.getXAxisStart();
			if(lastLine.getXAxisStop()<chkRange[1]) chkRange[1] = lastLine.getXAxisStop();
		}
		if(null!=nextLine){
			if(nextLine.getXAxisStart()>chkRange[0]) chkRange[0] = nextLine.getXAxisStart();
			if(nextLine.getXAxisStop()<chkRange[1]) chkRange[1] = nextLine.getXAxisStop();
		}
		
		return chkRange;
	}
	
	private int[] shiftLineIndex(int[] oriLineIdx,int startIdx,int stopIdx,int shiftVal){
		int start = 0, stop = 0, baseVal = 0;
		if(startIdx<0) startIdx = 0;
		if(startIdx>=oriLineIdx.length) startIdx = oriLineIdx.length - 1;
		if(stopIdx<0) stopIdx = 0;
		if(stopIdx>=oriLineIdx.length) stopIdx = oriLineIdx.length - 1;
		
		if(startIdx>stopIdx){
			start = stopIdx;
			stop = startIdx;
		}else{
			start = startIdx;
			stop = stopIdx;
		}
		
		if(shiftVal<0){
			for(int k=start;k<=stop;k++){
				oriLineIdx[k] = oriLineIdx[k] + shiftVal;
			}
		}else{
			baseVal = oriLineIdx[start];
			for(int k=start;k<=stop;k++){
				baseVal = baseVal + shiftVal;
				if(oriLineIdx[k]<baseVal) oriLineIdx[k] = oriLineIdx[k] + shiftVal;
			}
		}
		
		return oriLineIdx;
	}
	
	private int shiftCurrentLineNext(ImgExtractLine currLine, ImgExtractLine lastLine, ImgExtractLine nextLine, int currLineIdx, int targetLinesQty, 
										double[] weightCurLine, double[] weightLastLine, double[] weightNextLine, boolean curLineIsLonger, int[][] imgGrays,
										LinkedHashMap<Integer, ImgExtractLine> linesMap, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean curLineIsThicker = false, curLineOffsetIsOK = false, curLineLengthIsOK = false, overhangFailed = false;
		boolean lastLineLengthIsOK = false, nextLineLengthIsOK = false;
		double curLineOffset = 0.0, lastLineOffset = 0.0, nextLineOffset = 0.0;
		double offsetChgR0 = 0.0, offsetChgR1 = 0.0, weightDiff = 0.0;
		int maxValidPtsLineIdxDelta = 0, shiftFlag = 0, peakFlag = 0;
		
		shiftFlag = 0;//Default is no need to shift current line
		curLineOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
		if(null!=lastLine){
			lastLineOffset = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
		}else{
			return shiftFlag;
		}
		
		if(1==currLineIdx%2){
			offsetChgR0 = (curLineOffset - lastLineOffset) / oddPoleAvgOffset;
		}else{
			offsetChgR0 = (curLineOffset - lastLineOffset) / evenPoleAvgOffset;
		}
		
		if(null!=nextLine){
			nextLineOffset = nextLine.getLineIntercept()+nextLine.getLineInterceptDelta();
			if(0==(currLineIdx+1)%2){
				offsetChgR1 = (nextLineOffset - curLineOffset) / evenPoleAvgOffset;
			}else{
				offsetChgR1 = (nextLineOffset - curLineOffset) / oddPoleAvgOffset;
			}
		}
		
		curLineLengthIsOK = (curLineIsLonger && weightCurLine[0]>=0.5 || !curLineIsLonger && weightCurLine[0]<0.5);
		curLineOffsetIsOK = (offsetChgR0>minOffsetChgRate && offsetChgR0<maxOffsetChgRate);
		
		lastLineLengthIsOK = (curLineIsLonger && weightLastLine[0]<0.5 || !curLineIsLonger && weightLastLine[0]>=0.5);
		if(null!=nextLine){
			nextLineLengthIsOK = (curLineIsLonger && weightNextLine[0]<0.5 || !curLineIsLonger && weightNextLine[0]>=0.5);
			weightDiff = Math.abs(weightCurLine[0]-weightNextLine[0]);
		}
		
		//Pre-screen conditions
		if(curLineLengthIsOK && lastLineLengthIsOK && nextLineLengthIsOK) return shiftFlag;
		
		if(curLineLengthIsOK && curLineOffsetIsOK){
			if(null!=nextLine && currLineIdx==targetLinesQty-2){
				if(offsetChgR0>maxOffsetChgRate*0.8 || offsetChgR1>maxOffsetChgRate || offsetChgR1<minOffsetChgRate){
					peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
					if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
					if(0==peakFlag){
						shiftFlag = 1;//Current line shift next
					}else if(!curLineIsLonger && weightNextLine[0]>weightCurLine[0] && weightDiff>0.2){
						//Suppose current line is correct
					}else if(offsetChgR0>maxOffsetChgRate*0.8){
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
						if(overhangFailed && weightDiff>0.2){
							maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
									-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
							if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
						}
					}
				}
			}
		}else{
			if(curLineLengthIsOK && offsetChgR0<=minOffsetChgRate){
				return shiftFlag;
			}else if(curLineLengthIsOK && offsetChgR0>=maxOffsetChgRate || !curLineLengthIsOK && curLineOffsetIsOK){//Possibly need to shift next
				if(currLineIdx!=targetLinesQty-2){
					if(thereIsPoleBtw(imgGrays,currLine,lastLine,true)){
						shiftFlag = 1;//Current line shift next
					}else{
						return shiftFlag;
					}
				}else{
					curLineIsThicker = lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0);
					if(firstPoleIsThicker && curLineIsThicker) return shiftFlag;
					
					if(null!=nextLine){
						if(curLineOffsetIsOK && lastLineLengthIsOK && nextLineLengthIsOK && offsetChgR1>minOffsetChgRate && offsetChgR1<maxOffsetChgRate
							&& !curLineIsLonger && weightNextLine[0]-weightCurLine[0]>0.2){
							//Suppose current line is correct
						}else{
							overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
							if(overhangFailed){
								peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
								if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
								if(offsetChgR1>maxOffsetChgRate || offsetChgR1<minOffsetChgRate){//Next line is out of expectation
									if(0==peakFlag){
										shiftFlag = 1;//Current line shift next
									}else{
										if(!curLineLengthIsOK){
											if(weightDiff>0.2) shiftFlag = 1;//Current line shift next(Give it a try)
										}
									}
								}else{
									if(curLineLengthIsOK){
										if(0==peakFlag) shiftFlag = 1;//Current line shift next
									}else{
										if(weightDiff>0.2) shiftFlag = 1;//Current line shift next(Give it a try)
									}
								}
							}else{
								if(!curLineLengthIsOK){
									if(offsetChgR0>maxOffsetChgRate*0.72){
										if(weightDiff>0.2){
											shiftFlag = 1;//Current line shift next(Give it a try)
										}else{
											maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
													-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
											if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
										}
									}
								}
							}
						}
					}else{
						maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
								-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx-1,lastLine,currLine,weightLastLine[0],weightCurLine[0]);
						if(0==maxValidPtsLineIdxDelta && overhangFailed){//There is no potential line after current line and overhang is NG btw current line and last line
							shiftFlag = 1;//Current line shift next(Give it a try)
						}
					}
				}
			}else if(!curLineLengthIsOK && offsetChgR0<=minOffsetChgRate){//Current line is too closed to last line, should be skipped
				shiftFlag = -1;//Skip current line
			}else if(!curLineLengthIsOK && offsetChgR0>=maxOffsetChgRate){//Possibly need to shift next
				if(currLineIdx==targetLinesQty-2){
					curLineIsThicker = lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0);
					if(firstPoleIsThicker && curLineIsThicker) return shiftFlag;
					
					peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
					if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
					if(0==peakFlag){
						shiftFlag = 1;//Current line shift next
					}else if(offsetChgR0>maxOffsetChgRate*0.8 && null!=nextLine){
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
						if(overhangFailed && weightDiff>0.2){
							if(offsetChgR0>maxOffsetChgRate && weightDiff>0.5){
								shiftFlag = 1;
							}else{
								maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
										-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
								if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
							}
						}
					}
				}
			}
		}
		
		return shiftFlag;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> doubleCheckAllLinesNew(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap, int[][] peakVals, int[][] initVals, int[][] imgGrays, boolean evenLineLonger, int targetLinesQty, double evenPoleAvgOffset, double oddPoleAvgOffset, double linesTendency_Slope, double linesTendency_Offset){
		LinkedHashMap<Integer, ImgExtractLine> linesMap = new LinkedHashMap<Integer, ImgExtractLine>();
		LinkedHashMap<Integer, ImgExtractLine> newLinesMap = new LinkedHashMap<Integer, ImgExtractLine>();
		ImgExtractLine currLine = null, nextLine = null, lastLine = null;
		
		for(int i=0; i<targetLinesQty; i++){
			if(null!=oriLinesMap.get(i)) linesMap.put(i, oriLinesMap.get(i));
		}
		int[] newLineIdx = new int[linesMap.size()];
		int[] oriLineIdx = new int[linesMap.size()];
		
		int idx = -1, lineIdx = -1, shiftFlag = 0, maxValidPtsLineIdxDelta = 0;
		int[] weightChkRange = null;
		boolean curLineIsLonger = false, curLineIsConfirmed = false, overhangFailed = false;
		boolean curLineLengthIsOK = false, curLineOffsetIsOK = false;
		boolean lastLineLengthIsOK = false, nextLineLengthIsOK = false;
		double[] weightCurLine = null, weightLastLine = null, weightNextLine = null, weight3 = null;
		double offsetChgR0 = 0.0, offsetChgR1 = 0.0, offsetChgR2 = 0.0;
		double nextLineOffset = 0.0, lastLineOffset = 0.0, curLineOffset = 0.0;
		
		for(int key:linesMap.keySet()){
			idx++;
			newLineIdx[idx] = key;//The final line index(will be adjusted in this routine)
			oriLineIdx[idx] = key;//The 1st guessing line index
		}
		
		for(int i=0; i<=idx; i++){
			if(newLineIdx[i]>=targetLinesQty) break;
			offsetChgR0 = 0.0; offsetChgR1 = 0.0; offsetChgR2 = 0.0;
			weightLastLine = null; weightNextLine = null;
			lastLineLengthIsOK = false; nextLineLengthIsOK = false;
			lineIdx = oriLineIdx[i];
			currLine = linesMap.get(lineIdx);//The line to be checked
			lastLine = newLinesMap.get(newLineIdx[i]-1);
			nextLine = linesMap.get(lineIdx+1);
			if(null!=currLine){
				if(currLine.getLineChecked()){
					newLinesMap.put(newLineIdx[i], currLine);
					continue;
				}
				curLineIsLonger = curLineIsLonger(newLineIdx[i],evenLineLonger);
				curLineOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				if(null!=lastLine){
					lastLineOffset = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
				}else{
					lastLineOffset = linesTendency_Slope*(newLineIdx[i]-1)+linesTendency_Offset;
				}
				if(1==newLineIdx[i]%2){
					offsetChgR0 = (curLineOffset - lastLineOffset) / oddPoleAvgOffset;
				}else{
					offsetChgR0 = (curLineOffset - lastLineOffset) / evenPoleAvgOffset;
				}
				if(offsetChgR0<0) continue;
				
				if(null!=nextLine){
					nextLineOffset = nextLine.getLineIntercept()+nextLine.getLineInterceptDelta();
					if(0==(newLineIdx[i]+1)%2){
						offsetChgR1 = (nextLineOffset - curLineOffset) / evenPoleAvgOffset;
						offsetChgR2 = (nextLineOffset - lastLineOffset) / evenPoleAvgOffset;
					}else{
						offsetChgR1 = (nextLineOffset - curLineOffset) / oddPoleAvgOffset;
						offsetChgR2 = (nextLineOffset - lastLineOffset) / oddPoleAvgOffset;
					}
				}
				
				if(12==lineIdx){
					System.out.print("");
				}
				
				weightChkRange = getWeightChkRange(linesMap,newLinesMap,lineIdx,newLineIdx[i]);
				weightCurLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, true, curLineIsLonger(newLineIdx[i],evenLineLonger), false);
				if(null!=lastLine){
					weightLastLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, newLineIdx[i]-1, targetLinesQty, true, curLineIsLonger(newLineIdx[i]-1,evenLineLonger), false);
					lastLineLengthIsOK = (curLineIsLonger && weightLastLine[0]<0.5 || !curLineIsLonger && weightLastLine[0]>=0.5);
				}
				if(null!=nextLine){
					weightNextLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx+1, targetLinesQty, true, curLineIsLonger(newLineIdx[i]+1,evenLineLonger), false);
					nextLineLengthIsOK = (curLineIsLonger && weightNextLine[0]<0.5 || !curLineIsLonger && weightNextLine[0]>=0.5);
				}
				
				curLineLengthIsOK = (curLineIsLonger && weightCurLine[0]>=0.5 || !curLineIsLonger && weightCurLine[0]<0.5);
				curLineOffsetIsOK = (offsetChgR0>minOffsetChgRate && offsetChgR0<maxOffsetChgRate);
				
				curLineIsConfirmed = false;
				//1.Expected case handling - Length of current pole is in expectation
				if(curLineLengthIsOK){
					//Offset variation of the most inner two poles could be bigger
					if(newLineIdx[i]==targetLinesQty-2){
						if(null!=nextLine){
							if(nextLine.getLineChecked()){//The most inner pole has confirmed
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
						//Length of current,left and right poles is in expectation
						if(!curLineIsConfirmed && lastLineLengthIsOK && nextLineLengthIsOK
							&& offsetChgR0>minOffsetChgRate*0.75){ //Pole offset meets the lower limit
							currLine.setLineChecked(true);
							newLinesMap.put(newLineIdx[i], currLine);
							curLineIsConfirmed = true;
						}
						//Offset of current pole is in control limit
						if(!curLineIsConfirmed){
							shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
									weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
									newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
							if(0<=shiftFlag){
								//Shift current line to next line
								if(1==shiftFlag) newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}else if(null!=lastLine && offsetChgR0>minOffsetChgRate*0.75 //Lower offset control limit could be loser while pole length is in expectation
						&& offsetChgR0<=maxOffsetChgRate //Pole offset is in control limit
						|| 0==newLineIdx[i] //Current line represents the most outer pole(the 1st pole)
						|| null!=lastLine && 1==currLine.getLineFlag() //Last line is fixed and current line is in the expected tendency
						|| null!=lastLine && curLineOffsetIsOK //Pole offset is in control limit
							//Current pole is the most inner pole and last pole is fixed
							&& newLineIdx[i]==targetLinesQty-1){
						//Key conditions:
						//(1)Last pole is fixed and offset of current pole is in ctrl limit
						//(2)Last pole is fixed and current pole is in ctrl tendency
						currLine.setLineChecked(true);
						newLinesMap.put(newLineIdx[i], currLine);
						curLineIsConfirmed = true;
					}
				}else if(0==newLineIdx[i] //Current line represents the most outer pole(the 1st pole)
					&& (offsetChgR0<=maxOffsetChgRate //Pole offset is in control criteria
						|| curLineIsLonger && weightCurLine[0]<0.5 //Length of current pole and next pole is very closed
						//Length of the most outer pole is not expected, which is usually caused by a longer
						//pole clings to the most outer short pole which leads to failed detection of short pole
						|| !curLineIsLonger && weightCurLine[0]>=0.5)){
					currLine.setLineChecked(true);
					newLinesMap.put(newLineIdx[i], currLine);
					curLineIsConfirmed = true;
				}else if(evenLineLonger && 1==newLineIdx[i]
					&& weightCurLine[0]>=0.5
					&& offsetChgR0>minOffsetChgRate*0.6){
					currLine.setLineChecked(true);
					newLinesMap.put(newLineIdx[i], currLine);
					curLineIsConfirmed = true;
				}
				
				//2.Common case handling
				if(!curLineIsConfirmed){//Length of current pole is out of expectation
					//2-1.Try to fix last pole first
					if(null==lastLine){ //Last pole is missing
						if(offsetChgR0<minOffsetChgRate //Current pole is too closed to last pole
							//Length of current pole is not expected
							|| offsetChgR0<maxOffsetChgRate*0.85 && !curLineLengthIsOK
							//Current line represents negative pole and last pole is negative pole
							|| offsetChgR0<maxOffsetChgRate*0.85 
								&& lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0) //Current line represents negative pole
								&& lineIsNegPole(newLineIdx[i]-1,evenLineLonger,evenPoleAvgOffset,oddPoleAvgOffset) //Last pole is negative pole
							//Current line represents the most inner pole and last pole is negative pole
							|| offsetChgR0<maxOffsetChgRate*0.75 && newLineIdx[i]==targetLinesQty-1 
								&& lineIsNegPole(newLineIdx[i]-1,evenLineLonger,evenPoleAvgOffset,oddPoleAvgOffset) //Last pole is negative pole
							//Current line represents the most inner pole and length of current pole is not expected
							|| offsetChgR0<maxOffsetChgRate*1.5 && newLineIdx[i]==targetLinesQty-1 
								&& (curLineIsLonger && weightCurLine[0]<0.45 //Length of current pole is not expected
									|| !curLineIsLonger && weightCurLine[0]>=0.5)){
							if(!lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0)
								&& newLineIdx[i]==targetLinesQty-1
								&& curLineIsLonger && weightCurLine[0]>0.5){
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}else{
								//Shift current line to previous line
								newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,-1);
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}else if((offsetChgR0>maxOffsetChgRate || newLineIdx[i]==targetLinesQty-1)//Offset of current pole is bigger or current pole is the most inner pole
							&& (curLineIsLonger && weightCurLine[0]>0.45 //Length of current pole is in expectation
								|| !curLineIsLonger && weightCurLine[0]<0.5)){
								//Offset of current pole exceeds upper limit but length of it is in expectation
								if(newLineIdx[i]==targetLinesQty-1 && curLineIsLonger
									&& weightCurLine[0]>=0.5 && lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0)){
									//Shift current line to previous line
									newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,-1);
								}
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
						}
					}
					//2-2.Refer to next line first since last line is supposed correct
					if(!curLineIsConfirmed && null!=nextLine){
						if(nextLineLengthIsOK){//Length of next pole is in expectation
							if(curLineLengthIsOK && nextLineLengthIsOK){
								//Offset of both current and next poles is on target
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}else{//Length of next pole is out of expectation
							if(offsetChgR1<minOffsetChgRate && offsetChgR2<maxOffsetChgRate){//Next pole is too closed to current pole
								if(newLineIdx[i]==targetLinesQty-2 && nextLine.getLineChecked()){
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}else{
									//Shift next line to current line
									newLineIdx=shiftLineIndex(newLineIdx,i+1,linesMap.size()-1,-1);
									nextLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], nextLine);//Shift next line to current line
								}
								curLineIsConfirmed = true;
							}else if((offsetChgR0>maxOffsetChgRate*0.85 || newLineIdx[i]==targetLinesQty-2 && offsetChgR0>minOffsetChgRate*0.6)//Offset of current pole is in expectation
									//Current pole is longer(expect shorter) than next pole
									&& !curLineIsLonger && weightCurLine[0]-weightNextLine[0]>0.15
							){
								//TODO Verification
								shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
										weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
										newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
								if(0<=shiftFlag){
									//Shift current line to next line
									if(1==shiftFlag) newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
								}
								curLineIsConfirmed = true;
							}else if(offsetChgR0>maxOffsetChgRate){
								maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
										-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
								overhangFailed = twoNearLinesOverhangFailed(newLineIdx[i],currLine,nextLine,weightCurLine[0],weightNextLine[0]);
								if(0==maxValidPtsLineIdxDelta || overhangFailed){
									//Shift current line to next line
									newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
								}
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}else if(offsetChgR0>minOffsetChgRate*0.6 && offsetChgR1<maxOffsetChgRate
								&& 1==currLine.getLineFlag()){
								//Offset of next pole is in expectation
								//Offset of current pole meets the lower limit and it is in expecting tendency
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}
					//2-3.Refer to last line
					if(!curLineIsConfirmed && null!=lastLine){
						if(lastLineLengthIsOK){//Length of last pole is in expectation
							if(newLineIdx[i]==targetLinesQty-2){
								if(offsetChgR0>minOffsetChgRate*0.5){
									shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
											weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
											newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
									if(1==shiftFlag){
										//Shift current line to next line
										newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
									}
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}
							}else if(newLineIdx[i]==targetLinesQty-1 && curLineIsLonger){
								if(weightCurLine[0]>0.5 && currLine.getTendencyRSQ()>minBestRsq){
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}else{
									//Enlarge inner side searching range
									double researchOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta()+3;
									double researchOffsetStop = researchOffset + (evenPoleAvgOffset+oddPoleAvgOffset)/2*3;
									double researchSlope = currLine.getLineSlope();
									ImgExtractLine exLine = null;
									exLine = searchLine(peakVals, initVals, imgGrays, 255, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
									if(null!=exLine){
										linesMap.put(lineIdx+1, exLine);
										weight3 = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx+1, targetLinesQty, true, curLineIsLonger(newLineIdx[i],evenLineLonger), false);
										if(weight3[0]>0.5 && weight3[0]>weightCurLine[0]
											|| weight3[0]>weightCurLine[0] && currLine.getTendencyRSQ()<minBestRsq){
											exLine.setLineChecked(true);
											newLinesMap.put(newLineIdx[i], exLine);
											curLineIsConfirmed = true;
										}
									}
									if(!curLineIsConfirmed){
										currLine.setLineChecked(true);
										newLinesMap.put(newLineIdx[i], currLine);
										curLineIsConfirmed = true;
									}
								}
							}
							
							//Offset of current pole is in a more expecting range
							if(!curLineIsConfirmed && offsetChgR0>minOffsetChgRate*1.1 && offsetChgR0<maxOffsetChgRate){
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}
				}
				
				//3.Abnormal case handling
				if(!curLineIsConfirmed){
					if(null!=lastLine && null!=nextLine){
						//Length of last and next poles is in expectation
						//Offset of last and next poles exceed the upper limit(they are far way from current pole)
						//Length of current pole is out of expectation
						if(offsetChgR0>maxOffsetChgRate && offsetChgR0<maxOffsetChgRate*1.5
							&& offsetChgR1>maxOffsetChgRate && offsetChgR1<maxOffsetChgRate*1.5
							&& (curLineIsLonger && weightCurLine[0]<0.5 
									&& weightLastLine[0]<0.5 && weightNextLine[0]<0.5
								|| !curLineIsLonger && weightCurLine[0]>=0.5
									&& weightLastLine[0]>=0.5 && weightNextLine[0]>=0.5)){
							//Shift current line to next line
							newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
							currLine.setLineChecked(true);
							newLinesMap.put(newLineIdx[i], currLine);
							curLineIsConfirmed = true;
						}
					}
				}
			}
		}
		
		return newLinesMap;
	}
	
	private LinkedHashMap<Double,Double> getWrinklePtsEx(ImgExtractLine curLine, int[][] peakVals, int wrinkleStartChkPos, int wrinkleStopChkPos, int wrinkleLineMaxOffset, int maxChkOffset, boolean chkDownSide){
		LinkedHashMap<Double,Double> wrinklePts = new LinkedHashMap<Double,Double>();
		double tmpSlope = curLine.getLineSlope();
		double tmpOffset = curLine.getLineIntercept()+curLine.getLineInterceptDelta();
		int y = 0, nearCol = 0, imgHeight = peakVals[0].length;
		int minX = wrinkleStartChkPos, startY = (int)(wrinkleStartChkPos*tmpSlope+tmpOffset);
		
		boolean bFound = false;
		String[] pt = null;
		int xDelta = 0, yDelta = 0;
		ArrayList<ArrayList<String>> wrinkleLines = new ArrayList<ArrayList<String>>();
		ArrayList<String> pts = new ArrayList<String>();
		for(int x=wrinkleStartChkPos; x>wrinkleStopChkPos; x--){
			nearCol = (int)(x*tmpSlope+tmpOffset);
			for(int n=0; n<=(int)maxChkOffset; n++){
				if(chkDownSide){
					y = nearCol + n;
				}else{
					y = nearCol - n;
				}
				if(y>=0 && y<imgHeight && peakVals[x][y]>0 && peakVals[x][y]<noiseGrayThr){
					if(minX>x) minX = x;
					if(wrinkleLines.isEmpty()){
						pts.add(x+","+y);
						wrinkleLines.add(pts);
					}else{
						bFound = false;
						for(int i=0; i<wrinkleLines.size(); i++){
							pts = wrinkleLines.get(i);
							pt = pts.get(pts.size()-1).split(",");
							xDelta = Integer.parseInt(pt[0]) - x;
							yDelta = y - Integer.parseInt(pt[1]);
							if(Math.abs(yDelta)<lineScanRange/2 && xDelta<lineScanRange){
								bFound = true;
								pts.add(x+","+y);
								wrinkleLines.remove(i);
								wrinkleLines.add(i, pts);
							}
						}
						if(!bFound){
							pts = new ArrayList<String>();
							pts.add(x+","+y);
							wrinkleLines.add(pts);
						}
					}
				}
			}
		}
		
		double onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		double minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		
		double[] coef = null;
		double tmpAngle = 0.0, crossX = 0.0, maxAngle = -1, delta = 0.0;
		int maxAngleIdx = -1, maxSizeIdx = -1, maxSize = -1;
		ArrayList<LinkedHashMap<Double,Double>> tmpLines = new ArrayList<LinkedHashMap<Double,Double>>();
		if(wrinkleLines.size()>0){
			for(int i=0; i<wrinkleLines.size(); i++){
				pts = wrinkleLines.get(i);
				if(pts.size()>=5){
					LinkedHashMap<Double,Double> tmpLine = new LinkedHashMap<Double,Double>();
					for(int j=0; j<pts.size(); j++){
						pt = pts.get(j).split(",");
						tmpLine.put(Double.parseDouble(pt[0]), Double.parseDouble(pt[1]));
					}
					tmpLines.add(tmpLine);
					if(maxSize<0){
						maxSize = tmpLine.size();
						maxSizeIdx = 0;
					}else if(maxSize<tmpLine.size()){
						maxSize = tmpLine.size();
						maxSizeIdx = tmpLines.size()-1;
					}
					
					yDelta = 0; xDelta = 0;
					pt = pts.get(0).split(",");
					xDelta = wrinkleStartChkPos - Integer.parseInt(pt[0]);
					if(chkDownSide){
						yDelta = Integer.parseInt(pt[1]) - startY;
					}else{
						yDelta = startY - Integer.parseInt(pt[1]);
					}
					
					tmpAngle = -1;
					coef = MathUtils.lineFitting(tmpLine);
					if(-1!=tmpSlope*coef[0]){
						tmpAngle = (tmpSlope-coef[0])/(1+tmpSlope*coef[0]);
						tmpAngle = Math.toDegrees(Math.atan(tmpAngle));
					}
					if(tmpAngle>0){
						crossX = (coef[1]-tmpOffset)/(tmpSlope-coef[0]);
						delta = crossX - wrinkleStartChkPos;
						if(maxAngle<tmpAngle && Math.abs(delta)<lineScanRange*6 
							&& yDelta<lineScanRange*3
							&& !(xDelta>lineScanRange*4 
								&& yDelta>lineScanRange/2
								&& delta<minDistance)
							&& !(tmpLine.size()<lineScanRange*1.5
								&& yDelta>lineScanRange*1.5)){
							//Conditions
							//1.Cross point is close to the curve starting point
							//2.First point of the wrinkle line is close to the checked layer
							maxAngle=tmpAngle;
							maxAngleIdx = tmpLines.size() - 1;
						}
					}
				}
			}
			if(maxAngleIdx>=0){
				wrinklePts = tmpLines.get(maxAngleIdx);
			}else if(maxSizeIdx>=0){
				wrinklePts = tmpLines.get(maxSizeIdx);
				coef = MathUtils.lineFitting(wrinklePts);
				crossX = (coef[1]-tmpOffset)/(tmpSlope-coef[0]);
				delta = crossX - wrinkleStartChkPos;
				if(delta<lineScanRange*(-2) || delta>lineScanRange*2){
					yDelta = 0; xDelta = 0;
					for(Double x:wrinklePts.keySet()){
						xDelta = (int)(wrinkleStartChkPos - x);
						if(chkDownSide){
							yDelta = (int)(wrinklePts.get(x) - startY);
						}else{
							yDelta = (int)(startY - wrinklePts.get(x));
						}
						break;
					}
					
					tmpAngle = -1;
					if(-1!=tmpSlope*coef[0]){
						tmpAngle = (tmpSlope-coef[0])/(1+tmpSlope*coef[0]);
						tmpAngle = Math.toDegrees(Math.atan(tmpAngle));
					}
					
					double x0=0.0,y0=0.0;
					for(Double x:wrinklePts.keySet()){
						x0 = x; y0 = wrinklePts.get(x);
					}
					wrinklePts.clear();
					
					if(tmpAngle>0 && tmpAngle<5 && delta>lineScanRange*2
						&& yDelta<=lineScanRange/2 && xDelta<=lineScanRange/2){
						double x1,y1,newSlope,newOffset,xStep;
						x1=wrinkleStartChkPos;y1=tmpSlope*x1+tmpOffset;
						newSlope=(y1-y0)/(x1-x0);
						newOffset = y1-newSlope*x1;
						xStep = (x1-x0)/10;
						
						for(double x=x0; x<=x1; x=x+xStep){
							wrinklePts.put(x, newSlope*x+newOffset);
						}
					}
				}
			}
		}
		if(wrinklePts.size()>0){
			coef = MathUtils.lineFitting(wrinklePts);
			wrinklePts.put((double)minX, coef[0]*minX+coef[1]);
		}
		
		return wrinklePts;
	}
	
	private String getResultKey(int layerIdx){
		String procRsltKey = "";
		
		if(0==layerIdx%2){
			procRsltKey = "L" + (layerIdx/2) + "_L";
		}else{
			procRsltKey = "L" + ((layerIdx+1)/2) + "_R";
		}
		
		return procRsltKey;
	}
	
	private boolean twoNearLinesOverhangFailed(int curLineIdx, ImgExtractLine curLine, ImgExtractLine nextLine, double curLineWeight, double nextLineWeight){
		boolean failed = true;
		double minDistance = 10;//pixels
		double maxDistance = 116;//pixels
		double onePixelLen = 0.012;
		double overhang = 0.0;
		int refCurrLine = 0, refNextLine = 0;
		
		onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		
		if(null!=curLine && null!=nextLine){
			if(evenPoleIsLonger && 0==curLineIdx%2 || !evenPoleIsLonger && 1==curLineIdx%2){
				refCurrLine = (int)(curLine.getXAxisStop() + (curLine.getXAxisStart()-curLine.getXAxisStop())*(1-curLineWeight));
				refNextLine = (int)(nextLine.getXAxisStart() - (nextLine.getXAxisStart()-nextLine.getXAxisStop())*nextLineWeight);
			}else{
				refCurrLine = (int)(curLine.getXAxisStart() - (curLine.getXAxisStart()-curLine.getXAxisStop())*curLineWeight);
				refNextLine = (int)(nextLine.getXAxisStop() + (nextLine.getXAxisStart()-nextLine.getXAxisStop())*(1-nextLineWeight));
			}
			
			if(firstPoleIsLonger){
				overhang = evenPoleIsLonger?refNextLine - refCurrLine:refCurrLine - refNextLine;
			}else{
				overhang = !evenPoleIsLonger?refCurrLine - refNextLine:refNextLine - refCurrLine;
			}
			if(overhang>=minDistance && overhang<=maxDistance) failed = false;
		}
		
		return failed;
	}
	
	private boolean calculateFinalResult(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger, int[][] imgGrays, int defaultVal, int targetLinesQty, int[][] peakVals, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean bPassed = false, curLinePassed = false;
		double minDistance = 10;//pixels
		double maxDistance = 116;//pixels
		double maxPoleAngle = 25;//degrees
		double maxMissedCheckRate = 0.0, minPassedRate = 1.0, onePixelLen = 0.012;
		int meetCndQty = 0, missedCheckQty = 0;
		double missedCheckRate = 0.0, passedRate = 0.0;
		int imgHeight = imgGrays[0].length;
		String procRsltKey = "";
		
		onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		maxPoleAngle = Double.parseDouble(""+criteria.get("maxPoleAngle"));
		
		int[] distances = new int[targetLinesQty];
		int lineCounter = 0;
		for(int i=0; i<targetLinesQty; i++){
			curLinePassed = false;
			ImgExtractLine exLine = linesMap.get(i);
			if(null!=exLine){
				String grays = "";
				int start = 0, imgWidth = finalData.length, nearCol = 0;
				int lineFlag = lineIndexBase+i;
				double lineSlope = exLine.getLineSlope();
				double lineOffset = exLine.getLineIntercept()+exLine.getLineInterceptDelta();
				if(i>=10){
					start = exLine.getMostSharpChgPos(evenLineLonger,linesMap,i,imgGrays,peakVals,targetLinesQty);
				}else{
					if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
						start = exLine.getXAxisStop();
					}else{
						start = exLine.getXAxisStart();
					}
				}
				exLine.setPolePosition(start);
				if(i>0){
					procRsltKey = getResultKey(i);
					if(null!=linesMap.get(i-1)){
						if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
							distances[i] = linesMap.get(i-1).getPolePosition() - start;
						}else{
							distances[i] = start - linesMap.get(i-1).getPolePosition();
						}
						if(distances[i]>=minDistance && distances[i]<=maxDistance){
							meetCndQty++;
							curLinePassed = true;
						}else if(distances[i]<minDistance && i<10){
							//TODO Double check special case
							int[][] tmpGrays = new int[imgWidth][imgHeight];
							for(int k=0; k<imgWidth; k++){
								tmpGrays[k] = imgGrays[k].clone();
							}
							double tmpSlope = exLine.getLineSlope();
							double tmpOffset = exLine.getLineIntercept();
							double oriSlope = tmpSlope, oriOffset = tmpOffset;
							double maxDnChkOffset = 0.0, maxUpChkOffset = 0.0;
							boolean checkDnSide = false, checkUpSide = false;
							int newXAxisStop = -1, abnXAxisStop = -1, wrinkleLineMaxOffset = 0;
							int upStartChkPos = 0, dnStartChkPos = 0, dnCrossX = -1, upCrossX = -1;
							ImgExtractLine tmpLine = null;
							
							wrinkleLineMaxOffset = (int)(evenPoleAvgOffset+oddPoleAvgOffset)/2;
							maxDnChkOffset = (evenPoleAvgOffset+oddPoleAvgOffset)/2;
							maxUpChkOffset = maxDnChkOffset;
							if(curLineIsLonger(i, evenLineLonger)){
								//Current line is the longer one
								tmpLine = exLine;
								if(null!=linesMap.get(i-1) && null==linesMap.get(i-2)){
									maxUpChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i-1).getLineIntercept()-linesMap.get(i-1).getLineInterceptDelta();
									maxUpChkOffset = Math.abs(maxUpChkOffset)*1.5;
//									checkUpSide = true;
									upStartChkPos = linesMap.get(i-1).getXAxisStart();
								}
								if(null!=linesMap.get(i+1)){
									if(null!=linesMap.get(i+2)){
										maxDnChkOffset = linesMap.get(i+2).getLineIntercept()+linesMap.get(i+2).getLineInterceptDelta();
										maxDnChkOffset = maxDnChkOffset - tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
									}else{
										maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i+1).getLineIntercept()-linesMap.get(i+1).getLineInterceptDelta();
										maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
									}
									checkDnSide = true;
									dnStartChkPos = linesMap.get(i+1).getXAxisStart();
								}
							}else{
								//Last line is the longer one
								tmpLine = linesMap.get(i-1);
								tmpSlope = tmpLine.getLineSlope();
								tmpOffset = tmpLine.getLineIntercept();
								oriSlope = tmpSlope; oriOffset = tmpOffset;
								if(null!=linesMap.get(i-2) && null==linesMap.get(i-3)){
									maxUpChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i-2).getLineIntercept()-linesMap.get(i-2).getLineInterceptDelta();
									maxUpChkOffset = Math.abs(maxUpChkOffset)*1.5;
//									checkUpSide = true;
									upStartChkPos = linesMap.get(i-2).getXAxisStart();
								}
								if(null!=linesMap.get(i+1)){
									maxDnChkOffset = linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta();
									maxDnChkOffset = maxDnChkOffset-tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
								}else{
									maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-exLine.getLineIntercept()-exLine.getLineInterceptDelta();
									maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
								}
								checkDnSide = true;
								dnStartChkPos = exLine.getXAxisStart();
								if(1==tmpLine.getWrinkleFlag() || 3==tmpLine.getWrinkleFlag()){
									checkDnSide = false;
								}
							}
							
							int refPos = tmpLine.getPolePosition();
							int upSideGray = 0, dnSideGray = 0, scanLines = 3, minIdx = -1;
							int startChkPos = refPos - distances[i];
							if(startChkPos<0) startChkPos = 0;
							int stopChkPos = startChkPos - (int)maxDistance;
							if(stopChkPos<0) stopChkPos = 0;
							
							LinkedHashMap<Double,Double> dnSideWrinkleLine = new LinkedHashMap<Double,Double>();
							LinkedHashMap<Double,Double> upSideWrinkleLine = new LinkedHashMap<Double,Double>();
							//Check up side
							if(checkUpSide){
//								upSideWrinkleLine = getWrinklePts(tmpLine,peakVals,upStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxUpChkOffset,false);
//								upSideWrinkleLine = getWrinkleLineEx(tmpLine,upSideWrinkleLine,upStartChkPos,-maxUpChkOffset,maxPoleAngle,peakVals);
								upSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,upStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxUpChkOffset,false);
							}
							
							//Check down side
							if(checkDnSide){
//								dnSideWrinkleLine = getWrinklePts(tmpLine,peakVals,dnStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
//								dnSideWrinkleLine = getWrinkleLineEx(tmpLine,dnSideWrinkleLine,startChkPos,maxDnChkOffset,maxPoleAngle,peakVals);
								dnSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,dnStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
							}
							
							double[] dnLineParas = null, upLineParas = null;
							double dnSideAngle = 0.0, upSideAngle = 0.0;
							if(dnSideWrinkleLine.size()>=5){
								dnLineParas = MathUtils.lineFitting(dnSideWrinkleLine);
								dnSideAngle = 90.0;
								if(-1!=tmpSlope*dnLineParas[0]){
									dnSideAngle = Math.abs((tmpSlope-dnLineParas[0])/(1+tmpSlope*dnLineParas[0]));
									dnSideAngle = Math.toDegrees(Math.atan(dnSideAngle));
									dnCrossX = (int)((tmpOffset-dnLineParas[1])/(dnLineParas[0]-tmpSlope));
									System.out.println("Dn Side Angle:"+dnSideAngle);
								}
								tmpLine.setWrinkleFlag(1);
							}
							if(upSideWrinkleLine.size()>=5){
								upLineParas = MathUtils.lineFitting(upSideWrinkleLine);
								upSideAngle = 90.0;
								if(-1!=tmpSlope*upLineParas[0]){
									upSideAngle = Math.abs((tmpSlope-upLineParas[0])/(1+tmpSlope*upLineParas[0]));
									upSideAngle = Math.toDegrees(Math.atan(upSideAngle));
									upCrossX = (int)((tmpOffset-upLineParas[1])/(upLineParas[0]-tmpSlope));
									System.out.println("Up Side Angle:"+upSideAngle);
								}
								if(dnSideWrinkleLine.size()>=5){
									tmpLine.setWrinkleFlag(3);
								}else{
									tmpLine.setWrinkleFlag(2);
								}
							}
							if(!curLineIsLonger(i, evenLineLonger) && !checkDnSide){
								if(null!=imgProcResultAngle.get(procRsltKey) && imgProcResultAngle.get(procRsltKey)>maxPoleAngle){
									newXAxisStop = tmpLine.getXAxisStop();
								}
							}
							
							if(dnSideAngle>0 || upSideAngle>0){
								storeLayerAngle(evenLineLonger, i, dnSideAngle, upSideAngle);
								if(dnSideAngle>maxPoleAngle || upSideAngle>maxPoleAngle){
									if(0==i%2 && evenLineLonger || 1==i%2 &&!evenLineLonger){
										if(checkUpSide && upSideAngle>maxPoleAngle){
											abnXAxisStop = imgWidth;
											for(double k:upSideWrinkleLine.keySet()){
												if(k<abnXAxisStop) abnXAxisStop=(int)k;
											}
										}
									}else{
										if(checkDnSide && dnSideAngle>maxPoleAngle){
											abnXAxisStop = imgWidth;
											for(double k:dnSideWrinkleLine.keySet()){
												if(k<abnXAxisStop) abnXAxisStop=(int)k;
											}
										}
									}
									newXAxisStop = dnCrossX>upCrossX?dnCrossX:upCrossX;
									
									if(abnXAxisStop<0){
										dnSideAngle = 0; upSideAngle = 0;
									}
								}else{
									if(dnSideAngle>0 && dnSideAngle<=maxPoleAngle){
										upSideGray = dnSideGray + 1;
										minIdx = imgWidth;
										for(double k:dnSideWrinkleLine.keySet()){
											if(k<minIdx) minIdx=(int)k;
										}
										newXAxisStop = minIdx;
										for(int k=refPos; k>=minIdx; k--){
											nearCol = (int)(k*tmpSlope+tmpOffset);
											for(int n=(int)maxDnChkOffset;n>0;n--){
												if(nearCol+n>=0 && nearCol+n<imgHeight){
													if(imgGrays[k][nearCol+n]<defaultVal){
														if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
															tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
														}
													}
												}
											}
										}
									}else if(upSideAngle>0 && upSideAngle<=maxPoleAngle){
										dnSideGray = upSideGray + 1;
										minIdx = imgWidth;
										for(double k:upSideWrinkleLine.keySet()){
											if(k<minIdx) minIdx=(int)k;
										}
										if(newXAxisStop<0) newXAxisStop = minIdx;
										if(newXAxisStop>minIdx) newXAxisStop = minIdx;
										for(int k=(refPos+5); k>=minIdx; k--){
											nearCol = (int)(k*tmpSlope+tmpOffset);
											for(int n=(int)maxUpChkOffset;n>0;n--){
												if(nearCol-n>=0 && nearCol-n<imgHeight){
													if(imgGrays[k][nearCol-n]<defaultVal){
														if(tmpGrays[k][nearCol]>imgGrays[k][nearCol-n]){
															tmpGrays[k][nearCol]=imgGrays[k][nearCol-n];
														}
													}
												}
											}
										}
									}
								}
							}
							
							if(!(dnSideAngle>0 || upSideAngle>0) && -1==newXAxisStop){
								for(int k=refPos; k>0; k--){
									nearCol = (int)(k*tmpSlope+tmpOffset);
									if(nearCol>=1 && nearCol<imgHeight){
										upSideGray += imgGrays[k][nearCol-1];
										dnSideGray += imgGrays[k][nearCol+1];
									}
								}
								if(upSideGray>dnSideGray){//Check down side
									for(int k=refPos; k>0; k--){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=0 && nearCol<(imgHeight-scanLines)){
											for(int n=0; n<=scanLines; n++){
												if(imgGrays[k][nearCol+n]<defaultVal){
													if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
														tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
													}
												}
											}
										}
									}
								}else if(upSideGray<dnSideGray){//Check up side
									for(int k=refPos; k>0; k--){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=scanLines && nearCol<imgHeight){
											for(int n=0; n<=scanLines; n++){
												if(imgGrays[k][nearCol-n]<defaultVal){
													if(tmpGrays[k][nearCol]>imgGrays[k][nearCol-n]){
														tmpGrays[k][nearCol] = imgGrays[k][nearCol-n];
													}
												}
											}
										}
									}
								}
							}
							
							int oriRefPos = tmpLine.getPolePosition();
							int startPos = 0, stopPos = 0, oriCol = 0;
							boolean bDnSideWrinkle = false;
							if(upSideGray>dnSideGray || dnSideGray>upSideGray || -1!=newXAxisStop){
								System.out.println("Ori start/stop:"+tmpLine.getXAxisStart()+"/"+tmpLine.getXAxisStop());
								if(newXAxisStop<0){
									tmpLine = setLineBoundary(tmpLine, tmpGrays, defaultVal);
								}else{
									tmpLine.setXAxisStop(newXAxisStop);
									if(tmpLine.getXAxisStart()<newXAxisStop) tmpLine.setXAxisStart(newXAxisStop);
								}
								System.out.println("Cur start/stop:"+tmpLine.getXAxisStart()+"/"+tmpLine.getXAxisStop());
								tmpLine.setPolePosition(tmpLine.getXAxisStop());//tmpLine is the longer pole
								
								if(curLineIsLonger(i, evenLineLonger)){
									linesMap.put(i, tmpLine);//Current line is the longer one
								}else{
									linesMap.put(i-1, tmpLine);//Last line is the longer one
								}
								
								if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
									distances[i] = linesMap.get(i-1).getPolePosition() - linesMap.get(i).getPolePosition();
								}else{
									distances[i] = linesMap.get(i).getPolePosition() - linesMap.get(i-1).getPolePosition();
								}
								//distances[i] = Math.abs(linesMap.get(i).getPolePosition() - linesMap.get(i-1).getPolePosition());
								if(distances[i]>=minDistance && distances[i]<=maxDistance){
									meetCndQty++;
									curLinePassed = true;
								}
								
								if(!curLinePassed) lineFlag = 4;
								refPos = tmpLine.getXAxisStop();
								if(refPos > oriRefPos){
									startPos = oriRefPos;
									stopPos = refPos;
								}else{
									startPos = refPos;
									stopPos = oriRefPos;
								}
								
								bDnSideWrinkle = false;
								if(dnSideAngle>0 || upSideAngle>0){
									if(dnSideAngle>upSideAngle){
										tmpSlope = dnLineParas[0];
										tmpOffset = dnLineParas[1];
										bDnSideWrinkle = true;
									}else{
										tmpSlope = upLineParas[0];
										tmpOffset = upLineParas[1];
									}
									for(int k=startPos; k<=stopPos; k++){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										oriCol = (int)(k*oriSlope+oriOffset);
										if(bDnSideWrinkle && nearCol<oriCol) nearCol = oriCol;
										if(!bDnSideWrinkle && nearCol>oriCol) nearCol = oriCol;
										if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
									}
								}else{
									for(int k=startPos; k<=stopPos; k++){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
									}
								}
							}
							
							if(null!=dnLineParas || null!=upLineParas){
								bDnSideWrinkle = false;
								if(null!=dnLineParas){
									tmpSlope = dnLineParas[0];
									tmpOffset = dnLineParas[1];
									bDnSideWrinkle = true;
									if(abnXAxisStop<0){
										abnXAxisStop = imgWidth;
										for(double k:dnSideWrinkleLine.keySet()){
											if(k<abnXAxisStop) abnXAxisStop=(int)k;
										}
									}
								}else{
									tmpSlope = upLineParas[0];
									tmpOffset = upLineParas[1];
									if(abnXAxisStop<0){
										abnXAxisStop = imgWidth;
										for(double k:upSideWrinkleLine.keySet()){
											if(k<abnXAxisStop) abnXAxisStop=(int)k;
										}
									}
								}
								for(int k=abnXAxisStop; k<=oriRefPos; k++){
									nearCol = (int)(k*tmpSlope+tmpOffset);
									oriCol = (int)(k*oriSlope+oriOffset);
									if(bDnSideWrinkle && nearCol<oriCol) nearCol = oriCol;
									if(!bDnSideWrinkle && nearCol>oriCol) nearCol = oriCol;
									if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
								}
							}
						}
						if(!curLinePassed) lineFlag = 4;//Draw the failed line
						imgProcResultLength.put(procRsltKey, distances[i]*onePixelLen);
						imgProcResultOK.put(procRsltKey, curLinePassed);
					}else{
						missedCheckQty++;
						imgProcResultLength.put(procRsltKey, 0.0);
						imgProcResultOK.put(procRsltKey, false);
					}
				}
				
				if(exLine.getCrossX()>0) start = exLine.getCrossX();
				for(int k=0; k<start; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					grays += "," + imgGrays[k][nearCol];
				}
				for(int k=start; k<imgWidth; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					finalData[k][nearCol] = lineFlag;
					grays += "," + imgGrays[k][nearCol];
				}
				
				lineCounter++;
				if(logEnabled){
					LogUtils.rawLog("sortLineParas_", exLine.printLineParas(i,1==lineCounter?true:false));
					LogUtils.rawLog("sortLineGrays_", "G"+i+grays);
				}
			}else{
				if(i>0) missedCheckQty++;
			}
		}
		
		//Most outer line special handling
		if(!evenLineLonger && null!=imgProcResultLength.get("L1_R") && null!=imgProcResultLength.get("L1_L")){
			double layer1R = imgProcResultLength.get("L1_R");
			double layer1L = imgProcResultLength.get("L1_L");
			if(layer1R>0 && layer1R<(minDistance*onePixelLen)
				&& layer1L>0 && layer1L>(minDistance*onePixelLen)){
				meetCndQty++;
			}
		}
		
		//Double check the result
		for(String key:imgProcResultOK.keySet()){
			if(!imgProcResultOK.get(key) && key.endsWith("_R")){
				if(null!=imgProcResultAngle.get(key.replace("_R", "_L"))){
					meetCndQty++;
					imgProcResultOK.put(key, true);
					imgProcResultLength.put(key, imgProcResultLength.get(key.replace("_R", "_L")));
				}
			}
		}
		
		missedCheckRate = (double)missedCheckQty / (targetLinesQty - 1);
		passedRate = (double)meetCndQty / (targetLinesQty - 1 - missedCheckQty);
		if(missedCheckRate<=maxMissedCheckRate && passedRate>=minPassedRate){
			bPassed = true;
		}
		
		return bPassed;
	}

	private void storeLayerAngle(boolean evenLineLonger, int layerIdx, double dnSideAngle, double upSideAngle) {
		if(dnSideAngle>0 || upSideAngle>0){
			String angleKey = "";
			if(curLineIsLonger(layerIdx, evenLineLonger)){
				if(0==layerIdx%2){
					angleKey = "L" + (layerIdx/2);
				}else{
					angleKey = "L" + ((layerIdx+1)/2);
				}
			}else{
				if(0==(layerIdx-1)%2){
					angleKey = "L" + ((layerIdx-1)/2);
				}else{
					angleKey = "L" + (layerIdx/2);
				}
			}
			angleKey = angleKey + (dnSideAngle>upSideAngle?"_L":"_R");
			imgProcResultAngle.put(angleKey, (dnSideAngle>upSideAngle?dnSideAngle:upSideAngle));
		}
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> searchMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap,
			ImgExtractLine myBaseline,int[][] peakVals, int[][] initVals, int[][]imgGrays, 
			int defaultVal, double[] slope, double[] offset, int bestRsqIdx,
			double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty, boolean chkMinOffset){
		
		double diff1,diff2,offsetChgR,addLineSlope,addLineOffset,off1,off2,curOffset;
		double researchSlope = myBaseline.getLineSlope(), researchOffset = myBaseline.getLineIntercept();
		double researchOffsetStop = 0;
		
		for(int i=0; i<targetLinesQty; i++){
			ImgExtractLine exLine = linesMap.get(i);
			if(null==exLine){
				if(null!=linesMap.get(i-1)){
					researchOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta();
				}else{
					researchOffset = slope[bestRsqIdx]*(i-1)+offset[bestRsqIdx];
				}
				
				if(null!=linesMap.get(i+1)){
					researchOffsetStop = linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta();
				}else{
					researchOffsetStop = slope[bestRsqIdx]*(i+1)+offset[bestRsqIdx];
				}
				off1 = researchOffset; off2 = researchOffsetStop;
				addLineSlope = researchSlope; addLineOffset = (researchOffset+researchOffsetStop)/2;
				if(0==i%2){
					researchOffset += evenPoleAvgOffset*0.9;
					researchOffsetStop -= (oddPoleAvgOffset*0.9>lineScanRange?lineScanRange:oddPoleAvgOffset*0.9);
					if(i==(targetLinesQty-1)) researchOffsetStop = researchOffset + oddPoleAvgOffset*1.5;
				}else{
					researchOffset += oddPoleAvgOffset*0.9;
					researchOffsetStop -= (evenPoleAvgOffset*0.9>lineScanRange?lineScanRange:evenPoleAvgOffset*0.9);
					if(i==(targetLinesQty-1)) researchOffsetStop = researchOffset + evenPoleAvgOffset*1.5;
				}
				if(researchOffsetStop-researchOffset<lineScanRange){
					researchOffset = (researchOffsetStop+researchOffset)/2-lineScanRange/2-1;
					researchOffsetStop = researchOffset+lineScanRange+1;
				}
				
				exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
				if(null!=exLine){
					if(null!=linesMap.get(i-2) && null!=linesMap.get(i-3)){
						diff1 = exLine.getLineIntercept()+exLine.getLineInterceptDelta()-researchOffset;
						diff2 = linesMap.get(i-2).getLineIntercept()-linesMap.get(i-3).getLineIntercept();
						diff2 += linesMap.get(i-2).getLineInterceptDelta()-linesMap.get(i-3).getLineInterceptDelta();
						offsetChgR = diff1/diff2;
						if(offsetChgR>maxOffsetChgRate){
							researchOffsetStop = exLine.getLineIntercept()+exLine.getLineInterceptDelta() - lineScanRange/2;
							exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
						}
						else if(chkMinOffset && offsetChgR<minOffsetChgRate){
							curOffset = exLine.getLineIntercept()+exLine.getLineInterceptDelta();
							if(off2-curOffset<curOffset-off1){
								exLine = addFixedLine(peakVals,imgGrays,defaultVal,addLineSlope,addLineOffset);
							}
						}
					}
					if(null!=exLine){
						exLine.setLineFlag(3);
						linesMap.put(i, exLine);
					}
				}
				System.out.println((null==exLine?"Missing:":"Insert:")+i);
			}else{
				researchSlope = linesMap.get(i).getLineSlope();
			}
		}
		
		return linesMap;
	}
	
	private boolean thereIsMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap, int targetLinesQty){
		boolean missing = false;
		
		for(int i=0; i<targetLinesQty; i++){
			if(null == linesMap.get(i)){
				missing = true;
				break;
			}
		}
		return missing;
	}
	
	private boolean lineIsNegPole(int lineIdx, boolean evenLineLonger, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean isNegPole = false;
		
		if(0==lineIdx%2 && !evenLineLonger || 1==lineIdx%2 && evenLineLonger){
			if(evenPoleAvgOffset>oddPoleAvgOffset) isNegPole = true;
		}
		
		return isNegPole;
	}
	
	private ImgExtractLine getMostClosedLine(double offset, double tolerance){
		ImgExtractLine line = null;
		int idx = -1;
		for(int i=0; i<allPossibleLines.size(); i++){
			if(allPossibleLines.get(i).getLineIntercept()>=offset){
				idx = i;
				break;
			}
		}
		if(idx>=0){
			if(allPossibleLines.get(idx).getLineIntercept()-offset<=tolerance){
				line = allPossibleLines.get(idx);
			}else if(idx>0 && allPossibleLines.get(idx-1).getLineIntercept()-offset<=tolerance){
				line = allPossibleLines.get(idx-1);
			}
		}
		
		return line;
	}
	
	private int getLineMeanGray(ImgExtractLine currLine, int[][] imgGrays, int startIdx, int stopIdx){
		if(null==currLine) return -1;
		
		double slope = currLine.getLineSlope(), sumGray = 0.0;
		double offset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
		int nearCol = 0, imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		int meanGray = -1, counter = 0;
		if(startIdx>stopIdx){
			nearCol = startIdx;
			startIdx = stopIdx;
			stopIdx = nearCol;
		}
		if(startIdx<0) startIdx = 0;
		if(stopIdx+1>imgWidth) stopIdx=imgWidth-1;
		
		for(int i=startIdx; i<=stopIdx; i++){
			nearCol = (int)(slope * i + offset);
			if(nearCol>=0 && nearCol<imgHeight){
				sumGray += imgGrays[i][nearCol];
				counter++;
			}
		}
		if(counter>0) meanGray = (int)(sumGray/counter);
		
		return meanGray;
	}
	
	private boolean thereIsPoleBtw(int[][] imgGrays, ImgExtractLine currLine, ImgExtractLine lastLine, boolean supposed){
		boolean poleExisting = supposed;
		
		if(null!=currLine && null!=lastLine){
			poleExisting = false;
			ImgExtractLine tmpLine = null;
			double offset1 = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
			double offset2 = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
			poleExisting = offsetInPeakRegion(allPossibleLines,(offset1+offset2)/2);
			
			//If out of expectation
			int gray0 = 0, gray1 = 0, gray2 = 0;
			if(!poleExisting && supposed){
				tmpLine = getMostClosedLine((offset1+offset2)/2,lineScanRange/2);
				if(null!=tmpLine){
					gray0 = getLineMeanGray(tmpLine,imgGrays,imgGrays.length/2,imgGrays.length);
					gray1 = getLineMeanGray(currLine,imgGrays,imgGrays.length/2,imgGrays.length);
					gray2 = getLineMeanGray(lastLine,imgGrays,imgGrays.length/2,imgGrays.length);
					if((double)(gray0-gray1+gray0-gray2)/2+0.5<3){
						poleExisting = supposed;
					}else{
						poleExisting = !supposed;
					}
				}
			}
		}
		
		return poleExisting;
	}
	
	private boolean lineIsThicker(double[] weightOfLine, int[][] imgGrays, ImgExtractLine currLine, ImgExtractLine lastLine, double offsetChgR){
		boolean thicker = false;
		//Total lines appear in Up or Dn side checking region is more than 3
		if(weightOfLine[6]>=0.6 && weightOfLine[8]>=5 
			|| weightOfLine[5]>=0.6 && weightOfLine[7]>=5
			|| weightOfLine[5]*weightOfLine[7]+weightOfLine[6]*weightOfLine[8]>=5){
			if(null==currLine){
				thicker = true;
			}else{
				double slope = currLine.getLineSlope();
				double offsetCurrLine = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				double offsetLastLine = offsetCurrLine-10;
				if(null!=lastLine) offsetLastLine = lastLine.getLineIntercept() + lastLine.getLineInterceptDelta()-3;
				int scanRange = (int)(offsetCurrLine - offsetLastLine);
				if(scanRange<0) scanRange = 10;
				int stDelta = -5;
				int[] grays = new int[scanRange+1-stDelta];
				int innerAvgGray = 0, outerAvgGray = 0, innerCnt = 0, outerCnt = 0;
				double innerGray = 0.0, outerGray = 0.0;
				
				for(int i=stDelta; i<=scanRange; i++){
					grays[i-stDelta] = currLine.getLineAvgGray(imgGrays, currLine.getXAxisStop(), slope, offsetCurrLine-i);
					if(i<scanRange/2){
						innerGray += grays[i-stDelta];
						innerCnt++;
					}else{
						outerGray += grays[i-stDelta];
						outerCnt++;
					}
				}
				outerAvgGray = (int)(outerGray/outerCnt);
				innerAvgGray = (int)(innerGray/innerCnt);
				
				if(outerAvgGray-innerAvgGray>3 
					|| outerAvgGray-innerAvgGray>=3 && weightOfLine[5]*weightOfLine[7]+weightOfLine[6]*weightOfLine[8]>=5
				){
					thicker = true;
				}
			}
		}
		
		return thicker;
	}
	
	private boolean evenLineIsLonger(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays){
		boolean evenLineLonger = false;
		int[] refGrayIndex = new int[targetLinesQty];
		double[] refGrays = new double[targetLinesQty];
		int longPoleFirstQty = 0, imgHeight = imgGrays[0].length;
		double weightOfEvenLineLonger = 0.0;
		
		for(int i=0; i<targetLinesQty; i++){
			ImgExtractLine exLine = linesMap.get(i);
			if(null!=exLine){
				if(0==i%2){
					refGrayIndex[i] = exLine.getXAxisStart();
				}else{
					refGrayIndex[i] = refGrayIndex[i-1];
				}
				
				double refGray = 0.0;
				double lineSlope = exLine.getLineSlope();
				double lineOffset = exLine.getLineIntercept();
				int nearCol = 0;
				for(int k=0; k<=refGrayIndex[i]; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					refGray += imgGrays[k][nearCol];
				}
				exLine.setRefGray(refGray);
				refGrays[i] = refGray;
				
				if(0!=i%2){
					if(refGrays[i]>refGrays[i-1]) longPoleFirstQty++;
				}
			}
		}
		weightOfEvenLineLonger = (double)longPoleFirstQty*2 / targetLinesQty;
		if(weightOfEvenLineLonger>0.5) evenLineLonger = true;
		
		return evenLineLonger;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> addMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap,
			ImgExtractLine myBaseline,int[][] peakVals, int[][] initVals, int[][]imgGrays, 
			int defaultVal, double[] slope, double[] offset, int bestRsqIdx,
			double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty){
		
		double addLineSlope = 0.0, addLineOffset = 0.0;
		double researchOffset = 0.0, researchOffsetStop = 0.0, researchSlope = 0.0;
		
		for(int i=1; i<targetLinesQty; i++){
			if(null==linesMap.get(i) && null!=linesMap.get(i-1)){
				ImgExtractLine exLine = null;
				addLineSlope = 0.0; addLineOffset = 0.0;
				if(null!=linesMap.get(i+1)){
					addLineSlope = (linesMap.get(i-1).getLineSlope()+linesMap.get(i+1).getLineSlope())/2;
					addLineOffset = (linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()
							+linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta())/2;
				}else if(i==(targetLinesQty-1)){
					researchSlope = linesMap.get(i-1).getLineSlope();
					researchOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()+(evenPoleAvgOffset+oddPoleAvgOffset)/2;
					researchOffsetStop = researchOffset + (evenPoleAvgOffset+oddPoleAvgOffset)/2*3;
					exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
					if(null!=exLine){
						exLine.setLineFlag(3);
					}else{
						addLineSlope = linesMap.get(i-1).getLineSlope();
						addLineOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()
								+(evenPoleAvgOffset+oddPoleAvgOffset)/2;
					}
				}
				if(addLineOffset>0) exLine = addFixedLine(peakVals,imgGrays,defaultVal,addLineSlope,addLineOffset);
				if(null!=exLine) linesMap.put(i, exLine);
			}
		}
		
		return linesMap;
	}
	
	private ImgExtractLine addFixedLine(int[][] peakVals, int[][]imgGrays, 
			int defaultVal, double addLineSlope, double addLineOffset){
		
		ImgExtractLine exLine = null;
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int nearCol = 0, scanRng = lineScanRange/2, colOffset = 0, maxCnt = 0;
		int[] dataCounters = new int[scanRng*2+1];
		exLine = new ImgExtractLine();
		
		for(int j=(imgWidth-1); j>=0; j--){
			nearCol = (int)(j*addLineSlope+addLineOffset);
			for(int k=-scanRng; k<=scanRng; k++){
				if(nearCol+k>=0 && nearCol+k<imgHeight){
					if(peakVals[j][nearCol+k]<lineFitGrayThr){
						dataCounters[k+scanRng] = dataCounters[k+scanRng]+1;
					}
				}
			}
		}
		
		for(int k=0; k<dataCounters.length; k++){
			if(maxCnt<dataCounters[k]){
				maxCnt = dataCounters[k];
				colOffset = k;
			}
		}
		
		colOffset = colOffset - scanRng;
		for(int j=(imgWidth-1); j>=0; j--){
			nearCol = (int)(j*addLineSlope+addLineOffset);
			if(nearCol+colOffset>=0 && nearCol+colOffset<imgHeight){
				if(peakVals[j][nearCol+colOffset]<lineFitGrayThr){
					exLine.addPoint(j, nearCol, imgGrays[j][nearCol]);
				}
			}
		}
		
		exLine.getLineCoef(false);
		exLine.setLineFlag(3);
		exLine = setLineBoundary(exLine, imgGrays, defaultVal);
		
		return exLine;
	}
	
	private void initLineFitGrayThreshold(){
		lineFitGrayThr = 255 * 0.8;
	}
	
	private void adjustLineFitGrayThreshold(int[][] imgGrays, ImgExtractLine myBaseline, int scanOffset){
		double slope = myBaseline.getLineSlope();
		double offset = myBaseline.getLineIntercept();
		int nearRow = 0, imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		double grayAvg = 0.0;
		int counter = 0;
		
		for(int col=0; col<imgWidth; col++){
			nearRow = (int)(slope*col+offset);
			if(nearRow<0 || nearRow+scanOffset>imgHeight) continue;
			for(int row=0; row<scanOffset; row++){
				if(imgGrays[col][nearRow+row]<noiseGrayThr){
					counter++;
					grayAvg += imgGrays[col][nearRow+row];
				}
			}
		}
		
		if(counter>0){
			grayAvg = grayAvg / counter * 1.05;
			System.out.println("Line fit threshold:"+lineFitGrayThr+"/"+grayAvg);
			if(grayAvg>lineFitGrayThr) lineFitGrayThr = grayAvg;
		}
	}
	
	private ArrayList<ImgExtractLine> searchLines(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, ImgExtractLine myBaseline){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int validCnt = 0, nearCol = 0, noisePoints = 0, realPoints = 0;
		int invalidCnt = 0, minValidCol = imgWidth*2, maxValidCol = -1;
		int startChkX = (int)(imgWidth*0.4), lastValidX = 0;
		int maxBlankX = (int)(imgWidth*0.05);
		double noiseRate = 0.0, slopeDelta = 0.0, validRate = 0.0;
		double lastLineOffset = 0.0, lastLineSlope = 0.0;
		double offsetDelta1 = 0.0, offsetDelta2 = 0.0, offsetDelta3 = 0.0, offsetDelta = 0.0;
		double invalidRatio = 0.0, maxColDelta = 3.0;
		int startSearchingOffset = 0, currentLineOffset = 0, finalSearchingOffset = 0;
		int lineSearchingRng = lineScanRange / 2;//Two sides searching
		
		int fittingMinPoints = (int)(imgWidth * minValidRatio);
		boolean bLineFound = false;
		
		int[][] sortData = new int[imgWidth][imgHeight];
		int[][] searchingLinesData = new int[imgWidth][imgHeight];
		finalData = new int[imgWidth][imgHeight];
		for(int i=0; i<imgWidth; i++){
			sortData[i] = initVals[i].clone();
			finalData[i] = initVals[i].clone();
			searchingLinesData[i] = peakVals[i].clone();
		}
		double myBaselineSlope = myBaseline.getLineSlope();
		double myBaselineOffset = myBaseline.getLineIntercept();
		startSearchingOffset = (int)(myBaselineSlope*(imgWidth-1)+myBaselineOffset);
		if(startSearchingOffset<0) startSearchingOffset = 0;
		lastLineOffset = -1;
		initLineFitGrayThreshold();
		adjustLineFitGrayThreshold(imgGrays,myBaseline,30);
		
		double[] lineCoef = null;
		ArrayList<ImgExtractLine> extractLines = new ArrayList<ImgExtractLine>();
		ImgExtractLine lastPossibleLine = null;
		ImgExtractLine extractLine = new ImgExtractLine();
		ImgExtractLine.setMinRSQ(0.7f);
		
		if(imgWidth > fittingMinPoints && imgHeight > lineSearchingRng){
			for(int i=startSearchingOffset; i<imgHeight; i++){
				bLineFound = false;
				minValidCol = imgWidth*2; maxValidCol = -1;
				extractLine.clearLineData();
				for(int j=(imgWidth-1); j>=0; j--){
					if(j<startChkX){
						lineSearchingRng = 1;
					}else{
						lineSearchingRng = lineScanRange / 2;
					}
					nearCol = (int)(j*myBaselineSlope+myBaselineOffset);
					if((nearCol-lineSearchingRng)>=0 && nearCol<(imgHeight-lineSearchingRng)){
						for(int k=-lineSearchingRng; k<lineSearchingRng; k++){
							if(peakVals[j][nearCol+k]<lineFitGrayThr){
								if(j>=startChkX || j<startChkX && lastValidX-j<maxBlankX){
									extractLine.addPoint(j, nearCol+k, peakVals[j][nearCol+k]);
									if((nearCol+k)<minValidCol) minValidCol = nearCol+k;
									if((nearCol+k)>maxValidCol) maxValidCol = nearCol+k;
									if(Math.abs(k)<=1) extractLine.addRealPoints(j, nearCol+k, 1);
									lastValidX = j;
								}
							}
							if(imgGrays[j][nearCol+k]>=noiseGrayThr) extractLine.addInvalidPoints(1);
						}
					}
				}
				
				validCnt = extractLine.getValidPoints();
				realPoints = extractLine.getRealPoints();
				invalidCnt = extractLine.getInvalidPoints();
				invalidRatio = (double)invalidCnt / (lineSearchingRng*2+1) / imgWidth;
				
				if(extractLines.size()<=0){
					saveSearchingLines(searchingLinesData,myBaselineSlope,myBaselineOffset,i,"debug");
					if(i-startSearchingOffset>(lineScanRange*3)){
						System.out.println("Fail to get 1st layer");
						break;
					}
				}else if(2==extractLines.size()){
//					if(249==i)
//					System.out.println("debug:"+i);
				}
				
				if((validCnt>=fittingMinPoints || realPoints>=fittingMinPoints*0.8) && invalidRatio<maxInvalidRatio){
					lineCoef = extractLine.getLineCoef(false);
					currentLineOffset = (int)(lineCoef[0]*(imgWidth-1)+lineCoef[1]);
					slopeDelta = Math.abs(myBaselineSlope-extractLine.getLineSlope());
					if(-1==lastLineOffset){
						offsetDelta1 = minOffsetDelta*1.1;
						offsetDelta2 = offsetDelta1; offsetDelta3 = offsetDelta1;
					}else{
						offsetDelta1 = lineCoef[1]-lastLineOffset;
						offsetDelta2 = (lineCoef[0]-lastLineSlope)*imgWidth/2+lineCoef[1]-lastLineOffset;
						offsetDelta3 = (lineCoef[0]-lastLineSlope)*(imgWidth-1)+lineCoef[1]-lastLineOffset;
					}
					offsetDelta = (offsetDelta1+offsetDelta2+offsetDelta3)/3;
					
					if(maxValidCol-minValidCol>maxColDelta){
						validRate = extractLine.getValidRateByYAxis((maxValidCol+minValidCol)/2-1, (maxValidCol+minValidCol)/2+1);
					}else{
						validRate = 1.0;
					}
					
					if(null!=lineCoef && (ImgExtractLine.getMinRSQ()<=lineCoef[2] 
							|| (maxValidCol-minValidCol)<=maxColDelta 
							|| validRate>minValidRate) 
							&& (extractLines.size()>0 && currentLineOffset > 0
								|| extractLines.isEmpty() && currentLineOffset>=0)
							&& slopeDelta<maxSlopeDelta 
							&& offsetDelta1>minOffsetDelta/3 
							&& offsetDelta2>minOffsetDelta/3 
							&& offsetDelta3>minOffsetDelta/3
							&& offsetDelta>minOffsetDelta){
						for(int k=0; k<imgWidth; k++){
							nearCol = (int)(k*lineCoef[0]+lineCoef[1]);
							if(nearCol>noiseScanRng && nearCol<(imgHeight-noiseScanRng)){
								noisePoints = 0;
								for(int n=-noiseScanRng; n<=noiseScanRng; n++){
									if(peakVals[k][nearCol+n]<noiseGrayThr){
										if(Math.abs(n)>1){
											noisePoints++;
										}else{
											extractLine.addOnlinePoint();
										}
									}
								}
								if(noisePoints>0) extractLine.addSideNoise(noisePoints);
							}else{
								break;
							}
						}
						
						noiseRate = maxNoiseRate + 1.0;
						if(extractLine.getOnlinePoints()>0) noiseRate = (double)extractLine.getNoisePoints() / extractLine.getOnlinePoints();
						
						if(extractLine.getOnlinePoints()>=(fittingMinPoints*0.8) 
							&& (noiseRate<maxNoiseRate 
							|| noiseRate>=maxNoiseRate 
							&& validRate>=1.0 
							&& ImgExtractLine.getMinRSQ()<=lineCoef[2])){
							
							if(extractLines.isEmpty()) extractLine.getLineCoef(true);
							lastLineSlope = extractLine.getLineSlope();
							lastLineOffset = extractLine.getLineIntercept();
							
							saveSearchingLines(searchingLinesData,myBaselineSlope,myBaselineOffset,extractLines.size(),"found");
							
							myBaselineSlope = extractLine.getLineSlope();
							myBaselineOffset = extractLine.getLineIntercept()+1;
							
							currentLineOffset = (int)(myBaselineSlope*(imgWidth-1)+myBaselineOffset);
							i = currentLineOffset+lineSearchingRng;
							bLineFound = true;
							extractLine = setLineBoundary(extractLine, imgGrays, defaultVal);
							extractLines.add(extractLine.clone());
							if(targetLinesQty==extractLines.size()) finalSearchingOffset = i;
							System.out.println("Line found:"+myBaselineSlope+"/"+myBaselineOffset);
						}
					}
				}
				if(!bLineFound) myBaselineOffset = myBaselineOffset+1;
				
				if(allPossibleLines.size()>0) lastPossibleLine = allPossibleLines.get(allPossibleLines.size()-1);
				if(!bLineFound && validCnt>5 && 0==extractLine.getLineIntercept()) extractLine.getLineCoef(false);
				if(allPossibleLines.size()>0 && validCnt==lastPossibleLine.getValidPoints()
					&& extractLine.getLineIntercept()-lastPossibleLine.getLineIntercept()<5){
					if(bLineFound || extractLine.getLineRSQ()>lastPossibleLine.getLineRSQ()){
						if(!bLineFound) bLineFound = (3==lastPossibleLine.getLineFlag()?true:false);
						allPossibleLines.remove(allPossibleLines.size()-1);
						if(allPossibleLines.size()>0){
							lastPossibleLine = allPossibleLines.get(allPossibleLines.size()-1);
						}else{
							lastPossibleLine = null;
						}
					}
				}
				if(allPossibleLines.isEmpty() || allPossibleLines.size()>0
					&& (validCnt!=lastPossibleLine.getValidPoints()
						|| extractLine.getLineIntercept()-lastPossibleLine.getLineIntercept()>=5)){
					if(bLineFound) extractLine.setLineFlag(3);
					allPossibleLines.add(extractLine.clone());
				}
				
				if(targetLinesQty==extractLines.size()){
					if(i>=finalSearchingOffset+lineScanRange*6) break;
				}
			}
		}
		
		if(extractLines.size()>0) extractLines = adjustAllSearchedLines(allPossibleLines,extractLines,imgGrays,defaultVal);
		saveImgData("graysSortLines_",sortData);
		return extractLines;
	}
	
	private double[] getPoleOffset(ArrayList<ImgExtractLine> lines, int targetLinesQty){
		double[] poleOffset = new double[]{0.0,0.0};
		double oddPoleOffset = 0.0, evenPoleOffset = 0.0, tmpOffset = 0.0;
		double oddMin = 0.0, oddMax = 0.0, evenMin = 0.0, evenMax = 0.0;
		int oddPoleCnt = 1, evenPoleCnt = 1;
		
		if(null!=lines && lines.size()>2){
			oddPoleOffset = lines.get(1).getLineIntercept() - lines.get(0).getLineIntercept();
			evenPoleOffset = lines.get(2).getLineIntercept() - lines.get(1).getLineIntercept();
			oddMin = oddPoleOffset; oddMax = oddMin;
			evenMin = evenPoleOffset; evenMax = evenMin;
			if(lines.size()>3){
				for(int i=3; i<lines.size(); i++){
					tmpOffset = lines.get(i).getLineIntercept() - lines.get(i-1).getLineIntercept();
					if(1==i%2){
						oddPoleCnt++;
						oddPoleOffset += tmpOffset;
						if(oddMin>tmpOffset) oddMin = tmpOffset;
						if(oddMax<tmpOffset) oddMax = tmpOffset;
					}else{
						evenPoleCnt++;
						evenPoleOffset += tmpOffset;
						if(evenMin>tmpOffset) evenMin = tmpOffset;
						if(evenMax<tmpOffset) evenMax = tmpOffset;
					}
				}
			}
			if(oddPoleCnt>2){
				oddPoleOffset = (oddPoleOffset-oddMin-oddMax)/(oddPoleCnt-2);
			}else{
				oddPoleOffset = oddPoleOffset/oddPoleCnt;
			}
			if(evenPoleCnt>2){
				evenPoleOffset = (evenPoleOffset-evenMin-evenMax)/(evenPoleCnt-2);
			}else{
				evenPoleOffset = evenPoleOffset/evenPoleCnt;
			}
			poleOffset[0] = evenPoleOffset;
			poleOffset[1] = oddPoleOffset;
		}
		
		return poleOffset;
	}
	
	private double[] twoLinesAvgOffset(double slope1, double offset1, double slope2, double offset2, double startX, double stopX){
		double sumOffset = 0.0, avgOffset = 0.0, stepX = (startX+stopX)/10, dblTemp = 0.0;
		double minOffset = 0.0, maxOffset = 0.0, offsetFactor = 1.0;
		int counter = 0;
		
		if(startX>stopX){
			dblTemp = startX;
			startX = stopX;
			stopX = dblTemp;
		}
		
		if(0==stepX) stepX = 1.0;
		if(offset2>offset1) offsetFactor = -1.0;
		minOffset = Math.abs(offset2-offset1); maxOffset = minOffset;
		for(double x = startX; x<=stopX; x+=stepX){
			dblTemp = (slope1*x+offset1 - (slope2*x+offset2))*offsetFactor;
			sumOffset += dblTemp;
			counter++;
			if(minOffset>dblTemp) minOffset = dblTemp;
			if(maxOffset<dblTemp) maxOffset = dblTemp;
		}
		
		avgOffset = sumOffset / counter;
		
		return new double[]{avgOffset,minOffset,maxOffset};
	}
	
	private ArrayList<ImgExtractLine> adjustAllSearchedLines(ArrayList<ImgExtractLine> allPossibleLines,ArrayList<ImgExtractLine> extractLines,int[][] imgGrays,int defaultVal){
		double ratio = 0.0, bestRsq = 0.0, offsetDelta = 0.0, off2 = 0.0, ratio2 = 0.0, ratio3 = 0.0;
		double refOffset = 0.0, lastOffset = 0.0, nextOffset = -1.0, tmpOffset = 0.0;
		int bestIdx = 0, refValidPts = 0, lastFoundIdx = -1, size = 0, nextIdx = 0;
		int scanRng = lineScanRange/2, offsetCmpFlag = 0;
		boolean swapPoleOffset = false;
		ArrayList<ImgExtractLine> adjLines1 = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjLines2 = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjustLines = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjLines = new ArrayList<ImgExtractLine>();
		ImgExtractLine tmpLine = null, lastLine = null;
		
		//Step_1:Adjust the first found lines
		for(int idx=0; idx<allPossibleLines.size(); idx++){
			if(3!=allPossibleLines.get(idx).getLineFlag()) continue;
			refValidPts = allPossibleLines.get(idx).getValidPoints();
			refOffset = allPossibleLines.get(idx).getLineIntercept();
			bestRsq = allPossibleLines.get(idx).getLineRSQ();
			bestIdx = idx;
			for(int i=-scanRng; i<=scanRng; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(null!=tmpLine && Math.abs(refOffset-tmpLine.getLineIntercept())<5){
					ratio = (double)tmpLine.getValidPoints()/refValidPts;
					if(ratio>0.95 && bestRsq<tmpLine.getLineRSQ()){
						bestRsq = tmpLine.getLineRSQ();
						bestIdx = idx+i;
					}
				}
			}
			tmpLine = allPossibleLines.get(bestIdx);
			offsetDelta = tmpLine.getLineIntercept();
			if(null!=lastLine){
				offsetDelta -= lastLine.getLineIntercept();
				if(offsetDelta<=5){
					adjLines1.remove(adjLines1.size()-1);
					lastLine = null;
				}
			}
			if(null==lastLine || null!=lastLine && offsetDelta>5){
				if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, defaultVal);
				adjLines1.add(tmpLine);
				lastLine = tmpLine;
			}
		}
		
		//Step_2:Get all potential lines via peak searching method
		adjLines2 = adjustAllSearchedLinesEx(allPossibleLines,imgGrays,defaultVal);
		adjLines2 = doubleCheckAllPotentialLines(adjLines2,allPossibleLines);
		double[] poleOffset = getPoleOffset(adjLines2,targetLinesQty);
		
		//Step_3:Combine all lines from Step_1 and Step_2
		lastFoundIdx = -1;
		if(adjLines2.isEmpty()){
			for(int i=0; i<adjLines1.size(); i++){
				adjustLines.add(adjLines1.get(i));
			}
		}else{
			for(int i=0; i<adjLines1.size(); i++){//First found lines are more reliable(they are the base)
				bestIdx = -1;
				tmpLine = adjLines1.get(i);
				refOffset = tmpLine.getLineIntercept();
				
				if(12==adjustLines.size()){
					System.out.print("");
				}
				
				for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
					//Double confirm in all potential lines
					if(Math.abs(refOffset-adjLines2.get(j).getLineIntercept())<3){
						bestIdx = j;
						break;
					}
					if(adjLines2.get(j).getLineIntercept()-refOffset>3) break;
				}
				
				//TODO Verification
				if(bestIdx<0 && adjustLines.isEmpty() && adjLines2.size()>0){
					//Double check the most outer line
					double[] offs = twoLinesAvgOffset(tmpLine.getLineSlope(),tmpLine.getLineIntercept(),adjLines2.get(0).getLineSlope(),adjLines2.get(0).getLineIntercept(),0.0,imgGrays.length);
					if(offs[0]<3 && offs[1]<1) continue;
				}
				
				if(bestIdx>=0){
					if(lastFoundIdx<0 && bestIdx>0){//Suppose adjLines2 is reliable
						for(int j=0; j<bestIdx; j++){
							adjustLines.add(adjLines2.get(j));
							lastFoundIdx = j;
						}
					}
					
					//Found in potential lines
					if(lastFoundIdx>=0 && bestIdx-lastFoundIdx>1){
						//Confirm the missed potential lines
						if(adjustLines.size()>0) refOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
						for(int k=(lastFoundIdx+1);k<bestIdx;k++){
							if(adjLines2.get(k).getLineIntercept()<refOffset) continue;
							lastOffset = refOffset;
							if(k>0) lastOffset = adjLines2.get(k-1).getLineIntercept();
							offsetDelta = adjLines2.get(k+1).getLineIntercept()-adjLines2.get(k).getLineIntercept();
							if((adjLines2.get(k).getLineIntercept()-lastOffset>=5 || k<2 && adjLines2.get(k).getLineIntercept()-lastOffset>=3)
								&& offsetDelta>=5){
								ratio = (double)adjLines2.get(k).getValidPoints()/imgGrays.length;
								if(ratio>=minValidRatio){
									adjustLines.add(adjLines2.get(k));
								}else{
									off2 = adjLines2.get(k).getLineIntercept()-lastOffset;
									ratio = offsetDelta/off2;
									if(ratio<minOffsetChgRate || ratio>maxOffsetChgRate
										|| offsetDelta>5 && off2>5) adjustLines.add(adjLines2.get(k));
								}
							}
						}
					}
					lastFoundIdx = bestIdx;
					tmpLine = adjLines2.get(bestIdx);
				}else if(adjustLines.size()>0 && refOffset>adjLines2.get(0).getLineIntercept()){
					//Not found in potential lines(after the 1st found line)
					if(lastFoundIdx+1<adjLines2.size()){
						offsetDelta = refOffset-adjLines2.get(lastFoundIdx+1).getLineIntercept();
						if(offsetDelta>5){//First found line is behind the potential lines
							for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
								if(refOffset-adjLines2.get(j).getLineIntercept()>5){
									adjustLines.add(adjLines2.get(j));
									lastFoundIdx = j;
								}else{
									break;
								}
							}
						}else if(offsetDelta<=5){//First found line is very closed to the potential lines
							for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
								if(refOffset>adjLines2.get(j).getLineIntercept()){//Fetch the potential lines
									adjustLines.add(adjLines2.get(j));
									lastFoundIdx = j;
								}else{
									break;
								}
							}
						}
					}
					
					//Get next potential line
					nextOffset = -1.0; nextIdx = -1;
					for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
						if(adjLines2.get(j).getLineIntercept()>refOffset){
							nextOffset = adjLines2.get(j).getLineIntercept();
							nextIdx = j;
							break;
						}
					}
					
					//Offset change rate of the first found line
					ratio = -1.0; lastOffset = 0.0; ratio2 = -1.0;
					size = adjustLines.size();
					if(size>0){
						lastOffset = adjustLines.get(size-1).getLineIntercept();
						if(size>2){//Refer to previous data
							ratio = (refOffset - lastOffset)/(adjustLines.get(size-2).getLineIntercept()-adjustLines.get(size-3).getLineIntercept());
							ratio2 = (nextOffset - lastOffset)/(adjustLines.get(size-2).getLineIntercept()-adjustLines.get(size-3).getLineIntercept());
						}else if(nextIdx>0 && nextIdx+3<adjLines2.size()){
							ratio = (refOffset - lastOffset)/(adjLines2.get(nextIdx+3).getLineIntercept()-adjLines2.get(nextIdx+2).getLineIntercept());
							ratio2 = (nextOffset - lastOffset)/(adjLines2.get(nextIdx+3).getLineIntercept()-adjLines2.get(nextIdx+2).getLineIntercept());
						}else{
							if(1==adjustLines.size()%2){//Supposed the first found line is a missing potential line
								if(poleOffset[1]>0){
									ratio = (refOffset - lastOffset)/poleOffset[1];
									ratio2 = (nextOffset - lastOffset)/poleOffset[1];
								}
							}else{
								if(poleOffset[0]>0){
									ratio = (refOffset - lastOffset)/poleOffset[0];
									ratio2 = (nextOffset - lastOffset)/poleOffset[0];
								}
							}
						}
					}
					
					swapPoleOffset = true;
					offsetCmpFlag = offsetInSamePeak(allPossibleLines,refOffset,nextOffset,lastOffset);
					
					if(-1==offsetCmpFlag){
						continue;//Skip because the first found line is not in a valid peak region
					}else if(2==offsetCmpFlag){
						continue;//Skip because the first found line is in the valid peak region of last line
					}else if(1==offsetCmpFlag){
						tmpLine = adjLines2.get(nextIdx);//Replace the first found line with next potential line
						lastFoundIdx = nextIdx;
						swapPoleOffset = false;
					}else if(0==offsetCmpFlag){
						if(!(adjustLines.size()>2 && ratio>minOffsetChgRate)){
							ratio3 = (double)tmpLine.getValidPoints()/imgGrays.length;
							if(ratio3<minValidRatio) continue;
						}
						if(ratio<maxOffsetChgRate*0.6 && ratio2>0 && ratio2<maxOffsetChgRate) continue;
					}
					
					if(swapPoleOffset){
						tmpOffset = poleOffset[0];
						poleOffset[0] = poleOffset[1];
						poleOffset[1] = tmpOffset;
					}
				}
				if(adjustLines.isEmpty()) tmpLine.setLineChecked(true);//Fixed the 1st found layer
				adjustLines.add(tmpLine);
			}
		}
		
		//Step_4:Check whether all layers are found
		if(adjustLines.size()<targetLinesQty){
			refOffset = 0.0;
			if(adjustLines.size()>0) refOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
			for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
				if(adjLines2.get(j).getLineIntercept()>refOffset && adjustLines.size()<targetLinesQty){
					adjustLines.add(adjLines2.get(j));
				}
			}
		}
		
		LinkedHashMap<Double,Double> tendency = new LinkedHashMap<Double,Double>();
		double[] coef = null;
		for(int i=0; i<adjustLines.size(); i++){
			tmpLine = adjustLines.get(i);
			tmpLine.setLineIndex(i);
			tendency.put((double)i, tmpLine.getLineIntercept());
			if(tendency.size()<3){
				tmpLine.setTendencyRSQ(1.0);
			}else{
				coef = MathUtils.lineFitting(tendency);
				tmpLine.setTendencyRSQ(coef[2]);
			}
			if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, 255);
			
			//TODO Verification
			if(i<(targetLinesQty-3)) tmpLine.setLineChecked(true);
			
			adjLines.add(tmpLine);
			allPotentialLines.add(tmpLine);
		}
		
		//Add all potential lines
		if(adjLines2.size()>lastFoundIdx+1){
			refOffset = allPotentialLines.get(allPotentialLines.size()-1).getLineIntercept();
			for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
				if(adjLines2.get(j).getLineIntercept()>refOffset){
					allPotentialLines.add(adjLines2.get(j));
				}
			}
		}
		
		if(logEnabled){
			for(int i=0; i<adjustLines.size(); i++){
				tmpLine = adjustLines.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,0==i?true:false));
			}
			for(int i=0; i<adjLines2.size(); i++){
				tmpLine = adjLines2.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,false));
			}
			for(int i=0; i<extractLines.size(); i++){
				tmpLine = extractLines.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,false));
			}
			for(int i=0; i<allPossibleLines.size(); i++){
				tmpLine = allPossibleLines.get(i);
				LogUtils.rawLog("searchLineParas_", tmpLine.printLineParas(tmpLine.getLineFlag(),0==i?true:false));
			}
			logSelectedLinesGray(adjustLines,imgGrays,5);
		}
		
		return adjLines;
	}
	
	private void logSelectedLinesGray(ArrayList<ImgExtractLine> selectedLines, int[][] imgGrays, int grayScanRng){
		ImgExtractLine tmpLine = null;
		int imgWidth = imgGrays.length, imgHeight = imgGrays[0].length, col = 0;
		double lineSlope = 0.0, lineOffset = 0.0;
		String title = "LineIdx,Offset,Col,Edge1,Edge2,X", data = "";
		
		if(null!=selectedLines && selectedLines.size()>0){
			for(int i=0; i<imgWidth; i++){
				title += "," + i;
			}
			LogUtils.rawLog("selectedLinesXY_",title);
			for(int i=0; i<selectedLines.size(); i++){
				tmpLine = selectedLines.get(i);
				lineSlope = tmpLine.getLineSlope(); lineOffset = tmpLine.getLineIntercept();
				for(int j=-grayScanRng; j<=grayScanRng; j++){
					data = i + "," + lineOffset + "," + j + "," + tmpLine.getXAxisStop() + "," + tmpLine.getXAxisStart() + ",Y";
					for(int k=0; k<imgWidth; k++){
						col = (int)(lineSlope * k + lineOffset + j);
						if(col>=0 && col<imgHeight){
							data += "," + imgGrays[k][col];
						}else{
							data += ",255";
						}
					}
					LogUtils.rawLog("selectedLinesXY_",data);
				}
			}
		}
	}
	
	private boolean offsetInPeakRegion(ArrayList<ImgExtractLine> allPossibleLines, double chkOffset){
		boolean inPeakRegion = false;
		double minDelta = 0.0, offsetDelta = 0.0, ratio = 0.0;
		int mostCloseIdx = -1, scanRng = lineScanRange/2, counter = 0, minValidPts = 0;
		int size = allPossibleLines.size(), peakIdx = -1, maxValidPts = 0;
		
		if(size>0){
			//Get the index of chkOffset in allPossibleLines
			minDelta = Math.abs(allPossibleLines.get(0).getLineIntercept()-chkOffset);
			mostCloseIdx = 0;
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-chkOffset);
				if(minDelta>offsetDelta){
					minDelta = offsetDelta;
					mostCloseIdx = i;
				}
			}
			
			//Fine-tune the index of chkOffset
			peakIdx = -1; maxValidPts = 0;
			for(int i=-scanRng; i<=scanRng; i++){
				if(mostCloseIdx+i>=0 && mostCloseIdx+i<size){
					offsetDelta = Math.abs(allPossibleLines.get(mostCloseIdx+i).getLineIntercept()-chkOffset);
					if(offsetDelta<3){
						if(maxValidPts<allPossibleLines.get(mostCloseIdx+i).getValidPoints()){
							maxValidPts = allPossibleLines.get(mostCloseIdx+i).getValidPoints();
							peakIdx = mostCloseIdx+i;
						}
					}
				}
			}
			
			if(peakIdx>=0){
				//Possibility of being in the peak region
				counter = 0;
				for(int i=scanRng; i>0; i--){
					if(peakIdx-i>=0 && peakIdx+i<size){
						if(allPossibleLines.get(peakIdx).getValidPoints()>=allPossibleLines.get(peakIdx-i).getValidPoints()
							&& allPossibleLines.get(peakIdx).getValidPoints()>=allPossibleLines.get(peakIdx+i).getValidPoints()){
							counter++;
						}
					}
				}
				ratio = (double)counter/scanRng;
				if(ratio>0.66){
					//Check whether current peakIdx represents a valid peak or not
					maxValidPts = allPossibleLines.get(peakIdx).getValidPoints();
					minValidPts = maxValidPts;
					ratio = 0.0;
					//Get the base&max value in last 10 points
					for(int i=peakIdx; i>(peakIdx-10); i--){
						if(i<0) break;
						if(maxValidPts<allPossibleLines.get(i).getValidPoints()) maxValidPts = allPossibleLines.get(i).getValidPoints();
						if(minValidPts>allPossibleLines.get(i).getValidPoints()) minValidPts = allPossibleLines.get(i).getValidPoints();
					}
					if(maxValidPts>minValidPts) ratio = (double)(allPossibleLines.get(peakIdx).getValidPoints()-minValidPts)/(maxValidPts-minValidPts);
					if(ratio>0.2) inPeakRegion = true;
				}
			}
		}
		return inPeakRegion;
	}
	
	private int offsetInSamePeak(ArrayList<ImgExtractLine> allPossibleLines, double chkOffset, double nextOffset, double lastOffset){
		int rsltFlag = -1;
		double minDelta0 = 0.0, offsetDelta = 0.0, minDelta1 = 0.0, minDelta2 = 0.0;
		int chkIdx = -1, nextIdx = -1, lastIdx = -1;
		int size = allPossibleLines.size();
		int[] validPts = null, idx1 = null, idx2 = null;
		
		if(size>0 && chkOffset>0 && (nextOffset>0 || lastOffset>0)){
			minDelta0 = Math.abs(allPossibleLines.get(0).getLineIntercept()-chkOffset);
			minDelta1 = Math.abs(allPossibleLines.get(0).getLineIntercept()-nextOffset);
			minDelta2 = Math.abs(allPossibleLines.get(0).getLineIntercept()-lastOffset);
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-chkOffset);
				if(minDelta0>offsetDelta){
					minDelta0 = offsetDelta;
					chkIdx = i;
				}
				
				if(nextOffset>0){
					offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-nextOffset);
					if(minDelta1>offsetDelta){
						minDelta1 = offsetDelta;
						nextIdx = i;
					}
				}
				
				if(lastOffset>0){
					offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-lastOffset);
					if(minDelta2>offsetDelta){
						minDelta2 = offsetDelta;
						lastIdx = i;
					}
				}
			}
			
			validPts = getPossibleLinesValidDtPts(allPossibleLines);
			idx1 = MathUtils.getPeakCenterIndex(validPts, chkIdx, lineScanRange, true);
			if(idx1[0]>=0){
				rsltFlag = 0;
				if(nextIdx>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, nextIdx, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 1;
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(allPossibleLines.get(idx2[0]).getLineIntercept()-allPossibleLines.get(idx1[0]).getLineIntercept()<=lineScanRange/2) rsltFlag = 1;
						}
					}
				}
				if(0==rsltFlag && lastIdx>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, lastIdx, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 2;
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(allPossibleLines.get(idx1[0]).getLineIntercept()-allPossibleLines.get(idx2[0]).getLineIntercept()<=lineScanRange/2) rsltFlag = 2;
						}
					}
				}
			}
		}
		return rsltFlag;
	}
	
	private int offsetInSamePeakEx(ArrayList<ImgExtractLine> allPossibleLines, double offset1, double offset2){
		int rsltFlag = -1;//Not found in all possible lines
		double minDelta0 = 0.0, offsetDelta = 0.0, minDelta1 = 0.0;
		int index1 = -1, index2 = -1;
		int size = allPossibleLines.size();
		int[] validPts = null, idx1 = null, idx2 = null;
		
		if(size>0 && offset1>0 && offset2>0){
			minDelta0 = Math.abs(allPossibleLines.get(0).getLineIntercept()-offset1);
			minDelta1 = Math.abs(allPossibleLines.get(0).getLineIntercept()-offset2);
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-offset1);
				if(minDelta0>offsetDelta){
					minDelta0 = offsetDelta;
					index1 = i;
				}
				
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-offset2);
				if(minDelta1>offsetDelta){
					minDelta1 = offsetDelta;
					index2 = i;
				}
			}
			
			validPts = getPossibleLinesValidDtPts(allPossibleLines);
			idx1 = MathUtils.getPeakCenterIndex(validPts, index1, lineScanRange, true);
			if(idx1[0]>=0){
				rsltFlag = 0;//offset1 is found
				if(index2>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, index2, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 1;//offset1 and offset2 is in same peak
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(Math.abs(allPossibleLines.get(idx2[0]).getLineIntercept()-allPossibleLines.get(idx1[0]).getLineIntercept())<=lineScanRange/2) rsltFlag = 1;
						}
						
						if(0==rsltFlag && Math.abs(idx2[1]-idx1[1])<=2){
							rsltFlag = 2;//Left edge of offset1 and offset2 is the same
						}
					}
				}
			}
		}
		return rsltFlag;
	}
	
	private int[] getPossibleLinesValidDtPts(ArrayList<ImgExtractLine> allPossibleLines){
		int[] lineValidDataPts = new int[allPossibleLines.size()];
		for(int i=0; i<allPossibleLines.size(); i++){
			lineValidDataPts[i] = allPossibleLines.get(i).getValidPoints();
		}
		return lineValidDataPts;
	}
	
	private ArrayList<ImgExtractLine> roughCheckAllPotentialLines(ArrayList<ImgExtractLine> potentialLines){
		ArrayList<ImgExtractLine> newPotentialLines = new ArrayList<ImgExtractLine>();
		double currOffset = 0.0, nextOffset = 0.0;
		
		if(null!=potentialLines && potentialLines.size()>0){
			if(potentialLines.size()>1){
				for(int i=0; i<potentialLines.size()-1; i++){
					currOffset = potentialLines.get(i).getLineIntercept();
					nextOffset = potentialLines.get(i+1).getLineIntercept();
					if(currOffset>0 && currOffset<nextOffset){
						newPotentialLines.add(potentialLines.get(i));
					}
				}
				if(currOffset>0 && currOffset<nextOffset){
					newPotentialLines.add(potentialLines.get(potentialLines.size()-1));
				}
			}else{
				newPotentialLines = potentialLines;
			}
		}
		
		return newPotentialLines;
	}
	
	private ArrayList<ImgExtractLine> doubleCheckAllPotentialLines(ArrayList<ImgExtractLine> potentialLines, ArrayList<ImgExtractLine> allPossibleLines){
		ArrayList<ImgExtractLine> newPotentialLines = new ArrayList<ImgExtractLine>();
		
		potentialLines = roughCheckAllPotentialLines(potentialLines);
		if(null!=potentialLines && potentialLines.size()>0){
			int size = potentialLines.size(), newSize = 0;
			int currLineIdx = 0, lastLineIdx = 0;
			int peakFlags = -1;
			double ratio = 0.0;
			ImgExtractLine exLine = null;
			if(size<=1){
				newPotentialLines = potentialLines;
			}else{
				newPotentialLines.add(potentialLines.get(0));
				for(int i=1; i<size; i++){
					newSize = newPotentialLines.size();
					if(13==newSize){
						System.out.print("");
					}
					lastLineIdx = getLineIndex(allPossibleLines,newPotentialLines.get(newSize-1).getLineIntercept());
					currLineIdx = getLineIndex(allPossibleLines,potentialLines.get(i).getLineIntercept());
					if(lastLineIdx>0 && currLineIdx>lastLineIdx){
						if(newSize>2){//Check offset change rate of current line - see whether need to skip current line
							ratio = potentialLines.get(i).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
							ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
							if(ratio<maxOffsetChgRate*0.6){//Current line is very closed to last line
								ratio = (double)potentialLines.get(i).getValidPoints()/newPotentialLines.get(newSize-1).getValidPoints();
								if(ratio<0.2) continue;//Valid data points of current line is out of expectation
								
								peakFlags = offsetInSamePeakEx(allPossibleLines,newPotentialLines.get(newSize-1).getLineIntercept(),potentialLines.get(i).getLineIntercept());
								if(peakFlags>=1) continue;//Current line and last line is in the same peak
								
								if(i+1<size && newSize>2){//Double check next line
									ratio = potentialLines.get(i+1).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
									ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
									if(ratio<maxOffsetChgRate){
										if(ratio<maxOffsetChgRate*0.6){
											continue;//Next line is very close to last line, so skip current line
										}else if(newSize>4){
											ratio = potentialLines.get(i+1).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
											ratio = ratio/(newPotentialLines.get(newSize-4).getLineIntercept()-newPotentialLines.get(newSize-5).getLineIntercept());
											if(ratio<maxOffsetChgRate) continue;//Offset change rate btw next and last line lower than upper control limit is true
										}
									}
								}
							}
						}
						
						//Check whether there is line btw current and last line
						exLine = getPotentialLineBtw(allPossibleLines,lastLineIdx,currLineIdx,newPotentialLines.get(newSize-1).getValidPoints());
						
						if(null!=exLine){
							ratio = 1.0;
							if(newSize>2){
								ratio = exLine.getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
								ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
							}
							if(ratio>minOffsetChgRate) newPotentialLines.add(exLine);
						}
					}
					newPotentialLines.add(potentialLines.get(i));
				}
			}
		}
		
		return newPotentialLines;
	}
	
	private ImgExtractLine getPotentialLineBtw(ArrayList<ImgExtractLine> allPossibleLines,int startIdx,int stopIdx,int refValidDataPts){
		ImgExtractLine exLine = null;
		int validPts = 0, maxValidPts = -1, maxIdx = -1, peakFlag = 0;
		double ratio = 0.0, startOffset = 0.0, stopOffset = 0.0, foundOffset = 0.0;
		boolean startCheck = false, lineFound = false;
		if(null!=allPossibleLines && startIdx>0 && stopIdx>startIdx && stopIdx<allPossibleLines.size() && refValidDataPts>0){
			startOffset = allPossibleLines.get(startIdx).getLineIntercept();
			stopOffset = allPossibleLines.get(stopIdx).getLineIntercept();
			
			for(int i=startIdx; i<=stopIdx; i++){
				validPts = allPossibleLines.get(i).getValidPoints();
				ratio = (double)validPts/refValidDataPts;
				if(ratio<0.15){
					if(!startCheck){
						startCheck = true;
						maxValidPts = validPts;
						maxIdx = i;
					}else{
						ratio = (double)maxValidPts/refValidDataPts;
						if(ratio>0.2){
							lineFound = true;
							break;
						}
					}
				}
				if(startCheck){
					if(maxValidPts<validPts){
						maxValidPts = validPts;
						maxIdx = i;
					}
				}
			}
			
			if(lineFound){
				foundOffset = allPossibleLines.get(maxIdx).getLineIntercept();
				peakFlag = offsetInSamePeakEx(allPossibleLines,startOffset,foundOffset);
				if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,foundOffset,stopOffset);
				if(0==peakFlag) exLine = allPossibleLines.get(maxIdx);
			}
		}
		
		return exLine;
	}
	
	private int getLineIndex(ArrayList<ImgExtractLine> allPossibleLines, double lineOffset){
		int idx = -1;
		double offsetDelta = 0.0, minDelta = 10000.0;
		if(null!=allPossibleLines && allPossibleLines.size()>0){
			for(int i=0; i<allPossibleLines.size(); i++){
				offsetDelta = allPossibleLines.get(i).getLineIntercept() - lineOffset;
				if(offsetDelta<-5) continue;
				if(offsetDelta>5) break;
				
				offsetDelta = Math.abs(offsetDelta);
				if(minDelta>offsetDelta){
					minDelta = offsetDelta;
					idx = i;
				}
			}
		}
		return idx;
	}
	
	private int getMaxValidDataPtsLineIndex(ArrayList<ImgExtractLine> allPossibleLines, double startOffset, double stopOffset){
		int idx = -1, maxPts = 0;
		double lineOffset = 0.0;
		if(null!=allPossibleLines && allPossibleLines.size()>0){
			for(int i=0; i<allPossibleLines.size(); i++){
				lineOffset = allPossibleLines.get(i).getLineIntercept();
				if(lineOffset>stopOffset) break;
				if(lineOffset<startOffset) continue;
				if(maxPts<allPossibleLines.get(i).getValidPoints()){
					maxPts = allPossibleLines.get(i).getValidPoints();
					idx = i;
				}
			}
		}
		
		return idx;
	}
	
	private ArrayList<ImgExtractLine> adjustAllSearchedLinesEx(ArrayList<ImgExtractLine> allPossibleLines,int[][] imgGrays,int defaultVal){
		double ratio = 0.0, bestRsq = 0.0, refOffset = 0.0, lastOffset = 0.0, baseLine = 0.0, baseThr = 0.0;
		int bestIdx = 0, scanRng = lineScanRange/2, scanStart = -scanRng, scanStop = scanRng, maxVPts = 0, tmpVPts = 0;
		int lastBestIdx = 0, minValidPts = 0, basePts = 0, peakFlag = 0;
		ArrayList<ImgExtractLine> adjustLines = new ArrayList<ImgExtractLine>();
		ArrayList<Integer> maxValidPts = new ArrayList<Integer>();
		ArrayList<Integer> possLinesIdx = new ArrayList<Integer>();
		ImgExtractLine tmpLine = null;
		int[] lineValidDataPts = getPossibleLinesValidDtPts(allPossibleLines);
		
		LinkedHashMap<Integer,Integer> peaks = MathUtils.getPeakValsEx(lineValidDataPts, lineScanRange, true);
		
		for(int idx:peaks.keySet()){
			refOffset = allPossibleLines.get(idx).getLineIntercept();
			bestRsq = allPossibleLines.get(idx).getLineRSQ();
			maxVPts = allPossibleLines.get(idx).getValidPoints();
			bestIdx = idx;
			
			//Get peak index fine tune range
			for(int i=-scanRng; i>=0; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(0==tmpLine.getLineRSQ()) scanStart = i;
			}
			for(int i=0; i<=scanRng; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(0==tmpLine.getLineRSQ()) scanStop = i;
			}
			
			//Fine tune the peak index
			for(int i=scanStart; i<=scanStop; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(null!=tmpLine && Math.abs(refOffset-tmpLine.getLineIntercept())<5){
					tmpVPts = tmpLine.getValidPoints();
					ratio = (double)tmpVPts/peaks.get(idx);
					if(ratio>0.95 && bestRsq<tmpLine.getLineRSQ()){
						bestRsq = tmpLine.getLineRSQ();
						bestIdx = idx+i;
					}
					if(maxVPts<tmpVPts) maxVPts = tmpVPts;
				}
			}
			tmpLine = allPossibleLines.get(bestIdx);
			
			if(11==adjustLines.size()){
				System.out.print("");
			}
			
			ratio = 1.0;
			if(adjustLines.size()>1){
				lastOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
				tmpVPts = maxValidPts.get(maxValidPts.size()-1);
				if(tmpVPts>0){
					lastBestIdx = possLinesIdx.get(possLinesIdx.size()-1);
					minValidPts = tmpLine.getValidPoints();
					for(int k=lastBestIdx; k<=bestIdx; k++){
						if(minValidPts>allPossibleLines.get(k).getValidPoints()) minValidPts=allPossibleLines.get(k).getValidPoints();
					}
					if(tmpVPts!=minValidPts){
						baseThr = (tmpVPts-minValidPts)*0.2+minValidPts;
						baseLine = 0.0; basePts = 0;
						for(int k=lastBestIdx; k<=bestIdx; k++){
							if(allPossibleLines.get(k).getValidPoints()<baseThr){
								baseLine += allPossibleLines.get(k).getValidPoints();
								basePts++;
							}
						}
						if(basePts>0){
							baseLine = baseLine / basePts;
							ratio = (double)(tmpLine.getValidPoints()-baseLine)/(tmpVPts-baseLine);
						}else{
							ratio = (double)(tmpLine.getValidPoints()-minValidPts)/(tmpVPts-minValidPts);
						}
					}
				}
			}
			
			if(0==lastOffset || lastOffset>0 && tmpLine.getLineIntercept()-lastOffset>=5){
				if(lastOffset>0 && ratio<=0.2){
					peakFlag = offsetInSamePeakEx(allPossibleLines,lastOffset,refOffset);
					if(peakFlag>=1){
						continue;
					}else if(adjustLines.size()>3){
						ratio = (refOffset-lastOffset)/(adjustLines.get(adjustLines.size()-2).getLineIntercept()-adjustLines.get(adjustLines.size()-3).getLineIntercept());
						if(ratio<minOffsetChgRate) continue;
					}
				}
				if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, defaultVal);
				adjustLines.add(tmpLine);
				maxValidPts.add(maxVPts);
				possLinesIdx.add(bestIdx);
			}
		}
		
		return adjustLines;
	}
	
	private ImgExtractLine searchLine(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, double startSearchOffset, double stopSearchOffset, double mySearchSlope, int maxSearchRange){
		ImgExtractLine finalLine = null;
//		finalLine = getLineBtw(startSearchOffset,stopSearchOffset);
//		if(null!=finalLine){
//			if(0==finalLine.getXAxisStart()) finalLine = setLineBoundary(finalLine, imgGrays, defaultVal);
//			return finalLine;
//		}
		
		boolean bLineFound = false;
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int validCnt = 0, nearCol = 0, noisePoints = 0, realPoints = 0;
		int invalidCnt = 0, minValidCol = imgWidth*2, maxValidCol = -1;
		double noiseRate = 0.0, slopeDelta = 0.0, validRate = 0.0;
		double offsetDelta1 = 0.0, offsetDelta2 = 0.0, offsetDelta3 = 0.0, offsetDelta = 0.0;
		double invalidRatio = 0.0, maxColDelta = 3.0;
		int searchMinCol = 0, searchMaxCol = 0;
		int lineSearchingRng = lineScanRange / 2;//Two sides searching
		if(maxSearchRange<lineScanRange) lineSearchingRng = maxSearchRange/2;
		if(lineSearchingRng<=0) return null;
		
		int[][] searchingLinesData = new int[imgWidth][imgHeight];
		for(int i=0; i<imgWidth; i++){
			searchingLinesData[i] = peakVals[i].clone();
		}
		
		int fittingMinPoints = (int)(imgWidth * minValidRatio * 0.8);
		double[] lineCoef = null;
		finalLine = new ImgExtractLine();
		
		LinkedHashMap<Integer,ImgExtractLine> possibleLines = new LinkedHashMap<Integer,ImgExtractLine>();
		int possibleLineIdx = -1, bestValidRateIdx = -1;
		double bestValidRate = 0.0;
		
		if(stopSearchOffset>imgHeight) stopSearchOffset=imgHeight;
		if(imgWidth > fittingMinPoints && imgHeight > lineSearchingRng){
			for(int i=lineSearchingRng; i<=(maxSearchRange-lineSearchingRng); i++){
				minValidCol = imgWidth*2; maxValidCol = -1;
				ImgExtractLine extractLine = new ImgExtractLine();
				ImgExtractLine.setMinRSQ(0.7f);
				
				for(int j=(imgWidth-1); j>=0; j--){
					nearCol = (int)(j*mySearchSlope+startSearchOffset)+i;
					searchMinCol = (int)(j*mySearchSlope+startSearchOffset);
					searchMaxCol = (int)(j*mySearchSlope+stopSearchOffset);
					if(searchMinCol<0 || searchMinCol>(imgHeight-1)) continue;
					if(searchMaxCol<0 || searchMaxCol>(imgHeight-1)) continue;
					
					if((nearCol-lineSearchingRng)>=0 && nearCol<=(searchMaxCol-lineSearchingRng)){
						for(int k=-lineSearchingRng; k<=lineSearchingRng; k++){
							if(peakVals[j][nearCol+k]<lineFitGrayThr){
								extractLine.addPoint(j, nearCol+k, peakVals[j][nearCol+k]);
								if((nearCol+k)<minValidCol) minValidCol = nearCol+k;
								if((nearCol+k)>maxValidCol) maxValidCol = nearCol+k;
								if(Math.abs(k)<=1) extractLine.addRealPoints(j, nearCol+k, 1);
							}
							if(imgGrays[j][nearCol+k]>=noiseGrayThr) extractLine.addInvalidPoints(1);
						}
					}
				}
				
				if(i>=lineSearchingRng){
//					saveSearchingLines(searchingLinesData,mySearchSlope,startSearchOffset,i+500);
				}
				
				validCnt = extractLine.getValidPoints();
				realPoints = extractLine.getRealPoints();
				invalidCnt = extractLine.getInvalidPoints();
				invalidRatio = (double)invalidCnt / (lineSearchingRng*2+1) / imgWidth;
				if((validCnt>=fittingMinPoints 
						|| maxSearchRange<=3 
						|| realPoints>=fittingMinPoints*0.8) 
						&& invalidRatio<maxInvalidRatio){
					lineCoef = extractLine.getLineCoef(false);
					slopeDelta = Math.abs(mySearchSlope-extractLine.getLineSlope());
					offsetDelta1 = lineCoef[1] - startSearchOffset;
					offsetDelta2 = (lineCoef[0]-mySearchSlope)*imgWidth/2+lineCoef[1]-startSearchOffset;
					offsetDelta3 = (lineCoef[0]-mySearchSlope)*(imgWidth-1)+lineCoef[1]-startSearchOffset;
					offsetDelta = (offsetDelta1+offsetDelta2+offsetDelta3)/3;
					
					if(maxValidCol-minValidCol>maxColDelta){
						validRate = extractLine.getValidRateByYAxis((maxValidCol+minValidCol)/2-1, (maxValidCol+minValidCol)/2+1);
					}else{
						validRate = 1.0;
					}
					
					if(slopeDelta<maxSlopeDelta 
							&& offsetDelta1>0 && offsetDelta2>0 && offsetDelta3>0 
							&& offsetDelta>minOffsetDelta*0.5){
						possibleLineIdx++;
						possibleLines.put(possibleLineIdx, extractLine);
						if(bestValidRate<validRate){
							bestValidRate = validRate;
							bestValidRateIdx = possibleLineIdx;
						}
					}
					
					if(null!=lineCoef && (ImgExtractLine.getMinRSQ()<=lineCoef[2] 
							|| (maxValidCol-minValidCol)<=maxColDelta 
							|| validRate>minValidRate) 
							&& slopeDelta<maxSlopeDelta 
							&& offsetDelta1>0 && offsetDelta2>0 && offsetDelta3>0
							&& offsetDelta>minOffsetDelta*0.5){
						for(int k=0; k<imgWidth; k++){
							nearCol = (int)(k*lineCoef[0]+lineCoef[1]);
							if(nearCol>noiseScanRng && nearCol<(imgHeight-noiseScanRng)){
								noisePoints = 0;
								for(int n=-noiseScanRng; n<=noiseScanRng; n++){
									if(peakVals[k][nearCol+n]<noiseGrayThr){
										if(Math.abs(n)>1){
											noisePoints++;
										}else{
											extractLine.addOnlinePoint();
										}
									}
								}
								if(noisePoints>0) extractLine.addSideNoise(noisePoints);
							}else{
								break;
							}
						}
						
						noiseRate = (double)extractLine.getNoisePoints() / extractLine.getOnlinePoints();
						if(extractLine.getOnlinePoints()>=(fittingMinPoints*0.8) 
							&& noiseRate<maxNoiseRate){
							
							extractLine = setLineBoundary(extractLine, imgGrays, defaultVal);
							finalLine = extractLine;
							bLineFound = true;
							break;
						}
					}
				}
			}
		}
		
		if(!bLineFound){
			if(possibleLines.size()>0 && bestValidRateIdx>=0){
				finalLine = possibleLines.get(bestValidRateIdx);
				finalLine = setLineBoundary(finalLine, imgGrays, defaultVal);
			}else{
				finalLine = null;
			}
		}
		
		if(null!=finalLine){
			if(logEnabled){
				LogUtils.rawLog("researchLineParas_", finalLine.printLineParas(0,true));
			}
		}
		
		return finalLine;
	}
	
	private LinkedHashMap<Integer,Double> getSharpChgPosition(double[] chgs){
		LinkedHashMap<Integer, Double> sharpChgPos = new LinkedHashMap<Integer, Double>();
		
		int col = chgs.length;
		int scanPoints = 4;//Two sides scanning
		int meatCndCnt = 0;
		if(col>8){
			for(int j=scanPoints; j<(col-scanPoints); j++){
				meatCndCnt = 0;
				for(int k=scanPoints; k>0; k--){
					if(0!=chgs[j] && chgs[j]<=chgs[j-k] && chgs[j]<=chgs[j+k]){
						meatCndCnt++;
					}
				}
				if(meatCndCnt==scanPoints){
					sharpChgPos.put(j, chgs[j]);
					j += scanPoints;
				}
			}
		}
		
		return sharpChgPos;
	}
	
	private void setLinesSharpChgPosition(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, int targetLinesQty){
		ImgExtractLine extLine = null;
		double lineSlope, lineOffset, stdevRatio = 0.0;
		double[] Xs = new double[10], Ys = new double[10], chgs = null, tmp = null;
		int firstChgPos = 0, nearCol = 0, imgHeight = imgGrays[0].length, size = 0;
		int start = -1, stop = -1, chgStopPos = 0;
		int[] grays = null;
		String str1 = "", str2 = "";
		String[] sGrays = new String[11];
		
		for(int lineIdx:linesMap.keySet()){
			extLine = linesMap.get(lineIdx);
			if(null!=extLine){
				lineSlope = extLine.getLineSlope();
				lineOffset = extLine.getLineIntercept()+extLine.getLineInterceptDelta();
				firstChgPos = extLine.getXAxisStart()+10;
				chgStopPos = extLine.getXAxisStop();
				chgs = new double[firstChgPos];
				grays = new int[firstChgPos];
				str1 = ""; str2 = "";
				for(int k=0; k<11; k++){
					sGrays[k] = "";
				}
				
				for(int i=firstChgPos; i>0;i--){
					size = 0;
					for(int k=0; k<10; k++){
						nearCol = (int)(k*lineSlope+lineOffset);
						if(nearCol>=0 && nearCol<imgHeight){
							try {
								Xs[k] = i + k;
								Ys[k] = imgGrays[(int)Xs[k]][nearCol];
								size++;
							} catch (Exception e) {
								System.out.println(Xs[k]+":"+i+"/"+k);
							}
						}
					}
					tmp = MathUtils.lineFitting(Xs, Ys, size);
					chgs[i-1] = tmp[0];
					nearCol = (int)(i*lineSlope+lineOffset);
					if(nearCol>=0 && nearCol<imgHeight){
						if(i<imgGrays.length) grays[i-1] = imgGrays[i][nearCol];
					}
					for(int k=-5; k<=5; k++){
						if((nearCol+k)>=0 && (nearCol+k)<imgHeight && i<imgGrays.length){
							sGrays[k+5] += "," + imgGrays[i][nearCol+k];
						}else{
							sGrays[k+5] += ",0";
						}
					}
					
					str1 += "," + i;
					str2 += "," + chgs[i-1];
				}
				
				LinkedHashMap<Integer,Double> sharpChgPos = getSharpChgPosition(chgs);
				LinkedHashMap<Integer,LinkedHashMap<SharpChgItems,Double>> sharpChgPosParas = new LinkedHashMap<Integer,LinkedHashMap<SharpChgItems,Double>>();
				size = -1;
				for(int key:sharpChgPos.keySet()){
					size++;
					if(start<0){
						start = key;
						continue;
					}else{
						stop = key;
					}
					LinkedHashMap<SharpChgItems,Double> statisticParas = new LinkedHashMap<SharpChgItems,Double>();
					tmp = extLine.getLineStatisticParas(linesMap, start, (start+stop)/2, imgGrays, lineIdx, evenLineLonger);
					stdevRatio = tmp[3];
					if(1==size){
						LinkedHashMap<SharpChgItems,Double> sttParas = new LinkedHashMap<SharpChgItems,Double>();
						double[] weightOfBeingLine = extLine.weightOfBeingLine(linesMap,firstChgPos-10, chgStopPos, 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, true, curLineIsLonger(lineIdx,evenLineLonger), false);
						sttParas.put(SharpChgItems.STDEV, tmp[3]);
						sttParas.put(SharpChgItems.STDEVRATIO, weightOfBeingLine[0]);
						sttParas.put(SharpChgItems.AREARATIO, tmp[4]);
						
						tmp = extLine.getLineStatisticParas(linesMap, firstChgPos-10, chgStopPos, imgGrays, lineIdx, evenLineLonger);
						sttParas.put(SharpChgItems.INNERGRAYRATIO, tmp[5]);
						sharpChgPosParas.put(start, sttParas);
					}
					tmp = extLine.getLineStatisticParas(linesMap, (start+stop)/2, stop, imgGrays, lineIdx, evenLineLonger);
					stdevRatio = tmp[3] / stdevRatio;
					
					statisticParas.put(SharpChgItems.STDEV, tmp[3]);
					statisticParas.put(SharpChgItems.STDEVRATIO, stdevRatio);
					statisticParas.put(SharpChgItems.AREARATIO, tmp[4]);
					statisticParas.put(SharpChgItems.INNERGRAYRATIO, tmp[5]);
					sharpChgPosParas.put(key, statisticParas);
					start = key;
				}
				extLine.setSharpChgPos(sharpChgPos);
				extLine.setSharpChgPosParas(sharpChgPosParas);
				
				if(logEnabled){
					LogUtils.rawLog("sharpChgGrays_", "X"+lineIdx+str1);
					LogUtils.rawLog("sharpChgGrays_", "S"+lineIdx+str2);
					for(int k=-5; k<=5; k++){
						LogUtils.rawLog("sharpChgGrays_", "G"+lineIdx+"("+k+")"+sGrays[k+5]);
					}
					LogUtils.rawLog("sharpChgPos_", extLine.printSharpChgPos(lineIdx));
				}
			}
		}
	}
	
	private double boundaryNewThreshold(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal, int boundaryIdx, int dblCfmDataPts){
		int imgWidth = imgGrays.length;
		int imgHeight = imgGrays[0].length;
		int counter1 = 0, nearCol = 0;
		
		double sumGray1 = 0.0, grayThr1 = lineFitGrayThr;
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		
		for(int k=boundaryIdx; k<imgWidth; k++){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(k<0 || nearCol<0 || nearCol>=imgHeight) continue;
			if(imgGrays[k][nearCol]<noiseGrayThr){
				counter1++;
				sumGray1 += imgGrays[k][nearCol];
			}
			if(counter1>=dblCfmDataPts) break;
		}
		if(counter1>0){
			grayThr1 = sumGray1 / counter1;
			grayThr1 = grayThr1 + (defaultVal - grayThr1)*0.25;
		}
		
		return grayThr1;
	}
	
	private boolean boundaryIsOK(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal, int boundaryIdx, int backwardPts, double grayThr1){
		boolean ok = false;
		int imgHeight = imgGrays[0].length;
		int nearCol = 0, continueCnt1 = 0;
		
		double minGray = 0.0;
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		
		for(int k=boundaryIdx; k>=boundaryIdx-backwardPts; k--){
			if(k<0) break;
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			
			//Check +/-1 tracks
			minGray = imgGrays[k][nearCol];
			if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
			if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
			
			if(minGray<grayThr1){
				if(continueCnt1<5) continueCnt1 = 0;
			}else{
				continueCnt1++;
			}
		}
		
		if(continueCnt1>=5) ok = true;
		return ok;
	}
	
	private ImgExtractLine setLineBoundary(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal){
		int imgWidth = imgGrays.length;
		int imgHeight = imgGrays[0].length;
		int start = (int)(imgWidth*0.5);
		int counter1 = 0, counter2 = 0, nearCol = 0, contCntThr = 5;
		int continueCnt1 = 0, continueCnt2 = 0, minGray = 0, continueCnt3 = 0;
		double sumGray1 = 0.0, grayThr1 = lineFitGrayThr, newGrayThr1 = grayThr1;
		double sumGray2 = 0.0, grayThr2 = lineFitGrayThr, meanGray2 = 150.0, grayThr3 = noiseGrayThr2;
		
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		for(int k=start; k<imgWidth; k++){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			if(imgGrays[k][nearCol]<noiseGrayThr){
				counter1++;
				sumGray1 += imgGrays[k][nearCol];
			}
		}
		if(counter1>0){
			grayThr1 = sumGray1 / counter1;
			grayThr1 = grayThr1 + (defaultVal - grayThr1)*0.25;
		}
		
		for(int k=start; k>=0; k--){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			
			//Check +/-1 tracks
			minGray = imgGrays[k][nearCol];
			if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
			if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
			
			if(minGray<grayThr1){
				if(continueCnt1<contCntThr) continueCnt1 = 0;//Reset only when the X Axis Start is not found
			}else{
				continueCnt1++;
			}
			if(contCntThr==continueCnt1){
				newGrayThr1 = boundaryNewThreshold(extractLine,imgGrays,defaultVal,k+contCntThr,30);//Renew the threshold for a double confirmation
				if(boundaryIsOK(extractLine,imgGrays,defaultVal,k+contCntThr,contCntThr+2,newGrayThr1)){
					extractLine.setXAxisStart(k+contCntThr);
					extractLine.setMeanGray((int)grayThr1);
				}else{
					grayThr1 = newGrayThr1;
					continueCnt1 = 0;
				}
			}
			
			//To find X Axis Stop after X Axis Start is found
			if(contCntThr<=continueCnt1){
				counter2++;
				sumGray2 += imgGrays[k][nearCol];
				meanGray2 = sumGray2 / counter2;
				grayThr2 = (meanGray2 + defaultVal) / 2;
				
				minGray = imgGrays[k][nearCol];
				if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
				if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
				
				if(minGray>=grayThr2){
					continueCnt2++;
				}else{
					if(continueCnt2<contCntThr) continueCnt2=0;
				}
				
				if(minGray>=grayThr3){
					continueCnt3++;
				}else{
					if(continueCnt3<contCntThr) continueCnt3=0;
				}
				
				if(contCntThr<=continueCnt2 || contCntThr<=continueCnt3){
					extractLine.setXAxisStop(k+contCntThr);
					break;
				}
			}
		}
		
		return extractLine;
	}
	
	private ImgExtractLine getBaseLine(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int continueCnt = 0, minHeight = imgHeight, maxHeight = 0;
		int startY = 0, stopY = 0, contCntThr = 5, baseAvgPts = 10;
		int[][] startLine = new int[imgWidth][imgHeight];
		double baseGVal = 0.0, baseFactor = 0.9;
		String title = "", data = "";
		
		for(int i=0; i<imgWidth; i++){
			startLine[i] = imgGrays[i].clone();
		}
		
		int nearCol = 0;
		ImgExtractLine extractLine = new ImgExtractLine();
		LinkedHashMap<Integer,Integer> baseLineXY = new LinkedHashMap<Integer,Integer>();
		
		for(int i=(imgWidth-1); i>(int)(imgWidth*0.45); i-=10){
			continueCnt = 0; baseGVal = 0.0;
			for(int j=0; j<baseAvgPts; j++){
				baseGVal += imgGrays[i][j];
			}
			baseGVal = baseGVal / baseAvgPts * baseFactor;
			
			for(int j=baseAvgPts; j<imgHeight; j++){
				if(imgGrays[i][j]<baseGVal){
					continueCnt++;
				}else{
					baseGVal = 0.0;
					for(int k=j; k>j-baseAvgPts; k--){
						baseGVal += imgGrays[i][k];
					}
					baseGVal = baseGVal / baseAvgPts * baseFactor;
					continueCnt = 0;
				}
				if(continueCnt>=contCntThr){
					if(minHeight>(j-contCntThr)) minHeight = j-contCntThr;
					if(maxHeight<(j-contCntThr)) maxHeight = j-contCntThr;
					extractLine.addPoint(i, j-contCntThr, imgGrays[i][j-contCntThr]);
					baseLineXY.put(i, j-contCntThr);
					break;
				}
			}
		}
		extractLine.getLineCoef(false);
		
		//Fetch base line raw data
		if(logEnabled){
			if(baseLineXY.size()>0){
				startY = minHeight - 20;
				stopY = maxHeight + 30;
				if(startY<0) startY = 0;
				if(stopY>=imgHeight) stopY = imgHeight - 1;
				
				title = "x,y,rawY";
				for(int y=startY; y<=stopY; y++){
					title += "," + y;
				}
				LogUtils.rawLog("baseLineXY_",title);
				for(Integer key:baseLineXY.keySet()){
					data = key + "," + baseLineXY.get(key) + ",gray";
					for(int y=startY; y<=stopY; y++){
						data += "," + imgGrays[key][y];
					}
					LogUtils.rawLog("baseLineXY_",data);
				}
			}
			
			double startLineSlope = extractLine.getLineSlope();
			double startLineOffset = extractLine.getLineIntercept();
			for(int k=0; k<imgWidth; k++){
				nearCol = (int)(k*startLineSlope+startLineOffset);
				if(nearCol>=0 && nearCol<imgHeight) startLine[k][nearCol] = 0;
			}
			saveImgData("graysStartLine_",startLine);
		}
		
		return extractLine;
	}
	
	private ImgExtractLine getBaseLineBackup(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int continueCnt = 0, minHeight = imgHeight, maxHeight = 0;
		int startY = 0, stopY = 0;
		int[][] startLine = new int[imgWidth][imgHeight];
		String title = "", data = "";
		
		for(int i=0; i<imgWidth; i++){
			startLine[i] = imgGrays[i].clone();
		}
		
		int nearCol = 0;
		ImgExtractLine extractLine = new ImgExtractLine();
		LinkedHashMap<Integer,Integer> baseLineXY = new LinkedHashMap<Integer,Integer>();
		
		for(int i=(imgWidth-1); i>(int)(imgWidth*0.45); i-=10){
			continueCnt = 0;
			for(int j=0; j<imgHeight; j++){
				if(imgGrays[i][j]<noiseGrayThr2){
					continueCnt++;
				}else{
					continueCnt = 0;
				}
				if(continueCnt>10){
					if(minHeight>(j-10)) minHeight = j-10;
					if(maxHeight<(j-10)) maxHeight = j-10;
					extractLine.addPoint(i, j-10, imgGrays[i][j-10]);
					baseLineXY.put(i, j-10);
					break;
				}
			}
		}
		
		//Fetch base line raw data
		if(baseLineXY.size()>0){
			startY = minHeight - 20;
			stopY = maxHeight + 30;
			if(startY<0) startY = 0;
			if(stopY>=imgHeight) stopY = imgHeight - 1;
			
			title = "x,y,rawY";
			for(int y=startY; y<=stopY; y++){
				title += "," + y;
			}
			LogUtils.rawLog("baseLineXY_",title);
			for(Integer key:baseLineXY.keySet()){
				data = key + "," + baseLineXY.get(key) + ",gray";
				for(int y=startY; y<=stopY; y++){
					data += "," + imgGrays[key][y];
				}
				LogUtils.rawLog("baseLineXY_",data);
			}
		}
		
		extractLine.getLineCoef(false);
		double startLineSlope = extractLine.getLineSlope();
		double startLineOffset = extractLine.getLineIntercept();
		for(int k=0; k<imgWidth; k++){
			nearCol = (int)(k*startLineSlope+startLineOffset);
			if(nearCol>=0 && nearCol<imgHeight) startLine[k][nearCol] = 0;
		}
		saveImgData("graysStartLine_",startLine);
		
		return extractLine;
	}
	
	private int[][] getPeakVals(int[][] imgGrays, int[][] initVals){
		int[][] peakVals = null;
		if(null != imgGrays){
			int row = imgGrays.length;
			int col = imgGrays[0].length;
			int scanPoints = 3;//Two sides scanning
			int positiveCnt = 0, negativeCnt = 0;
			peakVals = new int[row][col];
			if(col>5){
				for(int i=0; i<row; i++){
					peakVals[i] = initVals[i].clone();
					for(int j=scanPoints; j<col; j++){
						if((j+scanPoints)<col){
							positiveCnt = 0;
							negativeCnt = 0;
							for(int k=scanPoints; k>0; k--){
								if(imgGrays[i][j]>imgGrays[i][j-k] && imgGrays[i][j]>imgGrays[i][j+k]){
									positiveCnt++;
								}
								
								if(imgGrays[i][j]<imgGrays[i][j-k] && imgGrays[i][j]<imgGrays[i][j+k]){
									negativeCnt++;
								}
							}
							if(negativeCnt==scanPoints){
								peakVals[i][j] = imgGrays[i][j];
								j += scanPoints;
							}
							if(positiveCnt==scanPoints) j += scanPoints;
						}else{
							break;
						}
					}
				}
			}
		}
		
		if(null!=peakVals) saveImgData("graysPeakVals_",peakVals);
		return peakVals;
	}
	
	private void saveImgData(String filePrefix, int[][] data){
		if(logEnabled){
			int width = data.length;
			int height = data[0].length;
			String str = "";
			
	    	for (int i = 0; i < width; i++) {
	        	str = "";
	            for (int j = (height-1); j >= 0; j--) {
	                str += data[i][j]+",";
	            }
	            LogUtils.rawLog(filePrefix,str);
	        }
		}
	}
	
	private void saveSearchingLines(int[][] data, double slope, double offset, int index, String flag){
		if(logEnabled){
			int imgWidth = data.length, imgHeight = data[0].length, nearCol = 0;
			for(int k=0; k<imgWidth; k++){
				nearCol = (int)(k*slope+offset);
				if(nearCol>=0 && nearCol<imgHeight){
					if(data[k][nearCol]>230) data[k][nearCol] = 0;
				}
			}
			saveImgData("graysSeachingLine_"+flag+"_"+index+"_",data);
		}
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:48.965
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:48.965
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:48.965
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:48.968
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:48.968
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:48.987
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.epp.logging.aeri.ui 2 26 2019-03-31 15:09:48.989
!MESSAGE Status index is not available. Version: 1.0.1.v20150913-0716
!STACK 0
org.apache.lucene.util.ThreadInterruptedException: java.lang.InterruptedException: sleep interrupted
	at org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run(SegmentInfos.java:696)
	at org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run(SegmentInfos.java:593)
	at org.apache.lucene.index.SegmentInfos.read(SegmentInfos.java:359)
	at org.apache.lucene.index.SegmentInfos.readCurrentVersion(SegmentInfos.java:480)
	at org.apache.lucene.index.DirectoryReader.isCurrent(DirectoryReader.java:901)
	at org.apache.lucene.index.DirectoryReader.doOpenNoWriter(DirectoryReader.java:471)
	at org.apache.lucene.index.DirectoryReader.doOpenIfChanged(DirectoryReader.java:450)
	at org.apache.lucene.index.DirectoryReader.doOpenIfChanged(DirectoryReader.java:391)
	at org.apache.lucene.index.IndexReader.openIfChanged(IndexReader.java:497)
	at org.eclipse.epp.internal.logging.aeri.ui.log.ProblemsDatabaseService.renewReaderAndSearcher(ProblemsDatabaseService.java:157)
	at org.eclipse.epp.internal.logging.aeri.ui.log.ProblemsDatabaseService.seen(ProblemsDatabaseService.java:78)
	at org.eclipse.epp.internal.logging.aeri.ui.log.ProblemsDatabaseService.seen(ProblemsDatabaseService.java:73)
	at org.eclipse.epp.internal.logging.aeri.ui.log.ReportPredicates$ProblemDatabaseIgnoredPredicate.apply(ReportPredicates.java:50)
	at org.eclipse.epp.internal.logging.aeri.ui.log.ReportPredicates$ProblemDatabaseIgnoredPredicate.apply(ReportPredicates.java:1)
	at org.eclipse.epp.internal.logging.aeri.ui.log.PredicateDebugDecorator.apply(PredicateDebugDecorator.java:40)
	at com.google.common.base.Predicates$AndPredicate.apply(Predicates.java:343)
	at org.eclipse.epp.internal.logging.aeri.ui.log.LogListener.logging(LogListener.java:118)
	at org.eclipse.core.internal.runtime.RuntimeLog.logToListeners(RuntimeLog.java:161)
	at org.eclipse.core.internal.runtime.PlatformLogWriter.logged(PlatformLogWriter.java:103)
	at org.eclipse.osgi.internal.log.ExtendedLogReaderServiceFactory.safeLogged(ExtendedLogReaderServiceFactory.java:88)
	at org.eclipse.osgi.internal.log.ExtendedLogReaderServiceFactory.logPrivileged(ExtendedLogReaderServiceFactory.java:217)
	at org.eclipse.osgi.internal.log.ExtendedLogReaderServiceFactory.log(ExtendedLogReaderServiceFactory.java:189)
	at org.eclipse.osgi.internal.log.ExtendedLogServiceFactory.log(ExtendedLogServiceFactory.java:65)
	at org.eclipse.osgi.internal.log.ExtendedLogServiceImpl.log(ExtendedLogServiceImpl.java:87)
	at org.eclipse.osgi.internal.log.LoggerImpl.log(LoggerImpl.java:54)
	at org.eclipse.core.internal.runtime.PlatformLogWriter.logging(PlatformLogWriter.java:44)
	at org.eclipse.core.internal.runtime.RuntimeLog.log(RuntimeLog.java:97)
	at org.eclipse.core.runtime.SafeRunner.handleException(SafeRunner.java:71)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:44)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)
Caused by: java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run(SegmentInfos.java:694)
	... 38 more

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:48.992
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:49.007
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:49.010
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:49.022
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:898)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:767)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:716)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:639)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:631)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:49.024
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:898)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:767)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:716)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:639)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:631)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:49.039
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:597)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:49.045
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:597)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-31 15:09:50.987
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.sto.utils;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashMap;

import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.stream.ImageOutputStream;

import com.sto.base.PolePositionItems;
import com.sto.base.SharpChgItems;
import com.sto.data.ImgExtractLine;
import com.sto.data.ProductSpec;

public class ImageUtils {
	//Judge Criteria
	private final double minValidRatio = 0.15;//Very depending on the image quality
	private final double minValidRate = 0.7;//Check it in +/-1 line
	private final double maxInvalidRatio = 0.4;//There should be no much white area around the line
	private final double maxSlopeDelta = 0.1;//The lines should be parallel
	private final double minOffsetDelta = 3.0;//There should be some distance between two near line
	private final double maxNoiseRate = 0.4;//There should be no much noise around the line
	private final double maxOffsetChgRate = 1.4;//Check whether some line is missed
	private final double minOffsetChgRate = 0.7;//Check whether there is noise line
	private final int noiseScanRng = 2;//Two sides scanning
	private final int lineScanRange = 6;//One side scanning
	private int targetLinesQty = 16;//The total lines to extract
	private double lineFitGrayThr = 255 * 0.8;
	private final double noiseGrayThr = 255 * 0.9;
	private final double noiseGrayThr2 = 255 * 0.95;
	private final double noiseGrayThr3 = 255 * 0.15;
	private final double minBestRsq = 0.991;
	private final int lineIndexBase = 100;
	private boolean firstPoleIsLonger = false;
	private boolean firstPoleIsThicker = true;
	
	private int[][] finalData = null;
	private boolean logEnabled = true;
	private boolean evenPoleIsLonger = false;
	private long imgProcTime = 0;
	private long imgStartSavingT = 0;
	
	private ProductSpec productSpec = ProductSpec.getInstance();
	private LinkedHashMap<String, Object> criteria = null;
	
	private ArrayList<ImgExtractLine> allPossibleLines = new ArrayList<ImgExtractLine>();
	private ArrayList<ImgExtractLine> allPotentialLines = new ArrayList<ImgExtractLine>();
	private LinkedHashMap<String, Double> imgProcResultLength = new LinkedHashMap<String, Double>();
	private LinkedHashMap<String, Boolean> imgProcResultOK = new LinkedHashMap<String, Boolean>();
	private LinkedHashMap<String, Double> imgProcResultAngle = new LinkedHashMap<String, Double>();
	private LinkedHashMap<String, String> imgProcResultStr = new LinkedHashMap<String, String>();
	
	private void clearMemory(){
		allPossibleLines.clear();
		allPotentialLines.clear();
		imgProcResultLength.clear();
		imgProcResultOK.clear();
		imgProcResultAngle.clear();
	}
	
	public void setLogEnabled(boolean enabled){
		logEnabled = enabled;
	}
	
	public long getImgProcTime(){
		return imgProcTime;
	}
	
	public long getImgStartSavingTime(){
		return imgStartSavingT;
	}
	
	private PolePositionItems getPolePositionInImage(BufferedImage BI){
		PolePositionItems polePosition = PolePositionItems.TOPLEFT;
		int imgWidth = BI.getWidth(), imgHeight = BI.getHeight();
		int[] fourCornersGray = new int[4];
        int pixel = 0, minGray = 0, minGrayIdx = 0;
        
        int start = (int)(imgHeight*0.25), stop = start-10;
        int width = (int)(imgWidth*0.25);
        for(int height=start; height>stop; height--){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[0] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.25); stop = start-10;
        width = (int)(imgWidth*0.75);
        for(int height=start; height>stop; height--){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[1] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.75); stop = start+10;
        width = (int)(imgWidth*0.75);
        for(int height=start; height<stop; height++){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[2] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.75); stop = start+10;
        width = (int)(imgWidth*0.25);
        for(int height=start; height<stop; height++){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[3] += (pixel & 0xffffff - 0xffff00);
        }
		
        minGray = fourCornersGray[0];
        minGrayIdx = 0;
        for(int i=0; i<fourCornersGray.length; i++){
        	if(fourCornersGray[i]<minGray){
        		minGray = fourCornersGray[i];
        		minGrayIdx = i;
        	}
        }
        
        switch(minGrayIdx){
        case 0:
        	polePosition = PolePositionItems.TOPLEFT;
        	break;
        case 1:
        	polePosition = PolePositionItems.TOPRIGHT;
        	break;
        case 2:
        	polePosition = PolePositionItems.BOTTOMRIGHT;
        	break;
        case 3:
        	polePosition = PolePositionItems.BOTTOMLEFT;
        	break;
        }
        
		return polePosition;
	}
	
	private LinkedHashMap<PolePositionItems,Integer> getLayersQty(){
		LinkedHashMap<PolePositionItems,Integer> layers = new LinkedHashMap<PolePositionItems,Integer>();
		
		layers.put(PolePositionItems.BOTTOMRIGHT, 
				Integer.parseInt(""+criteria.get("lowerRightCornerLayers")));
		
		layers.put(PolePositionItems.BOTTOMLEFT, 
				Integer.parseInt(""+criteria.get("lowerLeftCornerLayers")));
		
		layers.put(PolePositionItems.TOPRIGHT, 
				Integer.parseInt(""+criteria.get("topRightCornerLayers")));
		
		layers.put(PolePositionItems.TOPLEFT, 
				Integer.parseInt(""+criteria.get("topLeftCornerLayers")));
		
		return layers;
	}
	
	private void setFirstPoleConfig(){
		String c1 = (String) criteria.get("firstPoleIsShorter");
		String c2 = (String) criteria.get("firstPoleIsThicker");
		
		if(null!=c1) firstPoleIsLonger = (1==Integer.parseInt(c1)?false:true);
		if(null!=c2) firstPoleIsThicker = (1==Integer.parseInt(c2)?true:false);
	}
	
	private ArrayList<Object> edgeFoundParas(BufferedImage BI, PolePositionItems polePosition, double baseFactor, int layersQty, boolean searchWidth, int grapWidthStart, int grapWidthStop
		, int i, int baseAvgPts, int searchStart, int searchStop, int searchPos, int continueCnt1
		, int continueCntThr, int backOffPixels
		, double currGray, double baseGVal, double searchLineFactor, double grapFactor, int[] heightRng
		, ArrayList<Double> slopes, double[] searchParas){
		
		ArrayList<Object> edgeParas = new ArrayList<Object>();
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int edgeStart = 0, edgeStop = 0, maxLen = 0;
        boolean edgeFound = false, forwardSearch = searchStart>searchStop?false:true;
        
		if(currGray<baseGVal){
    		continueCnt1++;
    		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
    			if(searchStart<=i+continueCntThr){
    				searchLineFactor = searchLineFactor*(forwardSearch?0.8:1.25);
    				if(searchWidth){
    					searchStart = (int)(imgWidth*searchLineFactor);
    				}else{
    					searchStart = (int)(imgHeight*searchLineFactor);
    				}
    				if(forwardSearch && searchStart<imgWidth-baseAvgPts || !forwardSearch && searchStart>baseAvgPts){
    					i = searchStart;
    					searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, forwardSearch);
    					baseGVal = searchParas[1] * baseFactor;
    					slopes.clear();
    					slopes.add(searchParas[2]);
        				continueCnt1=0;
    				}
    			}
    			
    			if(forwardSearch){
	    			edgeStart = i + backOffPixels;
	    			if(edgeStart>maxLen) edgeStart = maxLen;
	    			if(searchWidth){
	    				edgeStop = edgeStart - (int)(imgWidth*grapFactor);
	    			}else{
	    				edgeStop = edgeStart - (int)(imgHeight*grapFactor);
	    			}
	    			if(edgeStop<0) edgeStop = 0;
    			}else{
    				edgeStart = i - backOffPixels;
        			if(edgeStart<0) edgeStart = 0;
        			if(searchWidth){
        				edgeStop = edgeStart + (int)(imgWidth*grapFactor);
        			}else{
        				edgeStop = edgeStart + (int)(imgHeight*grapFactor);
        			}
        			if(edgeStop>maxLen) edgeStop = maxLen;
    			}
    			
    			edgeFound = true;
    		}
    		if(searchWidth && currGray<noiseGrayThr3 && null==heightRng){//Already enter the very dark region(almost search to the picture edge)
    			heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
				searchPos = (heightRng[0]+heightRng[1])/2;
				searchStart = (int)(imgWidth*searchLineFactor);
				i = searchStart;
				searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
				baseGVal = searchParas[1] * baseFactor;
				slopes.clear();
				slopes.add(searchParas[2]);
				continueCnt1=0;
    		}
    	}else{
    		baseGVal = searchParas[1] * baseFactor;
    		continueCnt1=0;
    	}
		
		edgeParas.add(0, continueCnt1);
		edgeParas.add(1, searchStart);
		edgeParas.add(2, edgeStart);
		edgeParas.add(3, edgeStop);
		edgeParas.add(4, baseGVal);
		
		return edgeParas;
	}
	
	private int[] getImgProcEdges(BufferedImage BI, PolePositionItems polePosition, double baseFactor, int layersQty, boolean searchWidth, int grapWidthStart, int grapWidthStop){
		int edgeStart = 0, edgeStop = 0, backOffPixels = 50, baseAvgPts = 10, searchPos = 0;
		int continueCnt1 = 0, continueCntThr = 5, maxLen = 0, searchStart = 0, searchStop = 0;
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int[] heightRng = null;
		double baseGVal = 0.0, grapFactor = 0.0, searchLineFactor = 0.0, currGray = 0.0;
		double[] searchParas = null;
		ArrayList<Double> slopes = new ArrayList<Double>();
		ArrayList<Object> edgeParas = null;
		
		if(searchWidth){
			maxLen = imgWidth - 1;
			grapFactor = 0.375;
			if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
	        	searchLineFactor = 0.85;
	        	if(polePosition==PolePositionItems.TOPRIGHT) searchLineFactor = 0.15;
	        	searchPos = (int)(imgHeight*searchLineFactor);
	        	searchStart = baseAvgPts; searchStop = imgWidth-1;
	        	edgeStart = searchStart;
				edgeStop = searchStart + (int)(imgWidth*grapFactor);
			}else{
				searchLineFactor = 0.15;
	        	if(polePosition==PolePositionItems.BOTTOMLEFT) searchLineFactor = 0.85;
	        	searchPos = (int)(imgHeight*searchLineFactor);
	        	searchStart = imgWidth-baseAvgPts; searchStop = 0;
	        	edgeStart = searchStart;
				edgeStop = searchStart - (int)(imgWidth*grapFactor);
			}
		}else{
			maxLen = imgHeight - 1;
			if(layersQty<=8){
				grapFactor = 0.25;
	        }else{
	        	grapFactor = 0.28 / 8.0 * layersQty;
	        }
			
			if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.BOTTOMLEFT){
	        	searchLineFactor = 0.75;
	        	if(polePosition==PolePositionItems.BOTTOMLEFT) searchLineFactor = 0.25;
	        	if(grapWidthStart<0 || grapWidthStop<0){
	        		searchPos = (int)(imgWidth*searchLineFactor);
	        	}else{
	        		searchPos = (grapWidthStart + grapWidthStop)/2;
	        	}
	        	searchStart = baseAvgPts; searchStop = imgHeight-1;
	        	edgeStart = searchStart;
				edgeStop = searchStart + (int)(imgHeight*grapFactor);
			}else{
				searchLineFactor = 0.25;
				if(polePosition==PolePositionItems.TOPRIGHT) searchLineFactor = 0.75;
				if(grapWidthStart<0 || grapWidthStop<0){
	        		searchPos = (int)(imgWidth*searchLineFactor);
	        	}else{
	        		searchPos = (grapWidthStart + grapWidthStop) / 2;
	        	}
	        	searchStart = imgHeight-baseAvgPts; searchStop = 0;
	        	edgeStart = searchStart;
				edgeStop = searchStart - (int)(imgHeight*grapFactor);
			}
		}
		
		searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
		currGray = searchParas[0];
		baseGVal = searchParas[1] * baseFactor;
		slopes.add(searchParas[2]);
		
		if(searchStart>searchStop){
        	for(int i=searchStart; i>=searchStop; i--){
        		searchParas = getEdgeSearchParas(BI, i, baseAvgPts, searchPos, searchWidth, false);
        		currGray = searchParas[0];
        		slopes.add(searchParas[2]);
        		
        		if(currGray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){
            			if(searchStart>=i-continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            				searchLineFactor = searchLineFactor*1.25;
            				if(searchWidth){
            					searchStart = (int)(imgWidth*searchLineFactor);
            				}else{
            					searchStart = (int)(imgHeight*searchLineFactor);
            				}
            				if(searchStart>baseAvgPts){
            					i = searchStart;
            					searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
            					baseGVal = searchParas[1] * baseFactor;
            					slopes.clear();
            					slopes.add(searchParas[2]);
	            				continueCnt1=0;
	            				continue;
            				}
            			}
            			edgeStart = i - backOffPixels;
            			if(edgeStart<0) edgeStart = 0;
            			if(searchWidth){
            				edgeStop = edgeStart + (int)(imgWidth*grapFactor);
            			}else{
            				edgeStop = edgeStart + (int)(imgHeight*grapFactor);
            			}
            			if(edgeStop>maxLen) edgeStop = maxLen;
            			break;
            		}
            		
            		if(searchWidth && currGray<noiseGrayThr3 && null==heightRng){//Already enter the very dark region(almost search to the picture edge)
            			heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
        				searchPos = (heightRng[0]+heightRng[1])/2;
        				searchStart = (int)(imgWidth*searchLineFactor);
        				i = searchStart;
        				searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
    					baseGVal = searchParas[1] * baseFactor;
    					slopes.clear();
    					slopes.add(searchParas[2]);
        				continueCnt1=0; 
        				continue;
            		}
            	}else{
            		baseGVal = searchParas[1] * baseFactor;
            		continueCnt1=0;
            	}
        	}
        }else{
        	for(int i=searchStart; i<=searchStop; i++){
        		searchParas = getEdgeSearchParas(BI, i, baseAvgPts, searchPos, searchWidth, true);
        		currGray = searchParas[0];
        		slopes.add(searchParas[2]);
        		
        		edgeParas = edgeFoundParas(BI, polePosition, baseFactor, layersQty, searchWidth, grapWidthStart, grapWidthStop
        				, i, baseAvgPts, searchStart, searchStop, searchPos, continueCnt1
        				, int continueCntThr, int backOffPixels
        				, double currGray, double baseGVal, double searchLineFactor, double grapFactor, int[] heightRng
        				, ArrayList<Double> slopes, double[] searchParas);
        	}
        }
        
		return new int[]{edgeStart, edgeStop};
	}
	
	private double[] getEdgeSearchParas(BufferedImage BI, int currIdx, int baseAvgPts, int searchPos, boolean searchWidth, boolean forwardSearch){
		ArrayList<Integer> xAxis = new ArrayList<Integer>();
		ArrayList<Integer> yAxis = new ArrayList<Integer>();
		int pixel = 0, gray = 0, start = 0, stop = 0, currGray = 0;
		double avgGray = 0.0;
		double[] coef = null;
		
		if(forwardSearch){
			start = currIdx - baseAvgPts + 1; stop = currIdx;
		}else{
			start = currIdx; stop = currIdx + baseAvgPts - 1;
		}
		
		if(searchWidth){
			pixel = BI.getRGB(currIdx, searchPos);
			currGray = (pixel & 0xffffff - 0xffff00);
		}else{
			pixel = BI.getRGB(searchPos, currIdx);
			currGray = (pixel & 0xffffff - 0xffff00);
		}
		
		for(int i=start; i<=stop; i++){
			if(searchWidth){
    			pixel = BI.getRGB(i, searchPos);
            	gray = (pixel & 0xffffff - 0xffff00);
    		}else{
    			pixel = BI.getRGB(searchPos, i);
            	gray = (pixel & 0xffffff - 0xffff00);
    		}
			xAxis.add(i);
			yAxis.add(gray);
			avgGray += gray;
		}
		
		avgGray = avgGray / baseAvgPts;
		coef = MathUtils.lineFitting(xAxis, yAxis);
		
		return new double[]{(double)currGray,avgGray,coef[0]*coef[0]};
	}
	
	private int[] getImgProcWidthRng(BufferedImage BI, PolePositionItems polePosition, int layersQty){
		int[] widthRng = new int[2];
		int[] heightRng = null;
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int grapWidthStart = 0, grapWidthStop = 0, backOffPixels = 50, baseAvgPts = 10;
        int continueCnt1 = 0, start = 0, stop = 0, pixel = 0, gray = 0, continueCntThr = 5;
        double heightFactor = 0.0, widthFactor = 0.0, baseGVal = 0.0, baseFactor = 0.95;
		String strX = "X", strG = "G";
		
        if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
        	heightRng = null;
        	widthFactor = 0.25; heightFactor = 0.85;
        	if(polePosition==PolePositionItems.TOPRIGHT) heightFactor = 0.15;
        	start = (int)(imgWidth*widthFactor); stop = imgWidth-1;
        	int h = (int)(imgHeight*heightFactor);
        	
        	grapWidthStart = start;
			grapWidthStop = grapWidthStart + (int)(imgWidth*0.375);
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start-baseAvgPts; k<start; k++){
	        		pixel = BI.getRGB(k, h);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		widthFactor = widthFactor*0.8;
    				start = (int)(imgWidth*widthFactor);
    				if(start<=baseAvgPts){
    					start = baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int w=start; w<stop; w++){
        		pixel = BI.getRGB(w, h);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strX += "," + w;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){
            			if(start>=w-continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            				widthFactor = widthFactor*0.8;
            				start = (int)(imgWidth*widthFactor);
            				if(start>baseAvgPts){
            					w = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start-baseAvgPts; k<start; k++){
	            	        		pixel = BI.getRGB(k, h);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapWidthStart = w - backOffPixels;
            			if(grapWidthStart<0) grapWidthStart = 0;
            			grapWidthStop = grapWidthStart + (int)(imgWidth*0.375);
            			if(grapWidthStop>=imgWidth) grapWidthStop = imgWidth - 1;
            			break;
            		}
            		if(gray<noiseGrayThr3){//Already enter the very dark region(almost search to the picture edge)
            			if(null!=heightRng){
            				//If the height range is fixed, fixed the width range by guessing
	            			grapWidthStart = (int)(imgWidth*0.75);
	            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
	            			break;
            			}else{
            				heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
            				h = (heightRng[0]+heightRng[1])/2;
            				widthFactor = 0.25;
            				start = (int)(imgWidth*widthFactor);
            				w = start; continueCnt1=0; continue;
            			}
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=w; k>w-baseAvgPts; k--){
                		pixel = BI.getRGB(k, h);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(polePosition==PolePositionItems.TOPLEFT || polePosition==PolePositionItems.BOTTOMLEFT){
        	heightRng = null;
        	widthFactor = 0.75; heightFactor = 0.15;
        	if(polePosition==PolePositionItems.BOTTOMLEFT) heightFactor = 0.85;
        	start = (int)(imgWidth*widthFactor); stop = 0;
        	int h = (int)(imgHeight*heightFactor);
        	
        	grapWidthStart = start;
			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start+baseAvgPts; k>start; k--){
	        		pixel = BI.getRGB(k, h);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		widthFactor = widthFactor*1.25;
    				start = (int)(imgWidth*widthFactor);
    				if(start>=imgWidth-baseAvgPts){
    					start = imgWidth-baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int w=start; w>stop; w--){
        		pixel = BI.getRGB(w, h);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strX += "," + w;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start<=w+continueCntThr){
            				widthFactor = widthFactor*1.25;
            				start = (int)(imgWidth*widthFactor);
            				if(start<imgWidth-baseAvgPts){
            					w = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start+baseAvgPts; k>start; k--){
	            	        		pixel = BI.getRGB(k, h);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapWidthStart = w + backOffPixels;
            			if(grapWidthStart>=imgWidth) grapWidthStart = imgWidth - 1;
            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
            			if(grapWidthStop<0) grapWidthStop = 0;
            			break;
            		}
            		if(gray<noiseGrayThr3){//Already enter the very dark region(almost search to the picture edge)
            			if(null!=heightRng){
            				//If the height range is fixed, fixed the width range by guessing
	            			grapWidthStart = (int)(imgWidth*0.75);
	            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
	            			break;
            			}else{
            				heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
            				h = (heightRng[0]+heightRng[1])/2;
            				widthFactor = 0.75;
            				start = (int)(imgWidth*widthFactor);
            				w = start; continueCnt1=0; continue;
            			}
            		}
            	}else{
            		baseGVal = 0.0;
    	        	for(int k=start; k<start+baseAvgPts; k++){
    	        		pixel = BI.getRGB(k, h);
    	            	gray = (pixel & 0xffffff - 0xffff00);
    	        		baseGVal += gray;
    	        	}
    	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
    	        	
            		continueCnt1=0;
            	}
        	}
        }
		
        if(logEnabled){
        	LogUtils.rawLog("imgProcRegion_", strX);
        	LogUtils.rawLog("imgProcRegion_", strG);
        }
        
        widthRng[0] = grapWidthStart;
        widthRng[1] = grapWidthStop;
		return widthRng;
	}
	
	private int[] getImgProcHeightRng(BufferedImage BI, PolePositionItems polePosition, int layersQty, int grapWidthStart, int grapWidthStop){
		int[] heightRng = new int[2];
		int imgHeight = BI.getHeight();
		int imgWidth = BI.getWidth();
        int grapHeightStart = 0, grapHeightStop = 0, backOffPixels = 30, baseAvgPts = 10;
        int width = 0, continueCnt1 = 0, start = 0, stop = 0, pixel = 0, gray = 0, continueCntThr = 5;
        double heightFactor = 0.0, grapHeightFactor = 0.5, baseGVal = 0.0, baseFactor = 0.95;
        String strY = "Y", strG = "G";
        
        if(layersQty<=8){
        	grapHeightFactor = 0.25;
        }else{
        	grapHeightFactor = 0.28 / 8.0 * layersQty;
        }
		
        if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.BOTTOMLEFT){
        	heightFactor = 0.375;
        	start = (int)(imgHeight*heightFactor); stop = imgHeight-1;
        	
        	grapHeightStart = start;
			grapHeightStop = grapHeightStart + (int)(imgHeight*grapHeightFactor);
        	
        	if(grapWidthStart<0 || grapWidthStop<0){
        		if(polePosition==PolePositionItems.BOTTOMRIGHT) width = (int)(imgWidth*0.75);
        		if(polePosition==PolePositionItems.BOTTOMLEFT) width = (int)(imgWidth*0.25);
        	}else{
        		width = (grapWidthStart + grapWidthStop)/2;
        	}
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start-baseAvgPts; k<start; k++){
	        		pixel = BI.getRGB(width, k);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		heightFactor = heightFactor*0.8;
    				start = (int)(imgHeight*heightFactor);
    				if(start<=baseAvgPts){
    					start = baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int height=start; height<stop; height++){
        		pixel = BI.getRGB(width, height);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strY += "," + height;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start>=height-continueCntThr){
            				heightFactor = heightFactor*0.8;
            				start = (int)(imgHeight*heightFactor);
            				if(start>baseAvgPts){
            					height = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start-baseAvgPts; k<start; k++){
	            	        		pixel = BI.getRGB(width, k);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapHeightStart = height - backOffPixels;
            			if(grapHeightStart<0) grapHeightStart = 0;
            			grapHeightStop = grapHeightStart + (int)(imgHeight*grapHeightFactor);
            			if(grapHeightStop >= imgHeight){
            				grapHeightStart = grapHeightStart - (grapHeightStop-imgHeight);
            				grapHeightStop = imgHeight - 1;
            			}
            			break;
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=start; k>start-baseAvgPts; k--){
                		pixel = BI.getRGB(width, k);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(polePosition==PolePositionItems.TOPRIGHT || polePosition==PolePositionItems.TOPLEFT){
        	heightFactor = 0.625;
        	start = (int)(imgHeight*heightFactor); stop = 0;
        	
        	grapHeightStart = start;
			grapHeightStop = grapHeightStart - (int)(imgHeight*grapHeightFactor);
        	
        	if(grapWidthStart<0 || grapWidthStop<0){
        		if(polePosition==PolePositionItems.TOPRIGHT) width = (int)(imgWidth*0.75);
        		if(polePosition==PolePositionItems.TOPLEFT) width = (int)(imgWidth*0.25);
        	}else{
        		width = (grapWidthStart + grapWidthStop) / 2;
        	}
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start+baseAvgPts; k>start; k--){
	        		pixel = BI.getRGB(width, k);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		heightFactor = heightFactor*1.25;
    				start = (int)(imgHeight*heightFactor);
    				if(start>=imgHeight-baseAvgPts){
    					start = imgHeight - baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int height=start; height>stop; height--){
        		pixel = BI.getRGB(width, height);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strY += "," + height;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start<=height+continueCntThr){
            				heightFactor = heightFactor*1.25;
            				start = (int)(imgHeight*heightFactor);
            				if(start<imgHeight-baseAvgPts){
            					height = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start+baseAvgPts; k>start; k--){
	            	        		pixel = BI.getRGB(width, k);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapHeightStart = height + backOffPixels;
            			if(grapHeightStart>=imgHeight) grapHeightStart = imgHeight - 1;
            			grapHeightStop = grapHeightStart - (int)(imgHeight*grapHeightFactor);
            			if(grapHeightStop<0){
            				grapHeightStart = grapHeightStart - grapHeightStop;
            				grapHeightStop = 0;
            			}
            			break;
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=start; k<start+baseAvgPts; k++){
                		pixel = BI.getRGB(width, k);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(logEnabled){
        	LogUtils.rawLog("imgProcRegion_", strY);
        	LogUtils.rawLog("imgProcRegion_", strG);
        }
        
        heightRng[0] = grapHeightStart;
        heightRng[1] = grapHeightStop;
		return heightRng;
	}
	
	private int[] getImageProcRegion(BufferedImage BI, PolePositionItems polePosition, int layersQty){
		int[] grapImgStart = new int[4];
		int[] grapImgWidthRng = null, grapImgHeightRng = null;
		
		grapImgWidthRng = getImgProcWidthRng(BI,polePosition,layersQty);
		grapImgHeightRng = getImgProcHeightRng(BI,polePosition,layersQty,grapImgWidthRng[0],grapImgWidthRng[1]);
		
        grapImgStart[0] = grapImgHeightRng[0];
        grapImgStart[1] = grapImgHeightRng[1];
        grapImgStart[2] = grapImgWidthRng[0];
        grapImgStart[3] = grapImgWidthRng[1];
        
		return grapImgStart;
	}
	
	public boolean procImage(String imgRootDir, String imgFileName, boolean outImg, String specifiedSpec){
		boolean imgPassed = false;
		
        try {
			imgPassed = procImageEx(imgRootDir, imgFileName, outImg, specifiedSpec);
			clearMemory();
		} catch (Exception e) {
			LogUtils.errorLog("Process "+imgRootDir+File.separator+imgFileName+" error:"+e.getMessage());
		}
        
        return imgPassed;
	}
	
	private boolean procImageEx(String imgRootDir, String imgFileName, boolean outImg, String specifiedSpec){
		String src = imgRootDir + File.separator + imgFileName;
		criteria = productSpec.getData(imgRootDir);
		if(null==criteria){
			if(null!=specifiedSpec && !"".equals(specifiedSpec.trim())) criteria = productSpec.getData(specifiedSpec);
			if(null==criteria){
				System.out.println("Product Spec for "+imgRootDir+" is not set yet!");
				return false;
			}
		}
		
		long startProcTime = System.currentTimeMillis();
		File file = new File(src);
        BufferedImage BI = null;
        try{
            BI = ImageIO.read(file);
            if(null==BI){
            	System.out.println("Read "+src+" failed");
            	return false;
            }
        }catch(Exception e){
            e.printStackTrace();
            return false;
        }
        
        int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int grapHeightStart = 0, grapHeightStop = 0, grapHeight = 0;
        int grapWidthStart = 0, grapWidthStop = 0, grapWidth = 0;
        int[][] imgGrays = null, initVals = null, peakVals = null;
        int pixel = 0, gray = 0;
        
        PolePositionItems polePosition = getPolePositionInImage(BI);
        System.out.println("Pole Position:"+polePosition);
        
        LinkedHashMap<PolePositionItems,Integer> layers = getLayersQty();
        targetLinesQty = layers.get(polePosition)*2;
        if(targetLinesQty<=0) return false;
        LogUtils.clearLog(true);
        
        int[] imgProcRegion = getImageProcRegion(BI,polePosition,targetLinesQty/2);
        grapHeightStart = imgProcRegion[0]; grapHeightStop = imgProcRegion[1];
        grapWidthStart = imgProcRegion[2]; grapWidthStop = imgProcRegion[3];
        grapHeight = Math.abs(grapHeightStart-grapHeightStop);
        grapWidth = Math.abs(grapWidthStart-grapWidthStop);
        imgGrays = new int[grapWidth][grapHeight];
    	initVals = new int[imgGrays.length][imgGrays[0].length];
    	
    	if(grapWidthStop > grapWidthStart){
    		if(grapHeightStop > grapHeightStart){
    			//Bottom-right
    			for(int i=grapWidthStart; i<grapWidthStop; i++){
            		for(int j=grapHeightStart; j<grapHeightStop; j++){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[i-grapWidthStart][j-grapHeightStart] = gray;
            			initVals[i-grapWidthStart][j-grapHeightStart] = 255;
            		}
            	}
    		}else{
    			//Top-right
    			for(int i=grapWidthStart; i<grapWidthStop; i++){
            		for(int j=grapHeightStart; j>grapHeightStop; j--){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[i-grapWidthStart][grapHeightStart-j] = gray;
            			initVals[i-grapWidthStart][grapHeightStart-j] = 255;
            		}
            	}
    		}
    	}else{
    		if(grapHeightStop < grapHeightStart){
    			//Top-left
    			for(int i=grapWidthStart; i>grapWidthStop; i--){
            		for(int j=grapHeightStart; j>grapHeightStop; j--){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[grapWidthStart-i][grapHeightStart-j] = gray;
            			initVals[grapWidthStart-i][grapHeightStart-j] = 255;
            		}
            	}
    		}else{
    			//Bottom-left
    			for(int i=grapWidthStart; i>grapWidthStop; i--){
            		for(int j=grapHeightStart; j<grapHeightStop; j++){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[grapWidthStart-i][j-grapHeightStart] = gray;
            			initVals[grapWidthStart-i][j-grapHeightStart] = 255;
            		}
            	}
    		}
    	}
    	
        //Start image processing
        boolean imgPassed = false;
        allPossibleLines.clear();
        allPotentialLines.clear();
        imgProcResultLength.clear();
        imgProcResultOK.clear();
        imgProcResultAngle.clear();
        if(null!=imgGrays){
        	peakVals = getPeakVals(imgGrays,initVals);
            if(null!=peakVals){
            	setFirstPoleConfig();
            	ImgExtractLine baseLine = getBaseLine(peakVals,initVals,imgGrays,255);
            	if(null!=baseLine && baseLine.getLineRSQ()>0){
            		ArrayList<ImgExtractLine> extractLines = searchLines(peakVals,initVals,imgGrays,255,baseLine);
            		if(extractLines.size()>0){
            			imgPassed = checkLines(peakVals,initVals,imgGrays,255,baseLine,extractLines);
            		}
            	}else{
            		System.out.println("getBaseLine failed");
            	}
            }
        }
        
        //Save output image
        if(outImg){
        	BI = createBufferedImage(BI);
        	if(null!=finalData && finalData.length>0){
        		int realX = 0, realY = 0;
        		int firstLen = finalData.length, secondLen = finalData[0].length;
        		for(int i=0; i<firstLen; i++){
        			if(grapWidthStart>grapWidthStop){
    					realX = grapWidthStart - i;
    				}else{
    					realX = grapWidthStart + i;
    				}
        			
        			for(int j=0; j<secondLen; j++){
        				if(grapHeightStart>grapHeightStop){
        					realY = grapHeightStart - j;
        				}else{
        					realY = grapHeightStart + j;
        				}
        				
        				if(finalData[i][j]<255){
        					pixel = BI.getRGB(realX, realY);
        					if(4==finalData[i][j]){
        						BI.setRGB(realX, realY, Color.RED.getRGB());
        					}else{
        						if(evenPoleIsLonger && 0==finalData[i][j]%2 || !evenPoleIsLonger && 1==finalData[i][j]%2){
        							BI.setRGB(realX, realY, Color.ORANGE.getRGB());
        						}else{
        							BI.setRGB(realX, realY, Color.BLACK.getRGB());
        						}
        					}
        				}
        			}
        		}
        	}
        	
	        Iterator<ImageWriter> it = ImageIO.getImageWritersByFormatName("png");//
	        ImageWriter writer = it.next();
	        ImageOutputStream ios;
			try {
				writeProcResultInfo(imgFileName,BI,polePosition,imgPassed,imgWidth,imgHeight,startProcTime);
				if(imgPassed){
					ios = ImageIO.createImageOutputStream(new File(src+".OK.png"));
				}else{
					ios = ImageIO.createImageOutputStream(new File(src+".NG.png"));
				}
				writer.setOutput(ios);
		        writer.write(BI);
		        BI.flush();
		        ios.flush();
		        ios.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
        }
        
        String[] imgProcRslt = getImgProcRsltData(imgFileName);
        imgProcRslt[0] = imgProcRslt[0]+",imgSavingT(ms)";
        imgProcRslt[1] = imgProcRslt[1]+","+(System.currentTimeMillis()-getImgStartSavingTime());
        setImgProcRsltData(imgFileName,imgProcRslt[0],imgProcRslt[1]);
        
        return imgPassed;
	}
	
	private BufferedImage createBufferedImage(BufferedImage baseBI){
		int width = baseBI.getWidth();
		int height = baseBI.getHeight();
		
		BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
        bi.getGraphics().drawImage(baseBI, 0, 0,width, height, null);
        baseBI = null;
        
        return bi;
	}
	
	private void writeProcResultInfo(String imgFileName, BufferedImage BI, PolePositionItems polePosition, boolean imgPassed, int imgWidth, int imgHeight, long startProcTime){
		int txtX = 0, txtY = 0, txtOffset = 25, txtLine = 0, oriY = 0;
		double minL = 1000.0, maxL = -1000.0, curL = 0.0;
		String lenInfo = "", procRsltTitle = "", procRsltData = "";
		DecimalFormat df = new DecimalFormat("0.000");
		DecimalFormat df1 = new DecimalFormat("0.0");
		Graphics g = BI.getGraphics();
		g.setFont(new Font("Serif",Font.BOLD,54));
		g.setColor(imgPassed?Color.DARK_GRAY:Color.RED);
		if(polePosition==PolePositionItems.TOPLEFT || polePosition==PolePositionItems.BOTTOMLEFT){
			txtX = (int)(imgWidth*0.75);
			txtY = (int)(imgHeight*0.25);
		}else if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
			txtX = (int)(imgWidth*0.15);
			txtY = (int)(imgHeight*0.25);
		}
		oriY = txtY;
		
		g.drawString(imgPassed?"OK":"NG", txtX, txtY);
		g.setFont(new Font("Serif",Font.BOLD,18));
		txtLine = 3;
		txtY += txtOffset * txtLine;
		for(String key:imgProcResultLength.keySet()){
			txtY += txtOffset;
			curL = imgProcResultLength.get(key);
			lenInfo = key+" = "+df.format(curL);
			procRsltTitle += ","+key;
			procRsltData += ","+df.format(curL);
			
			if(null!=imgProcResultAngle.get(key)){
				lenInfo += " ["+df1.format(imgProcResultAngle.get(key))+"deg]";
			}
			
			if(imgProcResultOK.get(key)){
				g.setColor(Color.DARK_GRAY);
			}else{
				g.setColor(Color.RED);
			}
			g.drawString(lenInfo, txtX, txtY);
			if(minL>curL) minL = curL;
			if(maxL<curL) maxL = curL;
		}
		imgStartSavingT = System.currentTimeMillis();
		imgProcTime = imgStartSavingT-startProcTime;
		g.setColor(Color.DARK_GRAY);
		g.drawString("PRO_T = "+imgProcTime+" ms", txtX, oriY+txtOffset);
		g.drawString("MIN_L = "+df.format(minL)+" mm", txtX, oriY+txtOffset*2);
		g.drawString("MAX_L = "+df.format(maxL)+" mm", txtX, oriY+txtOffset*3);
		
		procRsltTitle = "procT(ms),MIN_L,MAX_L"+procRsltTitle;
		procRsltData = imgProcTime+","+df.format(minL)+","+df.format(maxL)+procRsltData;
		setImgProcRsltData(imgFileName,procRsltTitle,procRsltData);
	}
	
	public void clearImgProcRsltData(String imgFileName){
		imgProcResultStr.remove(imgFileName);
	}
	
	private void setImgProcRsltData(String imgFileName, String rsltTitle, String rsltData){
		imgProcResultStr.put(imgFileName, rsltTitle+"\r\n"+rsltData);
	}
	
	public String[] getImgProcRsltData(String imgFileName){
		String[] rsltStr = new String[]{"",""};
		String rslt = imgProcResultStr.get(imgFileName);
		if(null!=rslt) rsltStr = rslt.split("\r\n");
		return rsltStr;
	}
	
	private ArrayList<Object> getLinesTendencyParas(ArrayList<ImgExtractLine> extractLines, LinkedHashMap<Integer,ImgExtractLine> linesMap, int targetLinesQty){
		ArrayList<Object> tdcParas = new ArrayList<Object>();
		double[] coef = null, slope = null, offset = null;
		int reliableMaxIdx = 0, evenPoleCnt = 0, oddPoleCnt = 0;
		double evenPoleAvgOffset = 0.0, oddPoleAvgOffset = 0.0, finalRsq = 0.0;
		double evenMinOffset = 0.0, evenMaxOffset = 0.0, oddMinOffset = 0.0, oddMaxOffset = 0.0, curOffset = 0.0;
		
		LinkedHashMap<Double,Double> tendencyDt = new LinkedHashMap<Double,Double>();
		ArrayList<Double> tdcSlope = new ArrayList<Double>();
		ArrayList<Double> tdcOffset = new ArrayList<Double>();
		ArrayList<Double> tdcRsq = new ArrayList<Double>();
		
		if(null!=extractLines && extractLines.size()>0){
			if(null==linesMap){
				linesMap = new LinkedHashMap<Integer,ImgExtractLine>();
			}else if(!linesMap.isEmpty()){
				linesMap.clear();
			}
			
			for(int i=0; i<extractLines.size(); i++){
				if(i<targetLinesQty){
					linesMap.put(i, extractLines.get(i));
					tendencyDt.put((double)i, extractLines.get(i).getLineIntercept());
					if(i<2){
						tdcSlope.add(i,0.0);
						tdcOffset.add(i,0.0);
						tdcRsq.add(i,1.0);
						reliableMaxIdx = i;
					}else{
						coef = MathUtils.lineFitting(tendencyDt);
						tdcSlope.add(i,coef[0]);
						tdcOffset.add(i,coef[1]);
						tdcRsq.add(i,coef[2]);
						if(coef[2]>minBestRsq){
							reliableMaxIdx = i;
							finalRsq = coef[2];
						}
					}
				}else{
					break;
				}
			}
			
			//Recalculate the tendency
			if(reliableMaxIdx>5 && tdcRsq.get(reliableMaxIdx) < minBestRsq){
				LinkedHashMap<Double,Double> fittingDt = new LinkedHashMap<Double,Double>();
				for(int i=1; i<=reliableMaxIdx; i++){
					fittingDt.put((double)i, extractLines.get(i).getLineIntercept());
				}
				coef = MathUtils.lineFitting(fittingDt);
				finalRsq = coef[2];
			}
			
			//Calculate average offset of even & odd pole to its previous most-closed pole
			evenPoleAvgOffset=0.0; oddPoleAvgOffset=0.0;
			for(int i=1; i<=reliableMaxIdx; i++){
				curOffset = linesMap.get(i).getLineIntercept() - linesMap.get(i-1).getLineIntercept();
				if(0==i%2){
					evenPoleCnt++;
					evenPoleAvgOffset += curOffset;
					if(1==evenPoleCnt){
						evenMinOffset = curOffset; evenMaxOffset = curOffset;
					}else{
						if(evenMinOffset>curOffset) evenMinOffset = curOffset;
						if(evenMaxOffset<curOffset) evenMaxOffset = curOffset;
					}
				}else{
					oddPoleCnt++;
					oddPoleAvgOffset += curOffset;
					if(1==oddPoleCnt){
						oddMinOffset = curOffset; oddMaxOffset = curOffset;
					}else{
						if(oddMinOffset>curOffset) oddMinOffset = curOffset;
						if(oddMaxOffset<curOffset) oddMaxOffset = curOffset;
					}
				}
			}
			evenPoleAvgOffset = (evenPoleCnt>2)?(evenPoleAvgOffset-evenMinOffset-evenMaxOffset) / (evenPoleCnt-2):evenPoleAvgOffset / evenPoleCnt;
			oddPoleAvgOffset = (oddPoleCnt>2)?(oddPoleAvgOffset-oddMinOffset-oddMaxOffset) / (oddPoleCnt-2):oddPoleAvgOffset / oddPoleCnt;
		}
		
		tdcParas.add(0,finalRsq);
		tdcParas.add(1,evenPoleAvgOffset);
		tdcParas.add(2,oddPoleAvgOffset);
		tdcParas.add(3,reliableMaxIdx);
		if(tdcSlope.size()>0){
			slope = new double[tdcSlope.size()];
			offset = new double[tdcOffset.size()];
			for(int i=0; i<tdcSlope.size(); i++){
				slope[i] = tdcSlope.get(i);
				offset[i] = tdcOffset.get(i);
			}
		}
		tdcParas.add(4,slope);
		tdcParas.add(5,offset);
		
		return tdcParas;
	}
	
	private boolean checkLines(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, ImgExtractLine myBaseline, ArrayList<ImgExtractLine> extractLines){
		boolean bPassed = false;
		int extLinesQty = 0, bestRsqIdx = 0;
		double oddPoleAvgOffset = 0.0, evenPoleAvgOffset = 0.0;
		double[] slope = null, offset = null;
		
		LinkedHashMap<Integer,ImgExtractLine> linesMap = new LinkedHashMap<Integer,ImgExtractLine>();
		ArrayList<Object> tdcParas = null;
		
		extLinesQty = extractLines.size();
		if(extLinesQty>3){
			tdcParas = getLinesTendencyParas(extractLines, linesMap, targetLinesQty);
			if((double)tdcParas.get(0)<minBestRsq){
				System.out.println("RSQ NG:"+(double)tdcParas.get(0)+"(<"+minBestRsq+")");
				return bPassed;
			}
			evenPoleAvgOffset = (double)tdcParas.get(1);
			oddPoleAvgOffset = (double)tdcParas.get(2);
			bestRsqIdx = (int)tdcParas.get(3);
			slope = (double[]) tdcParas.get(4);
			offset = (double[]) tdcParas.get(5);
			
			//Recalculate the missing lines
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,false);
			}
			
			//Double check all lines
			evenPoleIsLonger = evenLineIsLonger(linesMap,imgGrays);
			System.out.println("bestIdx/evenOffset/oddOffset:"+bestRsqIdx
					+"/"+evenPoleAvgOffset+"/"+oddPoleAvgOffset
					+"/"+((currToLastOffsetDeltaIsBigger(2,evenPoleIsLonger)?
							((evenPoleAvgOffset>oddPoleAvgOffset)?"Correct":"Wrong"):
							((evenPoleAvgOffset<oddPoleAvgOffset)?"Correct":"Wrong"))));
			
			//Check one more layer inside if the first layer is longer
			if(evenPoleIsLonger && !firstPoleIsLonger){
				targetLinesQty = targetLinesQty + 1;
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,true);
			}
			
			//Compensate the longer layers
			linesMap = adjustLongerLines(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty,true);
			
			//Adjust all layers' index
			linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,true);
				linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			}
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = addMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
				linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			}
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = addMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
			}
			
			//Set all lines sharp change position
			linesMap = adjustLongerLines(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty,true);
			setLinesSharpChgPosition(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty);
			
			//Calculate the final result
			twoNearLayersOffsetCorrect(linesMap,evenPoleIsLonger);
			setLongerPolesLength(linesMap,imgGrays,peakVals,evenPoleIsLonger,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
			bPassed = calculateFinalResult(linesMap,evenPoleIsLonger,imgGrays,defaultVal,targetLinesQty,peakVals,evenPoleAvgOffset,oddPoleAvgOffset);
		}else{
			System.out.println("Extract Lines Qty:"+extractLines.size()+" is NG");
		}
		
		saveImgData("graysFinalLines_",finalData);
		System.out.println("Proc Result:"+(bPassed?"OK":"NG"));
		return bPassed;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> adjustLongerLines(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, int targetLinesQty, boolean bNotSetInterceptDelta){
		double[] weightOfLine = null;
		for(int lineIdx=0; lineIdx<targetLinesQty; lineIdx++){
			ImgExtractLine exLine = oriLinesMap.get(lineIdx);
			if(null!=exLine && 0==exLine.getXAxisStart()){
				exLine = setLineBoundary(exLine, imgGrays, 255);
				oriLinesMap.put(lineIdx, exLine);
			}
			
			if(curLineIsLonger(lineIdx,evenLineLonger)){
				if(null!=exLine){
					weightOfLine = exLine.weightOfBeingLine(oriLinesMap, exLine.getXAxisStop(), exLine.getXAxisStart(), 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, bNotSetInterceptDelta, curLineIsLonger(lineIdx,evenLineLonger), false);
					oriLinesMap.put(lineIdx, exLine);
					if(weightOfLine[0]<0.5) System.out.println("Weight of line("+lineIdx+"):"+weightOfLine[0]);
				}
			}
		}
		
		return oriLinesMap;
	}
	
	private int[] getPolePosX(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger, int targetLinesQty){
		double xPositionSum1 = 0.0, xPositionSum2 = 0.0;
		int counter1 = 0, counter2 = 0;
		int[] polePosX = new int[]{-1,-1};
		ImgExtractLine exLine = null;
		for(int lineIdx=0; lineIdx<targetLinesQty; lineIdx++){
			exLine = linesMap.get(lineIdx);
			if(null==exLine) continue;
			if(curLineIsLonger(lineIdx,evenLineLonger)){
				xPositionSum1 += exLine.getXAxisStop();
				counter1++;
			}else{
				xPositionSum2 += exLine.getXAxisStart();
				counter2++;
			}
		}
		if(counter1>0) polePosX[0] = (int)(xPositionSum1/counter1);
		if(counter2>0) polePosX[1] = (int)(xPositionSum2/counter2);
		return polePosX;
	}
	
	private boolean twoNearLayersOffsetCorrect(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger){
		boolean correct = true;
		ImgExtractLine currLine = null, lastLine = null;
		double evenPoleOffsetSum = 0.0, oddPoleOffsetSum = 0.0, offsetDelta = 0.0;
		double evenPoleAvgOffset = 0.0, oddPoleAvgOffset = 0.0;
		int evenPoleCnt = 0, oddPoleCnt = 0;
		
		for(Integer idx:linesMap.keySet()){
			currLine = linesMap.get(idx);
			lastLine = linesMap.get(idx-1);
			
			if(null!=currLine && null!=lastLine){
				offsetDelta = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				offsetDelta = offsetDelta-lastLine.getLineIntercept()-lastLine.getLineInterceptDelta();
				if(0==idx%2){
					evenPoleOffsetSum += offsetDelta;
					evenPoleCnt++;
				}else{
					oddPoleOffsetSum += offsetDelta;
					oddPoleCnt++;
				}
			}
		}
		if(evenPoleCnt>0) evenPoleAvgOffset=evenPoleOffsetSum/evenPoleCnt;
		if(oddPoleCnt>0) oddPoleAvgOffset=oddPoleOffsetSum/oddPoleCnt;
		correct = ((currToLastOffsetDeltaIsBigger(2,evenLineLonger)?
				((evenPoleAvgOffset>oddPoleAvgOffset)?true:false):
				((evenPoleAvgOffset<oddPoleAvgOffset)?true:false)));
		
		System.out.println("evenPoleAvgOffset/oddPoleAvgOffset:"
				+"/"+evenPoleAvgOffset+"/"+oddPoleAvgOffset
				+"/"+(correct?"Correct":"Wrong"));
		
		return correct;
	}
	
	private void setLongerPolesLength(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty){
		//Check the logic carefully
		int imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		int[][] tmpGrays = new int[imgWidth][imgHeight];
		for(int k=0; k<imgWidth; k++){
			tmpGrays[k] = imgGrays[k].clone();
		}
		double tmpSlope = 0.0, tmpOffset = 0.0, poleLength = 0.0;
		double oriSlope = tmpSlope, oriOffset = tmpOffset;
		double maxDnChkOffset = 0.0;
		boolean curLinePassed = false;
		int newXAxisStop = -1, wrinkleLineMaxOffset = 0;
		ImgExtractLine tmpLine = null, exLine = null;
		int[] polePosX = getPolePosX(linesMap,evenLineLonger,targetLinesQty);
		if(polePosX[0]<0 || polePosX[1]<0) return;
		
		int refPos = 0, minIdx = -1, oriCol = 0;
		int stopChkPos = 0, nearCol = 0, defaultVal = 255, lineFlag = 0;
		
		double maxPoleAngle = Double.parseDouble(""+criteria.get("maxPoleAngle"));
		double onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		double minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		double maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		
		for(int i=0; i<targetLinesQty; i++){
			if(i>=linesMap.size() || i>=10) break;
			if(!curLineIsLonger(i,evenLineLonger)) continue;
			exLine = linesMap.get(i);
			if(null==exLine || null==linesMap.get(i+1) || null==linesMap.get(i-1)) continue;
			if(i>0 && linesMap.get(i-1).getXAxisStart()-exLine.getXAxisStop()<minDistance) continue;
			if(i+1<linesMap.size() && linesMap.get(i+1).getXAxisStart()-exLine.getXAxisStop()<minDistance) continue;
			refPos = exLine.getXAxisStop();
			if(refPos-polePosX[0]<5) continue;
			
			curLinePassed = false;
			lineFlag = exLine.getLineFlag();
			tmpSlope = exLine.getLineSlope();
			tmpOffset = exLine.getLineIntercept();
			oriSlope = tmpSlope; oriOffset = tmpOffset;
			wrinkleLineMaxOffset = (int)(evenPoleAvgOffset+oddPoleAvgOffset)/2;
			maxDnChkOffset = (evenPoleAvgOffset+oddPoleAvgOffset)/2;
			
			tmpLine = exLine;
			if(null!=linesMap.get(i+2)){
				maxDnChkOffset = linesMap.get(i+2).getLineIntercept()+linesMap.get(i+2).getLineInterceptDelta();
				maxDnChkOffset = maxDnChkOffset - tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
			}else{
				maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i+1).getLineIntercept()-linesMap.get(i+1).getLineInterceptDelta();
				maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
			}
			
			minIdx = -1;
			stopChkPos = refPos - (int)maxDistance;
			if(stopChkPos<0) stopChkPos = 0;
			
			//Check down side
			LinkedHashMap<Double,Double> dnSideWrinkleLine = new LinkedHashMap<Double,Double>();
			dnSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,refPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
			
			double[] dnLineParas = null;
			double dnSideAngle = 0.0;
			if(dnSideWrinkleLine.size()>=5){
				dnLineParas = MathUtils.lineFitting(dnSideWrinkleLine);
				dnSideAngle = 90.0;
				if(-1!=tmpSlope*dnLineParas[0]){
					dnSideAngle = Math.abs((tmpSlope-dnLineParas[0])/(1+tmpSlope*dnLineParas[0]));
					dnSideAngle = Math.toDegrees(Math.atan(dnSideAngle));
				}
			}else{
				continue;
			}
			
			if(dnSideAngle>0){
				if(dnSideAngle<=maxPoleAngle){
					storeLayerAngle(evenLineLonger, i, dnSideAngle, 0);
					minIdx = imgWidth;
					for(double k:dnSideWrinkleLine.keySet()){
						if(k<minIdx) minIdx=(int)k;
					}
					newXAxisStop = minIdx;
					for(int k=refPos; k>=minIdx; k--){
						nearCol = (int)(k*tmpSlope+tmpOffset);
						for(int n=(int)maxDnChkOffset;n>0;n--){
							if(nearCol+n>=0 && nearCol+n<imgHeight){
								if(imgGrays[k][nearCol+n]<defaultVal){
									if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
										tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
									}
								}
							}
						}
					}
				}else{
					newXAxisStop = (int)((tmpOffset-dnLineParas[1])/(dnLineParas[0]-tmpSlope));
				}
			}
			
			if(newXAxisStop>=0){
				tmpLine.setXAxisStop(newXAxisStop);
				if(tmpLine.getXAxisStart()<newXAxisStop) tmpLine.setXAxisStart(newXAxisStop);
				tmpLine.setPolePosition(newXAxisStop);
				if(curLineIsLonger(i,evenLineLonger)){
					linesMap.put(i, tmpLine);
				}else{
					linesMap.put(i-1, tmpLine);
				}
				
				poleLength = linesMap.get(i-1).getXAxisStart()-tmpLine.getXAxisStop();
				if(poleLength>=minDistance && poleLength<=maxDistance) curLinePassed = true;
				
				if(!curLinePassed){
					lineFlag = 4;
				}else{
					lineFlag = lineIndexBase + i;
				}
				if(null!=dnLineParas && dnSideAngle<=maxPoleAngle){
					tmpSlope = dnLineParas[0];
					tmpOffset = dnLineParas[1];
					tmpLine.setCrossX(refPos);
					for(int k=newXAxisStop; k<=refPos; k++){
						nearCol = (int)(k*tmpSlope+tmpOffset);
						oriCol = (int)(k*oriSlope+oriOffset);
						if(nearCol<oriCol) nearCol = oriCol;
						if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
					}
				}
			}
		}
	}
	
	private boolean curLineIsLonger(int lineIdx, boolean evenLineLonger){
		boolean curLineLonger = false;
		if(0==lineIdx%2 && evenLineLonger || 1==lineIdx%2 && !evenLineLonger) curLineLonger = true;
		return curLineLonger;
	}
	
	private boolean currToLastOffsetDeltaIsBigger(int lineIdx, boolean evenLineLonger){
		boolean bigger = false;
		
		if(0==lineIdx%2 && firstPoleIsThicker || 1==lineIdx%2 && !firstPoleIsThicker){
			if(firstPoleIsLonger && evenLineLonger 
				|| !firstPoleIsLonger && !evenLineLonger) bigger=true;
		}
		
		return bigger;
	}
	
	private int[] getWeightChkRange(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap,LinkedHashMap<Integer, ImgExtractLine> newLinesMap,int oriLineIdx,int newLineIdx){
		int[] chkRange = new int[2];
		//Get the max range(Max start and Min stop) of the near three lines
		ImgExtractLine curLine = oriLinesMap.get(oriLineIdx);
		ImgExtractLine lastLine = newLinesMap.get(newLineIdx-1);
		ImgExtractLine nextLine = oriLinesMap.get(oriLineIdx+1);
		
		chkRange[0] = curLine.getXAxisStart();
		chkRange[1] = curLine.getXAxisStop();
		if(null!=lastLine){
			if(lastLine.getXAxisStart()>chkRange[0]) chkRange[0] = lastLine.getXAxisStart();
			if(lastLine.getXAxisStop()<chkRange[1]) chkRange[1] = lastLine.getXAxisStop();
		}
		if(null!=nextLine){
			if(nextLine.getXAxisStart()>chkRange[0]) chkRange[0] = nextLine.getXAxisStart();
			if(nextLine.getXAxisStop()<chkRange[1]) chkRange[1] = nextLine.getXAxisStop();
		}
		
		return chkRange;
	}
	
	private int[] shiftLineIndex(int[] oriLineIdx,int startIdx,int stopIdx,int shiftVal){
		int start = 0, stop = 0, baseVal = 0;
		if(startIdx<0) startIdx = 0;
		if(startIdx>=oriLineIdx.length) startIdx = oriLineIdx.length - 1;
		if(stopIdx<0) stopIdx = 0;
		if(stopIdx>=oriLineIdx.length) stopIdx = oriLineIdx.length - 1;
		
		if(startIdx>stopIdx){
			start = stopIdx;
			stop = startIdx;
		}else{
			start = startIdx;
			stop = stopIdx;
		}
		
		if(shiftVal<0){
			for(int k=start;k<=stop;k++){
				oriLineIdx[k] = oriLineIdx[k] + shiftVal;
			}
		}else{
			baseVal = oriLineIdx[start];
			for(int k=start;k<=stop;k++){
				baseVal = baseVal + shiftVal;
				if(oriLineIdx[k]<baseVal) oriLineIdx[k] = oriLineIdx[k] + shiftVal;
			}
		}
		
		return oriLineIdx;
	}
	
	private int shiftCurrentLineNext(ImgExtractLine currLine, ImgExtractLine lastLine, ImgExtractLine nextLine, int currLineIdx, int targetLinesQty, 
										double[] weightCurLine, double[] weightLastLine, double[] weightNextLine, boolean curLineIsLonger, int[][] imgGrays,
										LinkedHashMap<Integer, ImgExtractLine> linesMap, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean curLineIsThicker = false, curLineOffsetIsOK = false, curLineLengthIsOK = false, overhangFailed = false;
		boolean lastLineLengthIsOK = false, nextLineLengthIsOK = false;
		double curLineOffset = 0.0, lastLineOffset = 0.0, nextLineOffset = 0.0;
		double offsetChgR0 = 0.0, offsetChgR1 = 0.0, weightDiff = 0.0;
		int maxValidPtsLineIdxDelta = 0, shiftFlag = 0, peakFlag = 0;
		
		shiftFlag = 0;//Default is no need to shift current line
		curLineOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
		if(null!=lastLine){
			lastLineOffset = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
		}else{
			return shiftFlag;
		}
		
		if(1==currLineIdx%2){
			offsetChgR0 = (curLineOffset - lastLineOffset) / oddPoleAvgOffset;
		}else{
			offsetChgR0 = (curLineOffset - lastLineOffset) / evenPoleAvgOffset;
		}
		
		if(null!=nextLine){
			nextLineOffset = nextLine.getLineIntercept()+nextLine.getLineInterceptDelta();
			if(0==(currLineIdx+1)%2){
				offsetChgR1 = (nextLineOffset - curLineOffset) / evenPoleAvgOffset;
			}else{
				offsetChgR1 = (nextLineOffset - curLineOffset) / oddPoleAvgOffset;
			}
		}
		
		curLineLengthIsOK = (curLineIsLonger && weightCurLine[0]>=0.5 || !curLineIsLonger && weightCurLine[0]<0.5);
		curLineOffsetIsOK = (offsetChgR0>minOffsetChgRate && offsetChgR0<maxOffsetChgRate);
		
		lastLineLengthIsOK = (curLineIsLonger && weightLastLine[0]<0.5 || !curLineIsLonger && weightLastLine[0]>=0.5);
		if(null!=nextLine){
			nextLineLengthIsOK = (curLineIsLonger && weightNextLine[0]<0.5 || !curLineIsLonger && weightNextLine[0]>=0.5);
			weightDiff = Math.abs(weightCurLine[0]-weightNextLine[0]);
		}
		
		//Pre-screen conditions
		if(curLineLengthIsOK && lastLineLengthIsOK && nextLineLengthIsOK) return shiftFlag;
		
		if(curLineLengthIsOK && curLineOffsetIsOK){
			if(null!=nextLine && currLineIdx==targetLinesQty-2){
				if(offsetChgR0>maxOffsetChgRate*0.8 || offsetChgR1>maxOffsetChgRate || offsetChgR1<minOffsetChgRate){
					peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
					if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
					if(0==peakFlag){
						shiftFlag = 1;//Current line shift next
					}else if(!curLineIsLonger && weightNextLine[0]>weightCurLine[0] && weightDiff>0.2){
						//Suppose current line is correct
					}else if(offsetChgR0>maxOffsetChgRate*0.8){
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
						if(overhangFailed && weightDiff>0.2){
							maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
									-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
							if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
						}
					}
				}
			}
		}else{
			if(curLineLengthIsOK && offsetChgR0<=minOffsetChgRate){
				return shiftFlag;
			}else if(curLineLengthIsOK && offsetChgR0>=maxOffsetChgRate || !curLineLengthIsOK && curLineOffsetIsOK){//Possibly need to shift next
				if(currLineIdx!=targetLinesQty-2){
					if(thereIsPoleBtw(imgGrays,currLine,lastLine,true)){
						shiftFlag = 1;//Current line shift next
					}else{
						return shiftFlag;
					}
				}else{
					curLineIsThicker = lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0);
					if(firstPoleIsThicker && curLineIsThicker) return shiftFlag;
					
					if(null!=nextLine){
						if(curLineOffsetIsOK && lastLineLengthIsOK && nextLineLengthIsOK && offsetChgR1>minOffsetChgRate && offsetChgR1<maxOffsetChgRate
							&& !curLineIsLonger && weightNextLine[0]-weightCurLine[0]>0.2){
							//Suppose current line is correct
						}else{
							overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
							if(overhangFailed){
								peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
								if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
								if(offsetChgR1>maxOffsetChgRate || offsetChgR1<minOffsetChgRate){//Next line is out of expectation
									if(0==peakFlag){
										shiftFlag = 1;//Current line shift next
									}else{
										if(!curLineLengthIsOK){
											if(weightDiff>0.2) shiftFlag = 1;//Current line shift next(Give it a try)
										}
									}
								}else{
									if(curLineLengthIsOK){
										if(0==peakFlag) shiftFlag = 1;//Current line shift next
									}else{
										if(weightDiff>0.2) shiftFlag = 1;//Current line shift next(Give it a try)
									}
								}
							}else{
								if(!curLineLengthIsOK){
									if(offsetChgR0>maxOffsetChgRate*0.72){
										if(weightDiff>0.2){
											shiftFlag = 1;//Current line shift next(Give it a try)
										}else{
											maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
													-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
											if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
										}
									}
								}
							}
						}
					}else{
						maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
								-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx-1,lastLine,currLine,weightLastLine[0],weightCurLine[0]);
						if(0==maxValidPtsLineIdxDelta && overhangFailed){//There is no potential line after current line and overhang is NG btw current line and last line
							shiftFlag = 1;//Current line shift next(Give it a try)
						}
					}
				}
			}else if(!curLineLengthIsOK && offsetChgR0<=minOffsetChgRate){//Current line is too closed to last line, should be skipped
				shiftFlag = -1;//Skip current line
			}else if(!curLineLengthIsOK && offsetChgR0>=maxOffsetChgRate){//Possibly need to shift next
				if(currLineIdx==targetLinesQty-2){
					curLineIsThicker = lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0);
					if(firstPoleIsThicker && curLineIsThicker) return shiftFlag;
					
					peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
					if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
					if(0==peakFlag){
						shiftFlag = 1;//Current line shift next
					}else if(offsetChgR0>maxOffsetChgRate*0.8 && null!=nextLine){
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
						if(overhangFailed && weightDiff>0.2){
							if(offsetChgR0>maxOffsetChgRate && weightDiff>0.5){
								shiftFlag = 1;
							}else{
								maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
										-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
								if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
							}
						}
					}
				}
			}
		}
		
		return shiftFlag;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> doubleCheckAllLinesNew(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap, int[][] peakVals, int[][] initVals, int[][] imgGrays, boolean evenLineLonger, int targetLinesQty, double evenPoleAvgOffset, double oddPoleAvgOffset, double linesTendency_Slope, double linesTendency_Offset){
		LinkedHashMap<Integer, ImgExtractLine> linesMap = new LinkedHashMap<Integer, ImgExtractLine>();
		LinkedHashMap<Integer, ImgExtractLine> newLinesMap = new LinkedHashMap<Integer, ImgExtractLine>();
		ImgExtractLine currLine = null, nextLine = null, lastLine = null;
		
		for(int i=0; i<targetLinesQty; i++){
			if(null!=oriLinesMap.get(i)) linesMap.put(i, oriLinesMap.get(i));
		}
		int[] newLineIdx = new int[linesMap.size()];
		int[] oriLineIdx = new int[linesMap.size()];
		
		int idx = -1, lineIdx = -1, shiftFlag = 0, maxValidPtsLineIdxDelta = 0;
		int[] weightChkRange = null;
		boolean curLineIsLonger = false, curLineIsConfirmed = false, overhangFailed = false;
		boolean curLineLengthIsOK = false, curLineOffsetIsOK = false;
		boolean lastLineLengthIsOK = false, nextLineLengthIsOK = false;
		double[] weightCurLine = null, weightLastLine = null, weightNextLine = null, weight3 = null;
		double offsetChgR0 = 0.0, offsetChgR1 = 0.0, offsetChgR2 = 0.0;
		double nextLineOffset = 0.0, lastLineOffset = 0.0, curLineOffset = 0.0;
		
		for(int key:linesMap.keySet()){
			idx++;
			newLineIdx[idx] = key;//The final line index(will be adjusted in this routine)
			oriLineIdx[idx] = key;//The 1st guessing line index
		}
		
		for(int i=0; i<=idx; i++){
			if(newLineIdx[i]>=targetLinesQty) break;
			offsetChgR0 = 0.0; offsetChgR1 = 0.0; offsetChgR2 = 0.0;
			weightLastLine = null; weightNextLine = null;
			lastLineLengthIsOK = false; nextLineLengthIsOK = false;
			lineIdx = oriLineIdx[i];
			currLine = linesMap.get(lineIdx);//The line to be checked
			lastLine = newLinesMap.get(newLineIdx[i]-1);
			nextLine = linesMap.get(lineIdx+1);
			if(null!=currLine){
				if(currLine.getLineChecked()){
					newLinesMap.put(newLineIdx[i], currLine);
					continue;
				}
				curLineIsLonger = curLineIsLonger(newLineIdx[i],evenLineLonger);
				curLineOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				if(null!=lastLine){
					lastLineOffset = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
				}else{
					lastLineOffset = linesTendency_Slope*(newLineIdx[i]-1)+linesTendency_Offset;
				}
				if(1==newLineIdx[i]%2){
					offsetChgR0 = (curLineOffset - lastLineOffset) / oddPoleAvgOffset;
				}else{
					offsetChgR0 = (curLineOffset - lastLineOffset) / evenPoleAvgOffset;
				}
				if(offsetChgR0<0) continue;
				
				if(null!=nextLine){
					nextLineOffset = nextLine.getLineIntercept()+nextLine.getLineInterceptDelta();
					if(0==(newLineIdx[i]+1)%2){
						offsetChgR1 = (nextLineOffset - curLineOffset) / evenPoleAvgOffset;
						offsetChgR2 = (nextLineOffset - lastLineOffset) / evenPoleAvgOffset;
					}else{
						offsetChgR1 = (nextLineOffset - curLineOffset) / oddPoleAvgOffset;
						offsetChgR2 = (nextLineOffset - lastLineOffset) / oddPoleAvgOffset;
					}
				}
				
				if(12==lineIdx){
					System.out.print("");
				}
				
				weightChkRange = getWeightChkRange(linesMap,newLinesMap,lineIdx,newLineIdx[i]);
				weightCurLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, true, curLineIsLonger(newLineIdx[i],evenLineLonger), false);
				if(null!=lastLine){
					weightLastLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, newLineIdx[i]-1, targetLinesQty, true, curLineIsLonger(newLineIdx[i]-1,evenLineLonger), false);
					lastLineLengthIsOK = (curLineIsLonger && weightLastLine[0]<0.5 || !curLineIsLonger && weightLastLine[0]>=0.5);
				}
				if(null!=nextLine){
					weightNextLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx+1, targetLinesQty, true, curLineIsLonger(newLineIdx[i]+1,evenLineLonger), false);
					nextLineLengthIsOK = (curLineIsLonger && weightNextLine[0]<0.5 || !curLineIsLonger && weightNextLine[0]>=0.5);
				}
				
				curLineLengthIsOK = (curLineIsLonger && weightCurLine[0]>=0.5 || !curLineIsLonger && weightCurLine[0]<0.5);
				curLineOffsetIsOK = (offsetChgR0>minOffsetChgRate && offsetChgR0<maxOffsetChgRate);
				
				curLineIsConfirmed = false;
				//1.Expected case handling - Length of current pole is in expectation
				if(curLineLengthIsOK){
					//Offset variation of the most inner two poles could be bigger
					if(newLineIdx[i]==targetLinesQty-2){
						if(null!=nextLine){
							if(nextLine.getLineChecked()){//The most inner pole has confirmed
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
						//Length of current,left and right poles is in expectation
						if(!curLineIsConfirmed && lastLineLengthIsOK && nextLineLengthIsOK
							&& offsetChgR0>minOffsetChgRate*0.75){ //Pole offset meets the lower limit
							currLine.setLineChecked(true);
							newLinesMap.put(newLineIdx[i], currLine);
							curLineIsConfirmed = true;
						}
						//Offset of current pole is in control limit
						if(!curLineIsConfirmed){
							shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
									weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
									newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
							if(0<=shiftFlag){
								//Shift current line to next line
								if(1==shiftFlag) newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}else if(null!=lastLine && offsetChgR0>minOffsetChgRate*0.75 //Lower offset control limit could be loser while pole length is in expectation
						&& offsetChgR0<=maxOffsetChgRate //Pole offset is in control limit
						|| 0==newLineIdx[i] //Current line represents the most outer pole(the 1st pole)
						|| null!=lastLine && 1==currLine.getLineFlag() //Last line is fixed and current line is in the expected tendency
						|| null!=lastLine && curLineOffsetIsOK //Pole offset is in control limit
							//Current pole is the most inner pole and last pole is fixed
							&& newLineIdx[i]==targetLinesQty-1){
						//Key conditions:
						//(1)Last pole is fixed and offset of current pole is in ctrl limit
						//(2)Last pole is fixed and current pole is in ctrl tendency
						currLine.setLineChecked(true);
						newLinesMap.put(newLineIdx[i], currLine);
						curLineIsConfirmed = true;
					}
				}else if(0==newLineIdx[i] //Current line represents the most outer pole(the 1st pole)
					&& (offsetChgR0<=maxOffsetChgRate //Pole offset is in control criteria
						|| curLineIsLonger && weightCurLine[0]<0.5 //Length of current pole and next pole is very closed
						//Length of the most outer pole is not expected, which is usually caused by a longer
						//pole clings to the most outer short pole which leads to failed detection of short pole
						|| !curLineIsLonger && weightCurLine[0]>=0.5)){
					currLine.setLineChecked(true);
					newLinesMap.put(newLineIdx[i], currLine);
					curLineIsConfirmed = true;
				}else if(evenLineLonger && 1==newLineIdx[i]
					&& weightCurLine[0]>=0.5
					&& offsetChgR0>minOffsetChgRate*0.6){
					currLine.setLineChecked(true);
					newLinesMap.put(newLineIdx[i], currLine);
					curLineIsConfirmed = true;
				}
				
				//2.Common case handling
				if(!curLineIsConfirmed){//Length of current pole is out of expectation
					//2-1.Try to fix last pole first
					if(null==lastLine){ //Last pole is missing
						if(offsetChgR0<minOffsetChgRate //Current pole is too closed to last pole
							//Length of current pole is not expected
							|| offsetChgR0<maxOffsetChgRate*0.85 && !curLineLengthIsOK
							//Current line represents negative pole and last pole is negative pole
							|| offsetChgR0<maxOffsetChgRate*0.85 
								&& lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0) //Current line represents negative pole
								&& lineIsNegPole(newLineIdx[i]-1,evenLineLonger,evenPoleAvgOffset,oddPoleAvgOffset) //Last pole is negative pole
							//Current line represents the most inner pole and last pole is negative pole
							|| offsetChgR0<maxOffsetChgRate*0.75 && newLineIdx[i]==targetLinesQty-1 
								&& lineIsNegPole(newLineIdx[i]-1,evenLineLonger,evenPoleAvgOffset,oddPoleAvgOffset) //Last pole is negative pole
							//Current line represents the most inner pole and length of current pole is not expected
							|| offsetChgR0<maxOffsetChgRate*1.5 && newLineIdx[i]==targetLinesQty-1 
								&& (curLineIsLonger && weightCurLine[0]<0.45 //Length of current pole is not expected
									|| !curLineIsLonger && weightCurLine[0]>=0.5)){
							if(!lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0)
								&& newLineIdx[i]==targetLinesQty-1
								&& curLineIsLonger && weightCurLine[0]>0.5){
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}else{
								//Shift current line to previous line
								newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,-1);
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}else if((offsetChgR0>maxOffsetChgRate || newLineIdx[i]==targetLinesQty-1)//Offset of current pole is bigger or current pole is the most inner pole
							&& (curLineIsLonger && weightCurLine[0]>0.45 //Length of current pole is in expectation
								|| !curLineIsLonger && weightCurLine[0]<0.5)){
								//Offset of current pole exceeds upper limit but length of it is in expectation
								if(newLineIdx[i]==targetLinesQty-1 && curLineIsLonger
									&& weightCurLine[0]>=0.5 && lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0)){
									//Shift current line to previous line
									newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,-1);
								}
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
						}
					}
					//2-2.Refer to next line first since last line is supposed correct
					if(!curLineIsConfirmed && null!=nextLine){
						if(nextLineLengthIsOK){//Length of next pole is in expectation
							if(curLineLengthIsOK && nextLineLengthIsOK){
								//Offset of both current and next poles is on target
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}else{//Length of next pole is out of expectation
							if(offsetChgR1<minOffsetChgRate && offsetChgR2<maxOffsetChgRate){//Next pole is too closed to current pole
								if(newLineIdx[i]==targetLinesQty-2 && nextLine.getLineChecked()){
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}else{
									//Shift next line to current line
									newLineIdx=shiftLineIndex(newLineIdx,i+1,linesMap.size()-1,-1);
									nextLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], nextLine);//Shift next line to current line
								}
								curLineIsConfirmed = true;
							}else if((offsetChgR0>maxOffsetChgRate*0.85 || newLineIdx[i]==targetLinesQty-2 && offsetChgR0>minOffsetChgRate*0.6)//Offset of current pole is in expectation
									//Current pole is longer(expect shorter) than next pole
									&& !curLineIsLonger && weightCurLine[0]-weightNextLine[0]>0.15
							){
								//TODO Verification
								shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
										weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
										newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
								if(0<=shiftFlag){
									//Shift current line to next line
									if(1==shiftFlag) newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
								}
								curLineIsConfirmed = true;
							}else if(offsetChgR0>maxOffsetChgRate){
								maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
										-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
								overhangFailed = twoNearLinesOverhangFailed(newLineIdx[i],currLine,nextLine,weightCurLine[0],weightNextLine[0]);
								if(0==maxValidPtsLineIdxDelta || overhangFailed){
									//Shift current line to next line
									newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
								}
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}else if(offsetChgR0>minOffsetChgRate*0.6 && offsetChgR1<maxOffsetChgRate
								&& 1==currLine.getLineFlag()){
								//Offset of next pole is in expectation
								//Offset of current pole meets the lower limit and it is in expecting tendency
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}
					//2-3.Refer to last line
					if(!curLineIsConfirmed && null!=lastLine){
						if(lastLineLengthIsOK){//Length of last pole is in expectation
							if(newLineIdx[i]==targetLinesQty-2){
								if(offsetChgR0>minOffsetChgRate*0.5){
									shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
											weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
											newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
									if(1==shiftFlag){
										//Shift current line to next line
										newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
									}
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}
							}else if(newLineIdx[i]==targetLinesQty-1 && curLineIsLonger){
								if(weightCurLine[0]>0.5 && currLine.getTendencyRSQ()>minBestRsq){
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}else{
									//Enlarge inner side searching range
									double researchOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta()+3;
									double researchOffsetStop = researchOffset + (evenPoleAvgOffset+oddPoleAvgOffset)/2*3;
									double researchSlope = currLine.getLineSlope();
									ImgExtractLine exLine = null;
									exLine = searchLine(peakVals, initVals, imgGrays, 255, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
									if(null!=exLine){
										linesMap.put(lineIdx+1, exLine);
										weight3 = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx+1, targetLinesQty, true, curLineIsLonger(newLineIdx[i],evenLineLonger), false);
										if(weight3[0]>0.5 && weight3[0]>weightCurLine[0]
											|| weight3[0]>weightCurLine[0] && currLine.getTendencyRSQ()<minBestRsq){
											exLine.setLineChecked(true);
											newLinesMap.put(newLineIdx[i], exLine);
											curLineIsConfirmed = true;
										}
									}
									if(!curLineIsConfirmed){
										currLine.setLineChecked(true);
										newLinesMap.put(newLineIdx[i], currLine);
										curLineIsConfirmed = true;
									}
								}
							}
							
							//Offset of current pole is in a more expecting range
							if(!curLineIsConfirmed && offsetChgR0>minOffsetChgRate*1.1 && offsetChgR0<maxOffsetChgRate){
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}
				}
				
				//3.Abnormal case handling
				if(!curLineIsConfirmed){
					if(null!=lastLine && null!=nextLine){
						//Length of last and next poles is in expectation
						//Offset of last and next poles exceed the upper limit(they are far way from current pole)
						//Length of current pole is out of expectation
						if(offsetChgR0>maxOffsetChgRate && offsetChgR0<maxOffsetChgRate*1.5
							&& offsetChgR1>maxOffsetChgRate && offsetChgR1<maxOffsetChgRate*1.5
							&& (curLineIsLonger && weightCurLine[0]<0.5 
									&& weightLastLine[0]<0.5 && weightNextLine[0]<0.5
								|| !curLineIsLonger && weightCurLine[0]>=0.5
									&& weightLastLine[0]>=0.5 && weightNextLine[0]>=0.5)){
							//Shift current line to next line
							newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
							currLine.setLineChecked(true);
							newLinesMap.put(newLineIdx[i], currLine);
							curLineIsConfirmed = true;
						}
					}
				}
			}
		}
		
		return newLinesMap;
	}
	
	private LinkedHashMap<Double,Double> getWrinklePtsEx(ImgExtractLine curLine, int[][] peakVals, int wrinkleStartChkPos, int wrinkleStopChkPos, int wrinkleLineMaxOffset, int maxChkOffset, boolean chkDownSide){
		LinkedHashMap<Double,Double> wrinklePts = new LinkedHashMap<Double,Double>();
		double tmpSlope = curLine.getLineSlope();
		double tmpOffset = curLine.getLineIntercept()+curLine.getLineInterceptDelta();
		int y = 0, nearCol = 0, imgHeight = peakVals[0].length;
		int minX = wrinkleStartChkPos, startY = (int)(wrinkleStartChkPos*tmpSlope+tmpOffset);
		
		boolean bFound = false;
		String[] pt = null;
		int xDelta = 0, yDelta = 0;
		ArrayList<ArrayList<String>> wrinkleLines = new ArrayList<ArrayList<String>>();
		ArrayList<String> pts = new ArrayList<String>();
		for(int x=wrinkleStartChkPos; x>wrinkleStopChkPos; x--){
			nearCol = (int)(x*tmpSlope+tmpOffset);
			for(int n=0; n<=(int)maxChkOffset; n++){
				if(chkDownSide){
					y = nearCol + n;
				}else{
					y = nearCol - n;
				}
				if(y>=0 && y<imgHeight && peakVals[x][y]>0 && peakVals[x][y]<noiseGrayThr){
					if(minX>x) minX = x;
					if(wrinkleLines.isEmpty()){
						pts.add(x+","+y);
						wrinkleLines.add(pts);
					}else{
						bFound = false;
						for(int i=0; i<wrinkleLines.size(); i++){
							pts = wrinkleLines.get(i);
							pt = pts.get(pts.size()-1).split(",");
							xDelta = Integer.parseInt(pt[0]) - x;
							yDelta = y - Integer.parseInt(pt[1]);
							if(Math.abs(yDelta)<lineScanRange/2 && xDelta<lineScanRange){
								bFound = true;
								pts.add(x+","+y);
								wrinkleLines.remove(i);
								wrinkleLines.add(i, pts);
							}
						}
						if(!bFound){
							pts = new ArrayList<String>();
							pts.add(x+","+y);
							wrinkleLines.add(pts);
						}
					}
				}
			}
		}
		
		double onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		double minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		
		double[] coef = null;
		double tmpAngle = 0.0, crossX = 0.0, maxAngle = -1, delta = 0.0;
		int maxAngleIdx = -1, maxSizeIdx = -1, maxSize = -1;
		ArrayList<LinkedHashMap<Double,Double>> tmpLines = new ArrayList<LinkedHashMap<Double,Double>>();
		if(wrinkleLines.size()>0){
			for(int i=0; i<wrinkleLines.size(); i++){
				pts = wrinkleLines.get(i);
				if(pts.size()>=5){
					LinkedHashMap<Double,Double> tmpLine = new LinkedHashMap<Double,Double>();
					for(int j=0; j<pts.size(); j++){
						pt = pts.get(j).split(",");
						tmpLine.put(Double.parseDouble(pt[0]), Double.parseDouble(pt[1]));
					}
					tmpLines.add(tmpLine);
					if(maxSize<0){
						maxSize = tmpLine.size();
						maxSizeIdx = 0;
					}else if(maxSize<tmpLine.size()){
						maxSize = tmpLine.size();
						maxSizeIdx = tmpLines.size()-1;
					}
					
					yDelta = 0; xDelta = 0;
					pt = pts.get(0).split(",");
					xDelta = wrinkleStartChkPos - Integer.parseInt(pt[0]);
					if(chkDownSide){
						yDelta = Integer.parseInt(pt[1]) - startY;
					}else{
						yDelta = startY - Integer.parseInt(pt[1]);
					}
					
					tmpAngle = -1;
					coef = MathUtils.lineFitting(tmpLine);
					if(-1!=tmpSlope*coef[0]){
						tmpAngle = (tmpSlope-coef[0])/(1+tmpSlope*coef[0]);
						tmpAngle = Math.toDegrees(Math.atan(tmpAngle));
					}
					if(tmpAngle>0){
						crossX = (coef[1]-tmpOffset)/(tmpSlope-coef[0]);
						delta = crossX - wrinkleStartChkPos;
						if(maxAngle<tmpAngle && Math.abs(delta)<lineScanRange*6 
							&& yDelta<lineScanRange*3
							&& !(xDelta>lineScanRange*4 
								&& yDelta>lineScanRange/2
								&& delta<minDistance)
							&& !(tmpLine.size()<lineScanRange*1.5
								&& yDelta>lineScanRange*1.5)){
							//Conditions
							//1.Cross point is close to the curve starting point
							//2.First point of the wrinkle line is close to the checked layer
							maxAngle=tmpAngle;
							maxAngleIdx = tmpLines.size() - 1;
						}
					}
				}
			}
			if(maxAngleIdx>=0){
				wrinklePts = tmpLines.get(maxAngleIdx);
			}else if(maxSizeIdx>=0){
				wrinklePts = tmpLines.get(maxSizeIdx);
				coef = MathUtils.lineFitting(wrinklePts);
				crossX = (coef[1]-tmpOffset)/(tmpSlope-coef[0]);
				delta = crossX - wrinkleStartChkPos;
				if(delta<lineScanRange*(-2) || delta>lineScanRange*2){
					yDelta = 0; xDelta = 0;
					for(Double x:wrinklePts.keySet()){
						xDelta = (int)(wrinkleStartChkPos - x);
						if(chkDownSide){
							yDelta = (int)(wrinklePts.get(x) - startY);
						}else{
							yDelta = (int)(startY - wrinklePts.get(x));
						}
						break;
					}
					
					tmpAngle = -1;
					if(-1!=tmpSlope*coef[0]){
						tmpAngle = (tmpSlope-coef[0])/(1+tmpSlope*coef[0]);
						tmpAngle = Math.toDegrees(Math.atan(tmpAngle));
					}
					
					double x0=0.0,y0=0.0;
					for(Double x:wrinklePts.keySet()){
						x0 = x; y0 = wrinklePts.get(x);
					}
					wrinklePts.clear();
					
					if(tmpAngle>0 && tmpAngle<5 && delta>lineScanRange*2
						&& yDelta<=lineScanRange/2 && xDelta<=lineScanRange/2){
						double x1,y1,newSlope,newOffset,xStep;
						x1=wrinkleStartChkPos;y1=tmpSlope*x1+tmpOffset;
						newSlope=(y1-y0)/(x1-x0);
						newOffset = y1-newSlope*x1;
						xStep = (x1-x0)/10;
						
						for(double x=x0; x<=x1; x=x+xStep){
							wrinklePts.put(x, newSlope*x+newOffset);
						}
					}
				}
			}
		}
		if(wrinklePts.size()>0){
			coef = MathUtils.lineFitting(wrinklePts);
			wrinklePts.put((double)minX, coef[0]*minX+coef[1]);
		}
		
		return wrinklePts;
	}
	
	private String getResultKey(int layerIdx){
		String procRsltKey = "";
		
		if(0==layerIdx%2){
			procRsltKey = "L" + (layerIdx/2) + "_L";
		}else{
			procRsltKey = "L" + ((layerIdx+1)/2) + "_R";
		}
		
		return procRsltKey;
	}
	
	private boolean twoNearLinesOverhangFailed(int curLineIdx, ImgExtractLine curLine, ImgExtractLine nextLine, double curLineWeight, double nextLineWeight){
		boolean failed = true;
		double minDistance = 10;//pixels
		double maxDistance = 116;//pixels
		double onePixelLen = 0.012;
		double overhang = 0.0;
		int refCurrLine = 0, refNextLine = 0;
		
		onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		
		if(null!=curLine && null!=nextLine){
			if(evenPoleIsLonger && 0==curLineIdx%2 || !evenPoleIsLonger && 1==curLineIdx%2){
				refCurrLine = (int)(curLine.getXAxisStop() + (curLine.getXAxisStart()-curLine.getXAxisStop())*(1-curLineWeight));
				refNextLine = (int)(nextLine.getXAxisStart() - (nextLine.getXAxisStart()-nextLine.getXAxisStop())*nextLineWeight);
			}else{
				refCurrLine = (int)(curLine.getXAxisStart() - (curLine.getXAxisStart()-curLine.getXAxisStop())*curLineWeight);
				refNextLine = (int)(nextLine.getXAxisStop() + (nextLine.getXAxisStart()-nextLine.getXAxisStop())*(1-nextLineWeight));
			}
			
			if(firstPoleIsLonger){
				overhang = evenPoleIsLonger?refNextLine - refCurrLine:refCurrLine - refNextLine;
			}else{
				overhang = !evenPoleIsLonger?refCurrLine - refNextLine:refNextLine - refCurrLine;
			}
			if(overhang>=minDistance && overhang<=maxDistance) failed = false;
		}
		
		return failed;
	}
	
	private boolean calculateFinalResult(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger, int[][] imgGrays, int defaultVal, int targetLinesQty, int[][] peakVals, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean bPassed = false, curLinePassed = false;
		double minDistance = 10;//pixels
		double maxDistance = 116;//pixels
		double maxPoleAngle = 25;//degrees
		double maxMissedCheckRate = 0.0, minPassedRate = 1.0, onePixelLen = 0.012;
		int meetCndQty = 0, missedCheckQty = 0;
		double missedCheckRate = 0.0, passedRate = 0.0;
		int imgHeight = imgGrays[0].length;
		String procRsltKey = "";
		
		onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		maxPoleAngle = Double.parseDouble(""+criteria.get("maxPoleAngle"));
		
		int[] distances = new int[targetLinesQty];
		int lineCounter = 0;
		for(int i=0; i<targetLinesQty; i++){
			curLinePassed = false;
			ImgExtractLine exLine = linesMap.get(i);
			if(null!=exLine){
				String grays = "";
				int start = 0, imgWidth = finalData.length, nearCol = 0;
				int lineFlag = lineIndexBase+i;
				double lineSlope = exLine.getLineSlope();
				double lineOffset = exLine.getLineIntercept()+exLine.getLineInterceptDelta();
				if(i>=10){
					start = exLine.getMostSharpChgPos(evenLineLonger,linesMap,i,imgGrays,peakVals,targetLinesQty);
				}else{
					if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
						start = exLine.getXAxisStop();
					}else{
						start = exLine.getXAxisStart();
					}
				}
				exLine.setPolePosition(start);
				if(i>0){
					procRsltKey = getResultKey(i);
					if(null!=linesMap.get(i-1)){
						if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
							distances[i] = linesMap.get(i-1).getPolePosition() - start;
						}else{
							distances[i] = start - linesMap.get(i-1).getPolePosition();
						}
						if(distances[i]>=minDistance && distances[i]<=maxDistance){
							meetCndQty++;
							curLinePassed = true;
						}else if(distances[i]<minDistance && i<10){
							//TODO Double check special case
							int[][] tmpGrays = new int[imgWidth][imgHeight];
							for(int k=0; k<imgWidth; k++){
								tmpGrays[k] = imgGrays[k].clone();
							}
							double tmpSlope = exLine.getLineSlope();
							double tmpOffset = exLine.getLineIntercept();
							double oriSlope = tmpSlope, oriOffset = tmpOffset;
							double maxDnChkOffset = 0.0, maxUpChkOffset = 0.0;
							boolean checkDnSide = false, checkUpSide = false;
							int newXAxisStop = -1, abnXAxisStop = -1, wrinkleLineMaxOffset = 0;
							int upStartChkPos = 0, dnStartChkPos = 0, dnCrossX = -1, upCrossX = -1;
							ImgExtractLine tmpLine = null;
							
							wrinkleLineMaxOffset = (int)(evenPoleAvgOffset+oddPoleAvgOffset)/2;
							maxDnChkOffset = (evenPoleAvgOffset+oddPoleAvgOffset)/2;
							maxUpChkOffset = maxDnChkOffset;
							if(curLineIsLonger(i, evenLineLonger)){
								//Current line is the longer one
								tmpLine = exLine;
								if(null!=linesMap.get(i-1) && null==linesMap.get(i-2)){
									maxUpChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i-1).getLineIntercept()-linesMap.get(i-1).getLineInterceptDelta();
									maxUpChkOffset = Math.abs(maxUpChkOffset)*1.5;
//									checkUpSide = true;
									upStartChkPos = linesMap.get(i-1).getXAxisStart();
								}
								if(null!=linesMap.get(i+1)){
									if(null!=linesMap.get(i+2)){
										maxDnChkOffset = linesMap.get(i+2).getLineIntercept()+linesMap.get(i+2).getLineInterceptDelta();
										maxDnChkOffset = maxDnChkOffset - tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
									}else{
										maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i+1).getLineIntercept()-linesMap.get(i+1).getLineInterceptDelta();
										maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
									}
									checkDnSide = true;
									dnStartChkPos = linesMap.get(i+1).getXAxisStart();
								}
							}else{
								//Last line is the longer one
								tmpLine = linesMap.get(i-1);
								tmpSlope = tmpLine.getLineSlope();
								tmpOffset = tmpLine.getLineIntercept();
								oriSlope = tmpSlope; oriOffset = tmpOffset;
								if(null!=linesMap.get(i-2) && null==linesMap.get(i-3)){
									maxUpChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i-2).getLineIntercept()-linesMap.get(i-2).getLineInterceptDelta();
									maxUpChkOffset = Math.abs(maxUpChkOffset)*1.5;
//									checkUpSide = true;
									upStartChkPos = linesMap.get(i-2).getXAxisStart();
								}
								if(null!=linesMap.get(i+1)){
									maxDnChkOffset = linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta();
									maxDnChkOffset = maxDnChkOffset-tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
								}else{
									maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-exLine.getLineIntercept()-exLine.getLineInterceptDelta();
									maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
								}
								checkDnSide = true;
								dnStartChkPos = exLine.getXAxisStart();
								if(1==tmpLine.getWrinkleFlag() || 3==tmpLine.getWrinkleFlag()){
									checkDnSide = false;
								}
							}
							
							int refPos = tmpLine.getPolePosition();
							int upSideGray = 0, dnSideGray = 0, scanLines = 3, minIdx = -1;
							int startChkPos = refPos - distances[i];
							if(startChkPos<0) startChkPos = 0;
							int stopChkPos = startChkPos - (int)maxDistance;
							if(stopChkPos<0) stopChkPos = 0;
							
							LinkedHashMap<Double,Double> dnSideWrinkleLine = new LinkedHashMap<Double,Double>();
							LinkedHashMap<Double,Double> upSideWrinkleLine = new LinkedHashMap<Double,Double>();
							//Check up side
							if(checkUpSide){
//								upSideWrinkleLine = getWrinklePts(tmpLine,peakVals,upStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxUpChkOffset,false);
//								upSideWrinkleLine = getWrinkleLineEx(tmpLine,upSideWrinkleLine,upStartChkPos,-maxUpChkOffset,maxPoleAngle,peakVals);
								upSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,upStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxUpChkOffset,false);
							}
							
							//Check down side
							if(checkDnSide){
//								dnSideWrinkleLine = getWrinklePts(tmpLine,peakVals,dnStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
//								dnSideWrinkleLine = getWrinkleLineEx(tmpLine,dnSideWrinkleLine,startChkPos,maxDnChkOffset,maxPoleAngle,peakVals);
								dnSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,dnStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
							}
							
							double[] dnLineParas = null, upLineParas = null;
							double dnSideAngle = 0.0, upSideAngle = 0.0;
							if(dnSideWrinkleLine.size()>=5){
								dnLineParas = MathUtils.lineFitting(dnSideWrinkleLine);
								dnSideAngle = 90.0;
								if(-1!=tmpSlope*dnLineParas[0]){
									dnSideAngle = Math.abs((tmpSlope-dnLineParas[0])/(1+tmpSlope*dnLineParas[0]));
									dnSideAngle = Math.toDegrees(Math.atan(dnSideAngle));
									dnCrossX = (int)((tmpOffset-dnLineParas[1])/(dnLineParas[0]-tmpSlope));
									System.out.println("Dn Side Angle:"+dnSideAngle);
								}
								tmpLine.setWrinkleFlag(1);
							}
							if(upSideWrinkleLine.size()>=5){
								upLineParas = MathUtils.lineFitting(upSideWrinkleLine);
								upSideAngle = 90.0;
								if(-1!=tmpSlope*upLineParas[0]){
									upSideAngle = Math.abs((tmpSlope-upLineParas[0])/(1+tmpSlope*upLineParas[0]));
									upSideAngle = Math.toDegrees(Math.atan(upSideAngle));
									upCrossX = (int)((tmpOffset-upLineParas[1])/(upLineParas[0]-tmpSlope));
									System.out.println("Up Side Angle:"+upSideAngle);
								}
								if(dnSideWrinkleLine.size()>=5){
									tmpLine.setWrinkleFlag(3);
								}else{
									tmpLine.setWrinkleFlag(2);
								}
							}
							if(!curLineIsLonger(i, evenLineLonger) && !checkDnSide){
								if(null!=imgProcResultAngle.get(procRsltKey) && imgProcResultAngle.get(procRsltKey)>maxPoleAngle){
									newXAxisStop = tmpLine.getXAxisStop();
								}
							}
							
							if(dnSideAngle>0 || upSideAngle>0){
								storeLayerAngle(evenLineLonger, i, dnSideAngle, upSideAngle);
								if(dnSideAngle>maxPoleAngle || upSideAngle>maxPoleAngle){
									if(0==i%2 && evenLineLonger || 1==i%2 &&!evenLineLonger){
										if(checkUpSide && upSideAngle>maxPoleAngle){
											abnXAxisStop = imgWidth;
											for(double k:upSideWrinkleLine.keySet()){
												if(k<abnXAxisStop) abnXAxisStop=(int)k;
											}
										}
									}else{
										if(checkDnSide && dnSideAngle>maxPoleAngle){
											abnXAxisStop = imgWidth;
											for(double k:dnSideWrinkleLine.keySet()){
												if(k<abnXAxisStop) abnXAxisStop=(int)k;
											}
										}
									}
									newXAxisStop = dnCrossX>upCrossX?dnCrossX:upCrossX;
									
									if(abnXAxisStop<0){
										dnSideAngle = 0; upSideAngle = 0;
									}
								}else{
									if(dnSideAngle>0 && dnSideAngle<=maxPoleAngle){
										upSideGray = dnSideGray + 1;
										minIdx = imgWidth;
										for(double k:dnSideWrinkleLine.keySet()){
											if(k<minIdx) minIdx=(int)k;
										}
										newXAxisStop = minIdx;
										for(int k=refPos; k>=minIdx; k--){
											nearCol = (int)(k*tmpSlope+tmpOffset);
											for(int n=(int)maxDnChkOffset;n>0;n--){
												if(nearCol+n>=0 && nearCol+n<imgHeight){
													if(imgGrays[k][nearCol+n]<defaultVal){
														if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
															tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
														}
													}
												}
											}
										}
									}else if(upSideAngle>0 && upSideAngle<=maxPoleAngle){
										dnSideGray = upSideGray + 1;
										minIdx = imgWidth;
										for(double k:upSideWrinkleLine.keySet()){
											if(k<minIdx) minIdx=(int)k;
										}
										if(newXAxisStop<0) newXAxisStop = minIdx;
										if(newXAxisStop>minIdx) newXAxisStop = minIdx;
										for(int k=(refPos+5); k>=minIdx; k--){
											nearCol = (int)(k*tmpSlope+tmpOffset);
											for(int n=(int)maxUpChkOffset;n>0;n--){
												if(nearCol-n>=0 && nearCol-n<imgHeight){
													if(imgGrays[k][nearCol-n]<defaultVal){
														if(tmpGrays[k][nearCol]>imgGrays[k][nearCol-n]){
															tmpGrays[k][nearCol]=imgGrays[k][nearCol-n];
														}
													}
												}
											}
										}
									}
								}
							}
							
							if(!(dnSideAngle>0 || upSideAngle>0) && -1==newXAxisStop){
								for(int k=refPos; k>0; k--){
									nearCol = (int)(k*tmpSlope+tmpOffset);
									if(nearCol>=1 && nearCol<imgHeight){
										upSideGray += imgGrays[k][nearCol-1];
										dnSideGray += imgGrays[k][nearCol+1];
									}
								}
								if(upSideGray>dnSideGray){//Check down side
									for(int k=refPos; k>0; k--){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=0 && nearCol<(imgHeight-scanLines)){
											for(int n=0; n<=scanLines; n++){
												if(imgGrays[k][nearCol+n]<defaultVal){
													if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
														tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
													}
												}
											}
										}
									}
								}else if(upSideGray<dnSideGray){//Check up side
									for(int k=refPos; k>0; k--){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=scanLines && nearCol<imgHeight){
											for(int n=0; n<=scanLines; n++){
												if(imgGrays[k][nearCol-n]<defaultVal){
													if(tmpGrays[k][nearCol]>imgGrays[k][nearCol-n]){
														tmpGrays[k][nearCol] = imgGrays[k][nearCol-n];
													}
												}
											}
										}
									}
								}
							}
							
							int oriRefPos = tmpLine.getPolePosition();
							int startPos = 0, stopPos = 0, oriCol = 0;
							boolean bDnSideWrinkle = false;
							if(upSideGray>dnSideGray || dnSideGray>upSideGray || -1!=newXAxisStop){
								System.out.println("Ori start/stop:"+tmpLine.getXAxisStart()+"/"+tmpLine.getXAxisStop());
								if(newXAxisStop<0){
									tmpLine = setLineBoundary(tmpLine, tmpGrays, defaultVal);
								}else{
									tmpLine.setXAxisStop(newXAxisStop);
									if(tmpLine.getXAxisStart()<newXAxisStop) tmpLine.setXAxisStart(newXAxisStop);
								}
								System.out.println("Cur start/stop:"+tmpLine.getXAxisStart()+"/"+tmpLine.getXAxisStop());
								tmpLine.setPolePosition(tmpLine.getXAxisStop());//tmpLine is the longer pole
								
								if(curLineIsLonger(i, evenLineLonger)){
									linesMap.put(i, tmpLine);//Current line is the longer one
								}else{
									linesMap.put(i-1, tmpLine);//Last line is the longer one
								}
								
								if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
									distances[i] = linesMap.get(i-1).getPolePosition() - linesMap.get(i).getPolePosition();
								}else{
									distances[i] = linesMap.get(i).getPolePosition() - linesMap.get(i-1).getPolePosition();
								}
								//distances[i] = Math.abs(linesMap.get(i).getPolePosition() - linesMap.get(i-1).getPolePosition());
								if(distances[i]>=minDistance && distances[i]<=maxDistance){
									meetCndQty++;
									curLinePassed = true;
								}
								
								if(!curLinePassed) lineFlag = 4;
								refPos = tmpLine.getXAxisStop();
								if(refPos > oriRefPos){
									startPos = oriRefPos;
									stopPos = refPos;
								}else{
									startPos = refPos;
									stopPos = oriRefPos;
								}
								
								bDnSideWrinkle = false;
								if(dnSideAngle>0 || upSideAngle>0){
									if(dnSideAngle>upSideAngle){
										tmpSlope = dnLineParas[0];
										tmpOffset = dnLineParas[1];
										bDnSideWrinkle = true;
									}else{
										tmpSlope = upLineParas[0];
										tmpOffset = upLineParas[1];
									}
									for(int k=startPos; k<=stopPos; k++){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										oriCol = (int)(k*oriSlope+oriOffset);
										if(bDnSideWrinkle && nearCol<oriCol) nearCol = oriCol;
										if(!bDnSideWrinkle && nearCol>oriCol) nearCol = oriCol;
										if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
									}
								}else{
									for(int k=startPos; k<=stopPos; k++){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
									}
								}
							}
							
							if(null!=dnLineParas || null!=upLineParas){
								bDnSideWrinkle = false;
								if(null!=dnLineParas){
									tmpSlope = dnLineParas[0];
									tmpOffset = dnLineParas[1];
									bDnSideWrinkle = true;
									if(abnXAxisStop<0){
										abnXAxisStop = imgWidth;
										for(double k:dnSideWrinkleLine.keySet()){
											if(k<abnXAxisStop) abnXAxisStop=(int)k;
										}
									}
								}else{
									tmpSlope = upLineParas[0];
									tmpOffset = upLineParas[1];
									if(abnXAxisStop<0){
										abnXAxisStop = imgWidth;
										for(double k:upSideWrinkleLine.keySet()){
											if(k<abnXAxisStop) abnXAxisStop=(int)k;
										}
									}
								}
								for(int k=abnXAxisStop; k<=oriRefPos; k++){
									nearCol = (int)(k*tmpSlope+tmpOffset);
									oriCol = (int)(k*oriSlope+oriOffset);
									if(bDnSideWrinkle && nearCol<oriCol) nearCol = oriCol;
									if(!bDnSideWrinkle && nearCol>oriCol) nearCol = oriCol;
									if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
								}
							}
						}
						if(!curLinePassed) lineFlag = 4;//Draw the failed line
						imgProcResultLength.put(procRsltKey, distances[i]*onePixelLen);
						imgProcResultOK.put(procRsltKey, curLinePassed);
					}else{
						missedCheckQty++;
						imgProcResultLength.put(procRsltKey, 0.0);
						imgProcResultOK.put(procRsltKey, false);
					}
				}
				
				if(exLine.getCrossX()>0) start = exLine.getCrossX();
				for(int k=0; k<start; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					grays += "," + imgGrays[k][nearCol];
				}
				for(int k=start; k<imgWidth; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					finalData[k][nearCol] = lineFlag;
					grays += "," + imgGrays[k][nearCol];
				}
				
				lineCounter++;
				if(logEnabled){
					LogUtils.rawLog("sortLineParas_", exLine.printLineParas(i,1==lineCounter?true:false));
					LogUtils.rawLog("sortLineGrays_", "G"+i+grays);
				}
			}else{
				if(i>0) missedCheckQty++;
			}
		}
		
		//Most outer line special handling
		if(!evenLineLonger && null!=imgProcResultLength.get("L1_R") && null!=imgProcResultLength.get("L1_L")){
			double layer1R = imgProcResultLength.get("L1_R");
			double layer1L = imgProcResultLength.get("L1_L");
			if(layer1R>0 && layer1R<(minDistance*onePixelLen)
				&& layer1L>0 && layer1L>(minDistance*onePixelLen)){
				meetCndQty++;
			}
		}
		
		//Double check the result
		for(String key:imgProcResultOK.keySet()){
			if(!imgProcResultOK.get(key) && key.endsWith("_R")){
				if(null!=imgProcResultAngle.get(key.replace("_R", "_L"))){
					meetCndQty++;
					imgProcResultOK.put(key, true);
					imgProcResultLength.put(key, imgProcResultLength.get(key.replace("_R", "_L")));
				}
			}
		}
		
		missedCheckRate = (double)missedCheckQty / (targetLinesQty - 1);
		passedRate = (double)meetCndQty / (targetLinesQty - 1 - missedCheckQty);
		if(missedCheckRate<=maxMissedCheckRate && passedRate>=minPassedRate){
			bPassed = true;
		}
		
		return bPassed;
	}

	private void storeLayerAngle(boolean evenLineLonger, int layerIdx, double dnSideAngle, double upSideAngle) {
		if(dnSideAngle>0 || upSideAngle>0){
			String angleKey = "";
			if(curLineIsLonger(layerIdx, evenLineLonger)){
				if(0==layerIdx%2){
					angleKey = "L" + (layerIdx/2);
				}else{
					angleKey = "L" + ((layerIdx+1)/2);
				}
			}else{
				if(0==(layerIdx-1)%2){
					angleKey = "L" + ((layerIdx-1)/2);
				}else{
					angleKey = "L" + (layerIdx/2);
				}
			}
			angleKey = angleKey + (dnSideAngle>upSideAngle?"_L":"_R");
			imgProcResultAngle.put(angleKey, (dnSideAngle>upSideAngle?dnSideAngle:upSideAngle));
		}
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> searchMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap,
			ImgExtractLine myBaseline,int[][] peakVals, int[][] initVals, int[][]imgGrays, 
			int defaultVal, double[] slope, double[] offset, int bestRsqIdx,
			double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty, boolean chkMinOffset){
		
		double diff1,diff2,offsetChgR,addLineSlope,addLineOffset,off1,off2,curOffset;
		double researchSlope = myBaseline.getLineSlope(), researchOffset = myBaseline.getLineIntercept();
		double researchOffsetStop = 0;
		
		for(int i=0; i<targetLinesQty; i++){
			ImgExtractLine exLine = linesMap.get(i);
			if(null==exLine){
				if(null!=linesMap.get(i-1)){
					researchOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta();
				}else{
					researchOffset = slope[bestRsqIdx]*(i-1)+offset[bestRsqIdx];
				}
				
				if(null!=linesMap.get(i+1)){
					researchOffsetStop = linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta();
				}else{
					researchOffsetStop = slope[bestRsqIdx]*(i+1)+offset[bestRsqIdx];
				}
				off1 = researchOffset; off2 = researchOffsetStop;
				addLineSlope = researchSlope; addLineOffset = (researchOffset+researchOffsetStop)/2;
				if(0==i%2){
					researchOffset += evenPoleAvgOffset*0.9;
					researchOffsetStop -= (oddPoleAvgOffset*0.9>lineScanRange?lineScanRange:oddPoleAvgOffset*0.9);
					if(i==(targetLinesQty-1)) researchOffsetStop = researchOffset + oddPoleAvgOffset*1.5;
				}else{
					researchOffset += oddPoleAvgOffset*0.9;
					researchOffsetStop -= (evenPoleAvgOffset*0.9>lineScanRange?lineScanRange:evenPoleAvgOffset*0.9);
					if(i==(targetLinesQty-1)) researchOffsetStop = researchOffset + evenPoleAvgOffset*1.5;
				}
				if(researchOffsetStop-researchOffset<lineScanRange){
					researchOffset = (researchOffsetStop+researchOffset)/2-lineScanRange/2-1;
					researchOffsetStop = researchOffset+lineScanRange+1;
				}
				
				exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
				if(null!=exLine){
					if(null!=linesMap.get(i-2) && null!=linesMap.get(i-3)){
						diff1 = exLine.getLineIntercept()+exLine.getLineInterceptDelta()-researchOffset;
						diff2 = linesMap.get(i-2).getLineIntercept()-linesMap.get(i-3).getLineIntercept();
						diff2 += linesMap.get(i-2).getLineInterceptDelta()-linesMap.get(i-3).getLineInterceptDelta();
						offsetChgR = diff1/diff2;
						if(offsetChgR>maxOffsetChgRate){
							researchOffsetStop = exLine.getLineIntercept()+exLine.getLineInterceptDelta() - lineScanRange/2;
							exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
						}
						else if(chkMinOffset && offsetChgR<minOffsetChgRate){
							curOffset = exLine.getLineIntercept()+exLine.getLineInterceptDelta();
							if(off2-curOffset<curOffset-off1){
								exLine = addFixedLine(peakVals,imgGrays,defaultVal,addLineSlope,addLineOffset);
							}
						}
					}
					if(null!=exLine){
						exLine.setLineFlag(3);
						linesMap.put(i, exLine);
					}
				}
				System.out.println((null==exLine?"Missing:":"Insert:")+i);
			}else{
				researchSlope = linesMap.get(i).getLineSlope();
			}
		}
		
		return linesMap;
	}
	
	private boolean thereIsMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap, int targetLinesQty){
		boolean missing = false;
		
		for(int i=0; i<targetLinesQty; i++){
			if(null == linesMap.get(i)){
				missing = true;
				break;
			}
		}
		return missing;
	}
	
	private boolean lineIsNegPole(int lineIdx, boolean evenLineLonger, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean isNegPole = false;
		
		if(0==lineIdx%2 && !evenLineLonger || 1==lineIdx%2 && evenLineLonger){
			if(evenPoleAvgOffset>oddPoleAvgOffset) isNegPole = true;
		}
		
		return isNegPole;
	}
	
	private ImgExtractLine getMostClosedLine(double offset, double tolerance){
		ImgExtractLine line = null;
		int idx = -1;
		for(int i=0; i<allPossibleLines.size(); i++){
			if(allPossibleLines.get(i).getLineIntercept()>=offset){
				idx = i;
				break;
			}
		}
		if(idx>=0){
			if(allPossibleLines.get(idx).getLineIntercept()-offset<=tolerance){
				line = allPossibleLines.get(idx);
			}else if(idx>0 && allPossibleLines.get(idx-1).getLineIntercept()-offset<=tolerance){
				line = allPossibleLines.get(idx-1);
			}
		}
		
		return line;
	}
	
	private int getLineMeanGray(ImgExtractLine currLine, int[][] imgGrays, int startIdx, int stopIdx){
		if(null==currLine) return -1;
		
		double slope = currLine.getLineSlope(), sumGray = 0.0;
		double offset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
		int nearCol = 0, imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		int meanGray = -1, counter = 0;
		if(startIdx>stopIdx){
			nearCol = startIdx;
			startIdx = stopIdx;
			stopIdx = nearCol;
		}
		if(startIdx<0) startIdx = 0;
		if(stopIdx+1>imgWidth) stopIdx=imgWidth-1;
		
		for(int i=startIdx; i<=stopIdx; i++){
			nearCol = (int)(slope * i + offset);
			if(nearCol>=0 && nearCol<imgHeight){
				sumGray += imgGrays[i][nearCol];
				counter++;
			}
		}
		if(counter>0) meanGray = (int)(sumGray/counter);
		
		return meanGray;
	}
	
	private boolean thereIsPoleBtw(int[][] imgGrays, ImgExtractLine currLine, ImgExtractLine lastLine, boolean supposed){
		boolean poleExisting = supposed;
		
		if(null!=currLine && null!=lastLine){
			poleExisting = false;
			ImgExtractLine tmpLine = null;
			double offset1 = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
			double offset2 = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
			poleExisting = offsetInPeakRegion(allPossibleLines,(offset1+offset2)/2);
			
			//If out of expectation
			int gray0 = 0, gray1 = 0, gray2 = 0;
			if(!poleExisting && supposed){
				tmpLine = getMostClosedLine((offset1+offset2)/2,lineScanRange/2);
				if(null!=tmpLine){
					gray0 = getLineMeanGray(tmpLine,imgGrays,imgGrays.length/2,imgGrays.length);
					gray1 = getLineMeanGray(currLine,imgGrays,imgGrays.length/2,imgGrays.length);
					gray2 = getLineMeanGray(lastLine,imgGrays,imgGrays.length/2,imgGrays.length);
					if((double)(gray0-gray1+gray0-gray2)/2+0.5<3){
						poleExisting = supposed;
					}else{
						poleExisting = !supposed;
					}
				}
			}
		}
		
		return poleExisting;
	}
	
	private boolean lineIsThicker(double[] weightOfLine, int[][] imgGrays, ImgExtractLine currLine, ImgExtractLine lastLine, double offsetChgR){
		boolean thicker = false;
		//Total lines appear in Up or Dn side checking region is more than 3
		if(weightOfLine[6]>=0.6 && weightOfLine[8]>=5 
			|| weightOfLine[5]>=0.6 && weightOfLine[7]>=5
			|| weightOfLine[5]*weightOfLine[7]+weightOfLine[6]*weightOfLine[8]>=5){
			if(null==currLine){
				thicker = true;
			}else{
				double slope = currLine.getLineSlope();
				double offsetCurrLine = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				double offsetLastLine = offsetCurrLine-10;
				if(null!=lastLine) offsetLastLine = lastLine.getLineIntercept() + lastLine.getLineInterceptDelta()-3;
				int scanRange = (int)(offsetCurrLine - offsetLastLine);
				if(scanRange<0) scanRange = 10;
				int stDelta = -5;
				int[] grays = new int[scanRange+1-stDelta];
				int innerAvgGray = 0, outerAvgGray = 0, innerCnt = 0, outerCnt = 0;
				double innerGray = 0.0, outerGray = 0.0;
				
				for(int i=stDelta; i<=scanRange; i++){
					grays[i-stDelta] = currLine.getLineAvgGray(imgGrays, currLine.getXAxisStop(), slope, offsetCurrLine-i);
					if(i<scanRange/2){
						innerGray += grays[i-stDelta];
						innerCnt++;
					}else{
						outerGray += grays[i-stDelta];
						outerCnt++;
					}
				}
				outerAvgGray = (int)(outerGray/outerCnt);
				innerAvgGray = (int)(innerGray/innerCnt);
				
				if(outerAvgGray-innerAvgGray>3 
					|| outerAvgGray-innerAvgGray>=3 && weightOfLine[5]*weightOfLine[7]+weightOfLine[6]*weightOfLine[8]>=5
				){
					thicker = true;
				}
			}
		}
		
		return thicker;
	}
	
	private boolean evenLineIsLonger(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays){
		boolean evenLineLonger = false;
		int[] refGrayIndex = new int[targetLinesQty];
		double[] refGrays = new double[targetLinesQty];
		int longPoleFirstQty = 0, imgHeight = imgGrays[0].length;
		double weightOfEvenLineLonger = 0.0;
		
		for(int i=0; i<targetLinesQty; i++){
			ImgExtractLine exLine = linesMap.get(i);
			if(null!=exLine){
				if(0==i%2){
					refGrayIndex[i] = exLine.getXAxisStart();
				}else{
					refGrayIndex[i] = refGrayIndex[i-1];
				}
				
				double refGray = 0.0;
				double lineSlope = exLine.getLineSlope();
				double lineOffset = exLine.getLineIntercept();
				int nearCol = 0;
				for(int k=0; k<=refGrayIndex[i]; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					refGray += imgGrays[k][nearCol];
				}
				exLine.setRefGray(refGray);
				refGrays[i] = refGray;
				
				if(0!=i%2){
					if(refGrays[i]>refGrays[i-1]) longPoleFirstQty++;
				}
			}
		}
		weightOfEvenLineLonger = (double)longPoleFirstQty*2 / targetLinesQty;
		if(weightOfEvenLineLonger>0.5) evenLineLonger = true;
		
		return evenLineLonger;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> addMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap,
			ImgExtractLine myBaseline,int[][] peakVals, int[][] initVals, int[][]imgGrays, 
			int defaultVal, double[] slope, double[] offset, int bestRsqIdx,
			double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty){
		
		double addLineSlope = 0.0, addLineOffset = 0.0;
		double researchOffset = 0.0, researchOffsetStop = 0.0, researchSlope = 0.0;
		
		for(int i=1; i<targetLinesQty; i++){
			if(null==linesMap.get(i) && null!=linesMap.get(i-1)){
				ImgExtractLine exLine = null;
				addLineSlope = 0.0; addLineOffset = 0.0;
				if(null!=linesMap.get(i+1)){
					addLineSlope = (linesMap.get(i-1).getLineSlope()+linesMap.get(i+1).getLineSlope())/2;
					addLineOffset = (linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()
							+linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta())/2;
				}else if(i==(targetLinesQty-1)){
					researchSlope = linesMap.get(i-1).getLineSlope();
					researchOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()+(evenPoleAvgOffset+oddPoleAvgOffset)/2;
					researchOffsetStop = researchOffset + (evenPoleAvgOffset+oddPoleAvgOffset)/2*3;
					exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
					if(null!=exLine){
						exLine.setLineFlag(3);
					}else{
						addLineSlope = linesMap.get(i-1).getLineSlope();
						addLineOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()
								+(evenPoleAvgOffset+oddPoleAvgOffset)/2;
					}
				}
				if(addLineOffset>0) exLine = addFixedLine(peakVals,imgGrays,defaultVal,addLineSlope,addLineOffset);
				if(null!=exLine) linesMap.put(i, exLine);
			}
		}
		
		return linesMap;
	}
	
	private ImgExtractLine addFixedLine(int[][] peakVals, int[][]imgGrays, 
			int defaultVal, double addLineSlope, double addLineOffset){
		
		ImgExtractLine exLine = null;
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int nearCol = 0, scanRng = lineScanRange/2, colOffset = 0, maxCnt = 0;
		int[] dataCounters = new int[scanRng*2+1];
		exLine = new ImgExtractLine();
		
		for(int j=(imgWidth-1); j>=0; j--){
			nearCol = (int)(j*addLineSlope+addLineOffset);
			for(int k=-scanRng; k<=scanRng; k++){
				if(nearCol+k>=0 && nearCol+k<imgHeight){
					if(peakVals[j][nearCol+k]<lineFitGrayThr){
						dataCounters[k+scanRng] = dataCounters[k+scanRng]+1;
					}
				}
			}
		}
		
		for(int k=0; k<dataCounters.length; k++){
			if(maxCnt<dataCounters[k]){
				maxCnt = dataCounters[k];
				colOffset = k;
			}
		}
		
		colOffset = colOffset - scanRng;
		for(int j=(imgWidth-1); j>=0; j--){
			nearCol = (int)(j*addLineSlope+addLineOffset);
			if(nearCol+colOffset>=0 && nearCol+colOffset<imgHeight){
				if(peakVals[j][nearCol+colOffset]<lineFitGrayThr){
					exLine.addPoint(j, nearCol, imgGrays[j][nearCol]);
				}
			}
		}
		
		exLine.getLineCoef(false);
		exLine.setLineFlag(3);
		exLine = setLineBoundary(exLine, imgGrays, defaultVal);
		
		return exLine;
	}
	
	private void initLineFitGrayThreshold(){
		lineFitGrayThr = 255 * 0.8;
	}
	
	private void adjustLineFitGrayThreshold(int[][] imgGrays, ImgExtractLine myBaseline, int scanOffset){
		double slope = myBaseline.getLineSlope();
		double offset = myBaseline.getLineIntercept();
		int nearRow = 0, imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		double grayAvg = 0.0;
		int counter = 0;
		
		for(int col=0; col<imgWidth; col++){
			nearRow = (int)(slope*col+offset);
			if(nearRow<0 || nearRow+scanOffset>imgHeight) continue;
			for(int row=0; row<scanOffset; row++){
				if(imgGrays[col][nearRow+row]<noiseGrayThr){
					counter++;
					grayAvg += imgGrays[col][nearRow+row];
				}
			}
		}
		
		if(counter>0){
			grayAvg = grayAvg / counter * 1.05;
			System.out.println("Line fit threshold:"+lineFitGrayThr+"/"+grayAvg);
			if(grayAvg>lineFitGrayThr) lineFitGrayThr = grayAvg;
		}
	}
	
	private ArrayList<ImgExtractLine> searchLines(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, ImgExtractLine myBaseline){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int validCnt = 0, nearCol = 0, noisePoints = 0, realPoints = 0;
		int invalidCnt = 0, minValidCol = imgWidth*2, maxValidCol = -1;
		int startChkX = (int)(imgWidth*0.4), lastValidX = 0;
		int maxBlankX = (int)(imgWidth*0.05);
		double noiseRate = 0.0, slopeDelta = 0.0, validRate = 0.0;
		double lastLineOffset = 0.0, lastLineSlope = 0.0;
		double offsetDelta1 = 0.0, offsetDelta2 = 0.0, offsetDelta3 = 0.0, offsetDelta = 0.0;
		double invalidRatio = 0.0, maxColDelta = 3.0;
		int startSearchingOffset = 0, currentLineOffset = 0, finalSearchingOffset = 0;
		int lineSearchingRng = lineScanRange / 2;//Two sides searching
		
		int fittingMinPoints = (int)(imgWidth * minValidRatio);
		boolean bLineFound = false;
		
		int[][] sortData = new int[imgWidth][imgHeight];
		int[][] searchingLinesData = new int[imgWidth][imgHeight];
		finalData = new int[imgWidth][imgHeight];
		for(int i=0; i<imgWidth; i++){
			sortData[i] = initVals[i].clone();
			finalData[i] = initVals[i].clone();
			searchingLinesData[i] = peakVals[i].clone();
		}
		double myBaselineSlope = myBaseline.getLineSlope();
		double myBaselineOffset = myBaseline.getLineIntercept();
		startSearchingOffset = (int)(myBaselineSlope*(imgWidth-1)+myBaselineOffset);
		if(startSearchingOffset<0) startSearchingOffset = 0;
		lastLineOffset = -1;
		initLineFitGrayThreshold();
		adjustLineFitGrayThreshold(imgGrays,myBaseline,30);
		
		double[] lineCoef = null;
		ArrayList<ImgExtractLine> extractLines = new ArrayList<ImgExtractLine>();
		ImgExtractLine lastPossibleLine = null;
		ImgExtractLine extractLine = new ImgExtractLine();
		ImgExtractLine.setMinRSQ(0.7f);
		
		if(imgWidth > fittingMinPoints && imgHeight > lineSearchingRng){
			for(int i=startSearchingOffset; i<imgHeight; i++){
				bLineFound = false;
				minValidCol = imgWidth*2; maxValidCol = -1;
				extractLine.clearLineData();
				for(int j=(imgWidth-1); j>=0; j--){
					if(j<startChkX){
						lineSearchingRng = 1;
					}else{
						lineSearchingRng = lineScanRange / 2;
					}
					nearCol = (int)(j*myBaselineSlope+myBaselineOffset);
					if((nearCol-lineSearchingRng)>=0 && nearCol<(imgHeight-lineSearchingRng)){
						for(int k=-lineSearchingRng; k<lineSearchingRng; k++){
							if(peakVals[j][nearCol+k]<lineFitGrayThr){
								if(j>=startChkX || j<startChkX && lastValidX-j<maxBlankX){
									extractLine.addPoint(j, nearCol+k, peakVals[j][nearCol+k]);
									if((nearCol+k)<minValidCol) minValidCol = nearCol+k;
									if((nearCol+k)>maxValidCol) maxValidCol = nearCol+k;
									if(Math.abs(k)<=1) extractLine.addRealPoints(j, nearCol+k, 1);
									lastValidX = j;
								}
							}
							if(imgGrays[j][nearCol+k]>=noiseGrayThr) extractLine.addInvalidPoints(1);
						}
					}
				}
				
				validCnt = extractLine.getValidPoints();
				realPoints = extractLine.getRealPoints();
				invalidCnt = extractLine.getInvalidPoints();
				invalidRatio = (double)invalidCnt / (lineSearchingRng*2+1) / imgWidth;
				
				if(extractLines.size()<=0){
					saveSearchingLines(searchingLinesData,myBaselineSlope,myBaselineOffset,i,"debug");
					if(i-startSearchingOffset>(lineScanRange*3)){
						System.out.println("Fail to get 1st layer");
						break;
					}
				}else if(2==extractLines.size()){
//					if(249==i)
//					System.out.println("debug:"+i);
				}
				
				if((validCnt>=fittingMinPoints || realPoints>=fittingMinPoints*0.8) && invalidRatio<maxInvalidRatio){
					lineCoef = extractLine.getLineCoef(false);
					currentLineOffset = (int)(lineCoef[0]*(imgWidth-1)+lineCoef[1]);
					slopeDelta = Math.abs(myBaselineSlope-extractLine.getLineSlope());
					if(-1==lastLineOffset){
						offsetDelta1 = minOffsetDelta*1.1;
						offsetDelta2 = offsetDelta1; offsetDelta3 = offsetDelta1;
					}else{
						offsetDelta1 = lineCoef[1]-lastLineOffset;
						offsetDelta2 = (lineCoef[0]-lastLineSlope)*imgWidth/2+lineCoef[1]-lastLineOffset;
						offsetDelta3 = (lineCoef[0]-lastLineSlope)*(imgWidth-1)+lineCoef[1]-lastLineOffset;
					}
					offsetDelta = (offsetDelta1+offsetDelta2+offsetDelta3)/3;
					
					if(maxValidCol-minValidCol>maxColDelta){
						validRate = extractLine.getValidRateByYAxis((maxValidCol+minValidCol)/2-1, (maxValidCol+minValidCol)/2+1);
					}else{
						validRate = 1.0;
					}
					
					if(null!=lineCoef && (ImgExtractLine.getMinRSQ()<=lineCoef[2] 
							|| (maxValidCol-minValidCol)<=maxColDelta 
							|| validRate>minValidRate) 
							&& (extractLines.size()>0 && currentLineOffset > 0
								|| extractLines.isEmpty() && currentLineOffset>=0)
							&& slopeDelta<maxSlopeDelta 
							&& offsetDelta1>minOffsetDelta/3 
							&& offsetDelta2>minOffsetDelta/3 
							&& offsetDelta3>minOffsetDelta/3
							&& offsetDelta>minOffsetDelta){
						for(int k=0; k<imgWidth; k++){
							nearCol = (int)(k*lineCoef[0]+lineCoef[1]);
							if(nearCol>noiseScanRng && nearCol<(imgHeight-noiseScanRng)){
								noisePoints = 0;
								for(int n=-noiseScanRng; n<=noiseScanRng; n++){
									if(peakVals[k][nearCol+n]<noiseGrayThr){
										if(Math.abs(n)>1){
											noisePoints++;
										}else{
											extractLine.addOnlinePoint();
										}
									}
								}
								if(noisePoints>0) extractLine.addSideNoise(noisePoints);
							}else{
								break;
							}
						}
						
						noiseRate = maxNoiseRate + 1.0;
						if(extractLine.getOnlinePoints()>0) noiseRate = (double)extractLine.getNoisePoints() / extractLine.getOnlinePoints();
						
						if(extractLine.getOnlinePoints()>=(fittingMinPoints*0.8) 
							&& (noiseRate<maxNoiseRate 
							|| noiseRate>=maxNoiseRate 
							&& validRate>=1.0 
							&& ImgExtractLine.getMinRSQ()<=lineCoef[2])){
							
							if(extractLines.isEmpty()) extractLine.getLineCoef(true);
							lastLineSlope = extractLine.getLineSlope();
							lastLineOffset = extractLine.getLineIntercept();
							
							saveSearchingLines(searchingLinesData,myBaselineSlope,myBaselineOffset,extractLines.size(),"found");
							
							myBaselineSlope = extractLine.getLineSlope();
							myBaselineOffset = extractLine.getLineIntercept()+1;
							
							currentLineOffset = (int)(myBaselineSlope*(imgWidth-1)+myBaselineOffset);
							i = currentLineOffset+lineSearchingRng;
							bLineFound = true;
							extractLine = setLineBoundary(extractLine, imgGrays, defaultVal);
							extractLines.add(extractLine.clone());
							if(targetLinesQty==extractLines.size()) finalSearchingOffset = i;
							System.out.println("Line found:"+myBaselineSlope+"/"+myBaselineOffset);
						}
					}
				}
				if(!bLineFound) myBaselineOffset = myBaselineOffset+1;
				
				if(allPossibleLines.size()>0) lastPossibleLine = allPossibleLines.get(allPossibleLines.size()-1);
				if(!bLineFound && validCnt>5 && 0==extractLine.getLineIntercept()) extractLine.getLineCoef(false);
				if(allPossibleLines.size()>0 && validCnt==lastPossibleLine.getValidPoints()
					&& extractLine.getLineIntercept()-lastPossibleLine.getLineIntercept()<5){
					if(bLineFound || extractLine.getLineRSQ()>lastPossibleLine.getLineRSQ()){
						if(!bLineFound) bLineFound = (3==lastPossibleLine.getLineFlag()?true:false);
						allPossibleLines.remove(allPossibleLines.size()-1);
						if(allPossibleLines.size()>0){
							lastPossibleLine = allPossibleLines.get(allPossibleLines.size()-1);
						}else{
							lastPossibleLine = null;
						}
					}
				}
				if(allPossibleLines.isEmpty() || allPossibleLines.size()>0
					&& (validCnt!=lastPossibleLine.getValidPoints()
						|| extractLine.getLineIntercept()-lastPossibleLine.getLineIntercept()>=5)){
					if(bLineFound) extractLine.setLineFlag(3);
					allPossibleLines.add(extractLine.clone());
				}
				
				if(targetLinesQty==extractLines.size()){
					if(i>=finalSearchingOffset+lineScanRange*6) break;
				}
			}
		}
		
		if(extractLines.size()>0) extractLines = adjustAllSearchedLines(allPossibleLines,extractLines,imgGrays,defaultVal);
		saveImgData("graysSortLines_",sortData);
		return extractLines;
	}
	
	private double[] getPoleOffset(ArrayList<ImgExtractLine> lines, int targetLinesQty){
		double[] poleOffset = new double[]{0.0,0.0};
		double oddPoleOffset = 0.0, evenPoleOffset = 0.0, tmpOffset = 0.0;
		double oddMin = 0.0, oddMax = 0.0, evenMin = 0.0, evenMax = 0.0;
		int oddPoleCnt = 1, evenPoleCnt = 1;
		
		if(null!=lines && lines.size()>2){
			oddPoleOffset = lines.get(1).getLineIntercept() - lines.get(0).getLineIntercept();
			evenPoleOffset = lines.get(2).getLineIntercept() - lines.get(1).getLineIntercept();
			oddMin = oddPoleOffset; oddMax = oddMin;
			evenMin = evenPoleOffset; evenMax = evenMin;
			if(lines.size()>3){
				for(int i=3; i<lines.size(); i++){
					tmpOffset = lines.get(i).getLineIntercept() - lines.get(i-1).getLineIntercept();
					if(1==i%2){
						oddPoleCnt++;
						oddPoleOffset += tmpOffset;
						if(oddMin>tmpOffset) oddMin = tmpOffset;
						if(oddMax<tmpOffset) oddMax = tmpOffset;
					}else{
						evenPoleCnt++;
						evenPoleOffset += tmpOffset;
						if(evenMin>tmpOffset) evenMin = tmpOffset;
						if(evenMax<tmpOffset) evenMax = tmpOffset;
					}
				}
			}
			if(oddPoleCnt>2){
				oddPoleOffset = (oddPoleOffset-oddMin-oddMax)/(oddPoleCnt-2);
			}else{
				oddPoleOffset = oddPoleOffset/oddPoleCnt;
			}
			if(evenPoleCnt>2){
				evenPoleOffset = (evenPoleOffset-evenMin-evenMax)/(evenPoleCnt-2);
			}else{
				evenPoleOffset = evenPoleOffset/evenPoleCnt;
			}
			poleOffset[0] = evenPoleOffset;
			poleOffset[1] = oddPoleOffset;
		}
		
		return poleOffset;
	}
	
	private double[] twoLinesAvgOffset(double slope1, double offset1, double slope2, double offset2, double startX, double stopX){
		double sumOffset = 0.0, avgOffset = 0.0, stepX = (startX+stopX)/10, dblTemp = 0.0;
		double minOffset = 0.0, maxOffset = 0.0, offsetFactor = 1.0;
		int counter = 0;
		
		if(startX>stopX){
			dblTemp = startX;
			startX = stopX;
			stopX = dblTemp;
		}
		
		if(0==stepX) stepX = 1.0;
		if(offset2>offset1) offsetFactor = -1.0;
		minOffset = Math.abs(offset2-offset1); maxOffset = minOffset;
		for(double x = startX; x<=stopX; x+=stepX){
			dblTemp = (slope1*x+offset1 - (slope2*x+offset2))*offsetFactor;
			sumOffset += dblTemp;
			counter++;
			if(minOffset>dblTemp) minOffset = dblTemp;
			if(maxOffset<dblTemp) maxOffset = dblTemp;
		}
		
		avgOffset = sumOffset / counter;
		
		return new double[]{avgOffset,minOffset,maxOffset};
	}
	
	private ArrayList<ImgExtractLine> adjustAllSearchedLines(ArrayList<ImgExtractLine> allPossibleLines,ArrayList<ImgExtractLine> extractLines,int[][] imgGrays,int defaultVal){
		double ratio = 0.0, bestRsq = 0.0, offsetDelta = 0.0, off2 = 0.0, ratio2 = 0.0, ratio3 = 0.0;
		double refOffset = 0.0, lastOffset = 0.0, nextOffset = -1.0, tmpOffset = 0.0;
		int bestIdx = 0, refValidPts = 0, lastFoundIdx = -1, size = 0, nextIdx = 0;
		int scanRng = lineScanRange/2, offsetCmpFlag = 0;
		boolean swapPoleOffset = false;
		ArrayList<ImgExtractLine> adjLines1 = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjLines2 = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjustLines = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjLines = new ArrayList<ImgExtractLine>();
		ImgExtractLine tmpLine = null, lastLine = null;
		
		//Step_1:Adjust the first found lines
		for(int idx=0; idx<allPossibleLines.size(); idx++){
			if(3!=allPossibleLines.get(idx).getLineFlag()) continue;
			refValidPts = allPossibleLines.get(idx).getValidPoints();
			refOffset = allPossibleLines.get(idx).getLineIntercept();
			bestRsq = allPossibleLines.get(idx).getLineRSQ();
			bestIdx = idx;
			for(int i=-scanRng; i<=scanRng; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(null!=tmpLine && Math.abs(refOffset-tmpLine.getLineIntercept())<5){
					ratio = (double)tmpLine.getValidPoints()/refValidPts;
					if(ratio>0.95 && bestRsq<tmpLine.getLineRSQ()){
						bestRsq = tmpLine.getLineRSQ();
						bestIdx = idx+i;
					}
				}
			}
			tmpLine = allPossibleLines.get(bestIdx);
			offsetDelta = tmpLine.getLineIntercept();
			if(null!=lastLine){
				offsetDelta -= lastLine.getLineIntercept();
				if(offsetDelta<=5){
					adjLines1.remove(adjLines1.size()-1);
					lastLine = null;
				}
			}
			if(null==lastLine || null!=lastLine && offsetDelta>5){
				if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, defaultVal);
				adjLines1.add(tmpLine);
				lastLine = tmpLine;
			}
		}
		
		//Step_2:Get all potential lines via peak searching method
		adjLines2 = adjustAllSearchedLinesEx(allPossibleLines,imgGrays,defaultVal);
		adjLines2 = doubleCheckAllPotentialLines(adjLines2,allPossibleLines);
		double[] poleOffset = getPoleOffset(adjLines2,targetLinesQty);
		
		//Step_3:Combine all lines from Step_1 and Step_2
		lastFoundIdx = -1;
		if(adjLines2.isEmpty()){
			for(int i=0; i<adjLines1.size(); i++){
				adjustLines.add(adjLines1.get(i));
			}
		}else{
			for(int i=0; i<adjLines1.size(); i++){//First found lines are more reliable(they are the base)
				bestIdx = -1;
				tmpLine = adjLines1.get(i);
				refOffset = tmpLine.getLineIntercept();
				
				if(12==adjustLines.size()){
					System.out.print("");
				}
				
				for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
					//Double confirm in all potential lines
					if(Math.abs(refOffset-adjLines2.get(j).getLineIntercept())<3){
						bestIdx = j;
						break;
					}
					if(adjLines2.get(j).getLineIntercept()-refOffset>3) break;
				}
				
				//TODO Verification
				if(bestIdx<0 && adjustLines.isEmpty() && adjLines2.size()>0){
					//Double check the most outer line
					double[] offs = twoLinesAvgOffset(tmpLine.getLineSlope(),tmpLine.getLineIntercept(),adjLines2.get(0).getLineSlope(),adjLines2.get(0).getLineIntercept(),0.0,imgGrays.length);
					if(offs[0]<3 && offs[1]<1) continue;
				}
				
				if(bestIdx>=0){
					if(lastFoundIdx<0 && bestIdx>0){//Suppose adjLines2 is reliable
						for(int j=0; j<bestIdx; j++){
							adjustLines.add(adjLines2.get(j));
							lastFoundIdx = j;
						}
					}
					
					//Found in potential lines
					if(lastFoundIdx>=0 && bestIdx-lastFoundIdx>1){
						//Confirm the missed potential lines
						if(adjustLines.size()>0) refOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
						for(int k=(lastFoundIdx+1);k<bestIdx;k++){
							if(adjLines2.get(k).getLineIntercept()<refOffset) continue;
							lastOffset = refOffset;
							if(k>0) lastOffset = adjLines2.get(k-1).getLineIntercept();
							offsetDelta = adjLines2.get(k+1).getLineIntercept()-adjLines2.get(k).getLineIntercept();
							if((adjLines2.get(k).getLineIntercept()-lastOffset>=5 || k<2 && adjLines2.get(k).getLineIntercept()-lastOffset>=3)
								&& offsetDelta>=5){
								ratio = (double)adjLines2.get(k).getValidPoints()/imgGrays.length;
								if(ratio>=minValidRatio){
									adjustLines.add(adjLines2.get(k));
								}else{
									off2 = adjLines2.get(k).getLineIntercept()-lastOffset;
									ratio = offsetDelta/off2;
									if(ratio<minOffsetChgRate || ratio>maxOffsetChgRate
										|| offsetDelta>5 && off2>5) adjustLines.add(adjLines2.get(k));
								}
							}
						}
					}
					lastFoundIdx = bestIdx;
					tmpLine = adjLines2.get(bestIdx);
				}else if(adjustLines.size()>0 && refOffset>adjLines2.get(0).getLineIntercept()){
					//Not found in potential lines(after the 1st found line)
					if(lastFoundIdx+1<adjLines2.size()){
						offsetDelta = refOffset-adjLines2.get(lastFoundIdx+1).getLineIntercept();
						if(offsetDelta>5){//First found line is behind the potential lines
							for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
								if(refOffset-adjLines2.get(j).getLineIntercept()>5){
									adjustLines.add(adjLines2.get(j));
									lastFoundIdx = j;
								}else{
									break;
								}
							}
						}else if(offsetDelta<=5){//First found line is very closed to the potential lines
							for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
								if(refOffset>adjLines2.get(j).getLineIntercept()){//Fetch the potential lines
									adjustLines.add(adjLines2.get(j));
									lastFoundIdx = j;
								}else{
									break;
								}
							}
						}
					}
					
					//Get next potential line
					nextOffset = -1.0; nextIdx = -1;
					for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
						if(adjLines2.get(j).getLineIntercept()>refOffset){
							nextOffset = adjLines2.get(j).getLineIntercept();
							nextIdx = j;
							break;
						}
					}
					
					//Offset change rate of the first found line
					ratio = -1.0; lastOffset = 0.0; ratio2 = -1.0;
					size = adjustLines.size();
					if(size>0){
						lastOffset = adjustLines.get(size-1).getLineIntercept();
						if(size>2){//Refer to previous data
							ratio = (refOffset - lastOffset)/(adjustLines.get(size-2).getLineIntercept()-adjustLines.get(size-3).getLineIntercept());
							ratio2 = (nextOffset - lastOffset)/(adjustLines.get(size-2).getLineIntercept()-adjustLines.get(size-3).getLineIntercept());
						}else if(nextIdx>0 && nextIdx+3<adjLines2.size()){
							ratio = (refOffset - lastOffset)/(adjLines2.get(nextIdx+3).getLineIntercept()-adjLines2.get(nextIdx+2).getLineIntercept());
							ratio2 = (nextOffset - lastOffset)/(adjLines2.get(nextIdx+3).getLineIntercept()-adjLines2.get(nextIdx+2).getLineIntercept());
						}else{
							if(1==adjustLines.size()%2){//Supposed the first found line is a missing potential line
								if(poleOffset[1]>0){
									ratio = (refOffset - lastOffset)/poleOffset[1];
									ratio2 = (nextOffset - lastOffset)/poleOffset[1];
								}
							}else{
								if(poleOffset[0]>0){
									ratio = (refOffset - lastOffset)/poleOffset[0];
									ratio2 = (nextOffset - lastOffset)/poleOffset[0];
								}
							}
						}
					}
					
					swapPoleOffset = true;
					offsetCmpFlag = offsetInSamePeak(allPossibleLines,refOffset,nextOffset,lastOffset);
					
					if(-1==offsetCmpFlag){
						continue;//Skip because the first found line is not in a valid peak region
					}else if(2==offsetCmpFlag){
						continue;//Skip because the first found line is in the valid peak region of last line
					}else if(1==offsetCmpFlag){
						tmpLine = adjLines2.get(nextIdx);//Replace the first found line with next potential line
						lastFoundIdx = nextIdx;
						swapPoleOffset = false;
					}else if(0==offsetCmpFlag){
						if(!(adjustLines.size()>2 && ratio>minOffsetChgRate)){
							ratio3 = (double)tmpLine.getValidPoints()/imgGrays.length;
							if(ratio3<minValidRatio) continue;
						}
						if(ratio<maxOffsetChgRate*0.6 && ratio2>0 && ratio2<maxOffsetChgRate) continue;
					}
					
					if(swapPoleOffset){
						tmpOffset = poleOffset[0];
						poleOffset[0] = poleOffset[1];
						poleOffset[1] = tmpOffset;
					}
				}
				if(adjustLines.isEmpty()) tmpLine.setLineChecked(true);//Fixed the 1st found layer
				adjustLines.add(tmpLine);
			}
		}
		
		//Step_4:Check whether all layers are found
		if(adjustLines.size()<targetLinesQty){
			refOffset = 0.0;
			if(adjustLines.size()>0) refOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
			for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
				if(adjLines2.get(j).getLineIntercept()>refOffset && adjustLines.size()<targetLinesQty){
					adjustLines.add(adjLines2.get(j));
				}
			}
		}
		
		LinkedHashMap<Double,Double> tendency = new LinkedHashMap<Double,Double>();
		double[] coef = null;
		for(int i=0; i<adjustLines.size(); i++){
			tmpLine = adjustLines.get(i);
			tmpLine.setLineIndex(i);
			tendency.put((double)i, tmpLine.getLineIntercept());
			if(tendency.size()<3){
				tmpLine.setTendencyRSQ(1.0);
			}else{
				coef = MathUtils.lineFitting(tendency);
				tmpLine.setTendencyRSQ(coef[2]);
			}
			if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, 255);
			
			//TODO Verification
			if(i<(targetLinesQty-3)) tmpLine.setLineChecked(true);
			
			adjLines.add(tmpLine);
			allPotentialLines.add(tmpLine);
		}
		
		//Add all potential lines
		if(adjLines2.size()>lastFoundIdx+1){
			refOffset = allPotentialLines.get(allPotentialLines.size()-1).getLineIntercept();
			for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
				if(adjLines2.get(j).getLineIntercept()>refOffset){
					allPotentialLines.add(adjLines2.get(j));
				}
			}
		}
		
		if(logEnabled){
			for(int i=0; i<adjustLines.size(); i++){
				tmpLine = adjustLines.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,0==i?true:false));
			}
			for(int i=0; i<adjLines2.size(); i++){
				tmpLine = adjLines2.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,false));
			}
			for(int i=0; i<extractLines.size(); i++){
				tmpLine = extractLines.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,false));
			}
			for(int i=0; i<allPossibleLines.size(); i++){
				tmpLine = allPossibleLines.get(i);
				LogUtils.rawLog("searchLineParas_", tmpLine.printLineParas(tmpLine.getLineFlag(),0==i?true:false));
			}
			logSelectedLinesGray(adjustLines,imgGrays,5);
		}
		
		return adjLines;
	}
	
	private void logSelectedLinesGray(ArrayList<ImgExtractLine> selectedLines, int[][] imgGrays, int grayScanRng){
		ImgExtractLine tmpLine = null;
		int imgWidth = imgGrays.length, imgHeight = imgGrays[0].length, col = 0;
		double lineSlope = 0.0, lineOffset = 0.0;
		String title = "LineIdx,Offset,Col,Edge1,Edge2,X", data = "";
		
		if(null!=selectedLines && selectedLines.size()>0){
			for(int i=0; i<imgWidth; i++){
				title += "," + i;
			}
			LogUtils.rawLog("selectedLinesXY_",title);
			for(int i=0; i<selectedLines.size(); i++){
				tmpLine = selectedLines.get(i);
				lineSlope = tmpLine.getLineSlope(); lineOffset = tmpLine.getLineIntercept();
				for(int j=-grayScanRng; j<=grayScanRng; j++){
					data = i + "," + lineOffset + "," + j + "," + tmpLine.getXAxisStop() + "," + tmpLine.getXAxisStart() + ",Y";
					for(int k=0; k<imgWidth; k++){
						col = (int)(lineSlope * k + lineOffset + j);
						if(col>=0 && col<imgHeight){
							data += "," + imgGrays[k][col];
						}else{
							data += ",255";
						}
					}
					LogUtils.rawLog("selectedLinesXY_",data);
				}
			}
		}
	}
	
	private boolean offsetInPeakRegion(ArrayList<ImgExtractLine> allPossibleLines, double chkOffset){
		boolean inPeakRegion = false;
		double minDelta = 0.0, offsetDelta = 0.0, ratio = 0.0;
		int mostCloseIdx = -1, scanRng = lineScanRange/2, counter = 0, minValidPts = 0;
		int size = allPossibleLines.size(), peakIdx = -1, maxValidPts = 0;
		
		if(size>0){
			//Get the index of chkOffset in allPossibleLines
			minDelta = Math.abs(allPossibleLines.get(0).getLineIntercept()-chkOffset);
			mostCloseIdx = 0;
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-chkOffset);
				if(minDelta>offsetDelta){
					minDelta = offsetDelta;
					mostCloseIdx = i;
				}
			}
			
			//Fine-tune the index of chkOffset
			peakIdx = -1; maxValidPts = 0;
			for(int i=-scanRng; i<=scanRng; i++){
				if(mostCloseIdx+i>=0 && mostCloseIdx+i<size){
					offsetDelta = Math.abs(allPossibleLines.get(mostCloseIdx+i).getLineIntercept()-chkOffset);
					if(offsetDelta<3){
						if(maxValidPts<allPossibleLines.get(mostCloseIdx+i).getValidPoints()){
							maxValidPts = allPossibleLines.get(mostCloseIdx+i).getValidPoints();
							peakIdx = mostCloseIdx+i;
						}
					}
				}
			}
			
			if(peakIdx>=0){
				//Possibility of being in the peak region
				counter = 0;
				for(int i=scanRng; i>0; i--){
					if(peakIdx-i>=0 && peakIdx+i<size){
						if(allPossibleLines.get(peakIdx).getValidPoints()>=allPossibleLines.get(peakIdx-i).getValidPoints()
							&& allPossibleLines.get(peakIdx).getValidPoints()>=allPossibleLines.get(peakIdx+i).getValidPoints()){
							counter++;
						}
					}
				}
				ratio = (double)counter/scanRng;
				if(ratio>0.66){
					//Check whether current peakIdx represents a valid peak or not
					maxValidPts = allPossibleLines.get(peakIdx).getValidPoints();
					minValidPts = maxValidPts;
					ratio = 0.0;
					//Get the base&max value in last 10 points
					for(int i=peakIdx; i>(peakIdx-10); i--){
						if(i<0) break;
						if(maxValidPts<allPossibleLines.get(i).getValidPoints()) maxValidPts = allPossibleLines.get(i).getValidPoints();
						if(minValidPts>allPossibleLines.get(i).getValidPoints()) minValidPts = allPossibleLines.get(i).getValidPoints();
					}
					if(maxValidPts>minValidPts) ratio = (double)(allPossibleLines.get(peakIdx).getValidPoints()-minValidPts)/(maxValidPts-minValidPts);
					if(ratio>0.2) inPeakRegion = true;
				}
			}
		}
		return inPeakRegion;
	}
	
	private int offsetInSamePeak(ArrayList<ImgExtractLine> allPossibleLines, double chkOffset, double nextOffset, double lastOffset){
		int rsltFlag = -1;
		double minDelta0 = 0.0, offsetDelta = 0.0, minDelta1 = 0.0, minDelta2 = 0.0;
		int chkIdx = -1, nextIdx = -1, lastIdx = -1;
		int size = allPossibleLines.size();
		int[] validPts = null, idx1 = null, idx2 = null;
		
		if(size>0 && chkOffset>0 && (nextOffset>0 || lastOffset>0)){
			minDelta0 = Math.abs(allPossibleLines.get(0).getLineIntercept()-chkOffset);
			minDelta1 = Math.abs(allPossibleLines.get(0).getLineIntercept()-nextOffset);
			minDelta2 = Math.abs(allPossibleLines.get(0).getLineIntercept()-lastOffset);
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-chkOffset);
				if(minDelta0>offsetDelta){
					minDelta0 = offsetDelta;
					chkIdx = i;
				}
				
				if(nextOffset>0){
					offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-nextOffset);
					if(minDelta1>offsetDelta){
						minDelta1 = offsetDelta;
						nextIdx = i;
					}
				}
				
				if(lastOffset>0){
					offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-lastOffset);
					if(minDelta2>offsetDelta){
						minDelta2 = offsetDelta;
						lastIdx = i;
					}
				}
			}
			
			validPts = getPossibleLinesValidDtPts(allPossibleLines);
			idx1 = MathUtils.getPeakCenterIndex(validPts, chkIdx, lineScanRange, true);
			if(idx1[0]>=0){
				rsltFlag = 0;
				if(nextIdx>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, nextIdx, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 1;
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(allPossibleLines.get(idx2[0]).getLineIntercept()-allPossibleLines.get(idx1[0]).getLineIntercept()<=lineScanRange/2) rsltFlag = 1;
						}
					}
				}
				if(0==rsltFlag && lastIdx>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, lastIdx, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 2;
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(allPossibleLines.get(idx1[0]).getLineIntercept()-allPossibleLines.get(idx2[0]).getLineIntercept()<=lineScanRange/2) rsltFlag = 2;
						}
					}
				}
			}
		}
		return rsltFlag;
	}
	
	private int offsetInSamePeakEx(ArrayList<ImgExtractLine> allPossibleLines, double offset1, double offset2){
		int rsltFlag = -1;//Not found in all possible lines
		double minDelta0 = 0.0, offsetDelta = 0.0, minDelta1 = 0.0;
		int index1 = -1, index2 = -1;
		int size = allPossibleLines.size();
		int[] validPts = null, idx1 = null, idx2 = null;
		
		if(size>0 && offset1>0 && offset2>0){
			minDelta0 = Math.abs(allPossibleLines.get(0).getLineIntercept()-offset1);
			minDelta1 = Math.abs(allPossibleLines.get(0).getLineIntercept()-offset2);
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-offset1);
				if(minDelta0>offsetDelta){
					minDelta0 = offsetDelta;
					index1 = i;
				}
				
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-offset2);
				if(minDelta1>offsetDelta){
					minDelta1 = offsetDelta;
					index2 = i;
				}
			}
			
			validPts = getPossibleLinesValidDtPts(allPossibleLines);
			idx1 = MathUtils.getPeakCenterIndex(validPts, index1, lineScanRange, true);
			if(idx1[0]>=0){
				rsltFlag = 0;//offset1 is found
				if(index2>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, index2, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 1;//offset1 and offset2 is in same peak
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(Math.abs(allPossibleLines.get(idx2[0]).getLineIntercept()-allPossibleLines.get(idx1[0]).getLineIntercept())<=lineScanRange/2) rsltFlag = 1;
						}
						
						if(0==rsltFlag && Math.abs(idx2[1]-idx1[1])<=2){
							rsltFlag = 2;//Left edge of offset1 and offset2 is the same
						}
					}
				}
			}
		}
		return rsltFlag;
	}
	
	private int[] getPossibleLinesValidDtPts(ArrayList<ImgExtractLine> allPossibleLines){
		int[] lineValidDataPts = new int[allPossibleLines.size()];
		for(int i=0; i<allPossibleLines.size(); i++){
			lineValidDataPts[i] = allPossibleLines.get(i).getValidPoints();
		}
		return lineValidDataPts;
	}
	
	private ArrayList<ImgExtractLine> roughCheckAllPotentialLines(ArrayList<ImgExtractLine> potentialLines){
		ArrayList<ImgExtractLine> newPotentialLines = new ArrayList<ImgExtractLine>();
		double currOffset = 0.0, nextOffset = 0.0;
		
		if(null!=potentialLines && potentialLines.size()>0){
			if(potentialLines.size()>1){
				for(int i=0; i<potentialLines.size()-1; i++){
					currOffset = potentialLines.get(i).getLineIntercept();
					nextOffset = potentialLines.get(i+1).getLineIntercept();
					if(currOffset>0 && currOffset<nextOffset){
						newPotentialLines.add(potentialLines.get(i));
					}
				}
				if(currOffset>0 && currOffset<nextOffset){
					newPotentialLines.add(potentialLines.get(potentialLines.size()-1));
				}
			}else{
				newPotentialLines = potentialLines;
			}
		}
		
		return newPotentialLines;
	}
	
	private ArrayList<ImgExtractLine> doubleCheckAllPotentialLines(ArrayList<ImgExtractLine> potentialLines, ArrayList<ImgExtractLine> allPossibleLines){
		ArrayList<ImgExtractLine> newPotentialLines = new ArrayList<ImgExtractLine>();
		
		potentialLines = roughCheckAllPotentialLines(potentialLines);
		if(null!=potentialLines && potentialLines.size()>0){
			int size = potentialLines.size(), newSize = 0;
			int currLineIdx = 0, lastLineIdx = 0;
			int peakFlags = -1;
			double ratio = 0.0;
			ImgExtractLine exLine = null;
			if(size<=1){
				newPotentialLines = potentialLines;
			}else{
				newPotentialLines.add(potentialLines.get(0));
				for(int i=1; i<size; i++){
					newSize = newPotentialLines.size();
					if(13==newSize){
						System.out.print("");
					}
					lastLineIdx = getLineIndex(allPossibleLines,newPotentialLines.get(newSize-1).getLineIntercept());
					currLineIdx = getLineIndex(allPossibleLines,potentialLines.get(i).getLineIntercept());
					if(lastLineIdx>0 && currLineIdx>lastLineIdx){
						if(newSize>2){//Check offset change rate of current line - see whether need to skip current line
							ratio = potentialLines.get(i).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
							ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
							if(ratio<maxOffsetChgRate*0.6){//Current line is very closed to last line
								ratio = (double)potentialLines.get(i).getValidPoints()/newPotentialLines.get(newSize-1).getValidPoints();
								if(ratio<0.2) continue;//Valid data points of current line is out of expectation
								
								peakFlags = offsetInSamePeakEx(allPossibleLines,newPotentialLines.get(newSize-1).getLineIntercept(),potentialLines.get(i).getLineIntercept());
								if(peakFlags>=1) continue;//Current line and last line is in the same peak
								
								if(i+1<size && newSize>2){//Double check next line
									ratio = potentialLines.get(i+1).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
									ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
									if(ratio<maxOffsetChgRate){
										if(ratio<maxOffsetChgRate*0.6){
											continue;//Next line is very close to last line, so skip current line
										}else if(newSize>4){
											ratio = potentialLines.get(i+1).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
											ratio = ratio/(newPotentialLines.get(newSize-4).getLineIntercept()-newPotentialLines.get(newSize-5).getLineIntercept());
											if(ratio<maxOffsetChgRate) continue;//Offset change rate btw next and last line lower than upper control limit is true
										}
									}
								}
							}
						}
						
						//Check whether there is line btw current and last line
						exLine = getPotentialLineBtw(allPossibleLines,lastLineIdx,currLineIdx,newPotentialLines.get(newSize-1).getValidPoints());
						
						if(null!=exLine){
							ratio = 1.0;
							if(newSize>2){
								ratio = exLine.getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
								ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
							}
							if(ratio>minOffsetChgRate) newPotentialLines.add(exLine);
						}
					}
					newPotentialLines.add(potentialLines.get(i));
				}
			}
		}
		
		return newPotentialLines;
	}
	
	private ImgExtractLine getPotentialLineBtw(ArrayList<ImgExtractLine> allPossibleLines,int startIdx,int stopIdx,int refValidDataPts){
		ImgExtractLine exLine = null;
		int validPts = 0, maxValidPts = -1, maxIdx = -1, peakFlag = 0;
		double ratio = 0.0, startOffset = 0.0, stopOffset = 0.0, foundOffset = 0.0;
		boolean startCheck = false, lineFound = false;
		if(null!=allPossibleLines && startIdx>0 && stopIdx>startIdx && stopIdx<allPossibleLines.size() && refValidDataPts>0){
			startOffset = allPossibleLines.get(startIdx).getLineIntercept();
			stopOffset = allPossibleLines.get(stopIdx).getLineIntercept();
			
			for(int i=startIdx; i<=stopIdx; i++){
				validPts = allPossibleLines.get(i).getValidPoints();
				ratio = (double)validPts/refValidDataPts;
				if(ratio<0.15){
					if(!startCheck){
						startCheck = true;
						maxValidPts = validPts;
						maxIdx = i;
					}else{
						ratio = (double)maxValidPts/refValidDataPts;
						if(ratio>0.2){
							lineFound = true;
							break;
						}
					}
				}
				if(startCheck){
					if(maxValidPts<validPts){
						maxValidPts = validPts;
						maxIdx = i;
					}
				}
			}
			
			if(lineFound){
				foundOffset = allPossibleLines.get(maxIdx).getLineIntercept();
				peakFlag = offsetInSamePeakEx(allPossibleLines,startOffset,foundOffset);
				if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,foundOffset,stopOffset);
				if(0==peakFlag) exLine = allPossibleLines.get(maxIdx);
			}
		}
		
		return exLine;
	}
	
	private int getLineIndex(ArrayList<ImgExtractLine> allPossibleLines, double lineOffset){
		int idx = -1;
		double offsetDelta = 0.0, minDelta = 10000.0;
		if(null!=allPossibleLines && allPossibleLines.size()>0){
			for(int i=0; i<allPossibleLines.size(); i++){
				offsetDelta = allPossibleLines.get(i).getLineIntercept() - lineOffset;
				if(offsetDelta<-5) continue;
				if(offsetDelta>5) break;
				
				offsetDelta = Math.abs(offsetDelta);
				if(minDelta>offsetDelta){
					minDelta = offsetDelta;
					idx = i;
				}
			}
		}
		return idx;
	}
	
	private int getMaxValidDataPtsLineIndex(ArrayList<ImgExtractLine> allPossibleLines, double startOffset, double stopOffset){
		int idx = -1, maxPts = 0;
		double lineOffset = 0.0;
		if(null!=allPossibleLines && allPossibleLines.size()>0){
			for(int i=0; i<allPossibleLines.size(); i++){
				lineOffset = allPossibleLines.get(i).getLineIntercept();
				if(lineOffset>stopOffset) break;
				if(lineOffset<startOffset) continue;
				if(maxPts<allPossibleLines.get(i).getValidPoints()){
					maxPts = allPossibleLines.get(i).getValidPoints();
					idx = i;
				}
			}
		}
		
		return idx;
	}
	
	private ArrayList<ImgExtractLine> adjustAllSearchedLinesEx(ArrayList<ImgExtractLine> allPossibleLines,int[][] imgGrays,int defaultVal){
		double ratio = 0.0, bestRsq = 0.0, refOffset = 0.0, lastOffset = 0.0, baseLine = 0.0, baseThr = 0.0;
		int bestIdx = 0, scanRng = lineScanRange/2, scanStart = -scanRng, scanStop = scanRng, maxVPts = 0, tmpVPts = 0;
		int lastBestIdx = 0, minValidPts = 0, basePts = 0, peakFlag = 0;
		ArrayList<ImgExtractLine> adjustLines = new ArrayList<ImgExtractLine>();
		ArrayList<Integer> maxValidPts = new ArrayList<Integer>();
		ArrayList<Integer> possLinesIdx = new ArrayList<Integer>();
		ImgExtractLine tmpLine = null;
		int[] lineValidDataPts = getPossibleLinesValidDtPts(allPossibleLines);
		
		LinkedHashMap<Integer,Integer> peaks = MathUtils.getPeakValsEx(lineValidDataPts, lineScanRange, true);
		
		for(int idx:peaks.keySet()){
			refOffset = allPossibleLines.get(idx).getLineIntercept();
			bestRsq = allPossibleLines.get(idx).getLineRSQ();
			maxVPts = allPossibleLines.get(idx).getValidPoints();
			bestIdx = idx;
			
			//Get peak index fine tune range
			for(int i=-scanRng; i>=0; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(0==tmpLine.getLineRSQ()) scanStart = i;
			}
			for(int i=0; i<=scanRng; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(0==tmpLine.getLineRSQ()) scanStop = i;
			}
			
			//Fine tune the peak index
			for(int i=scanStart; i<=scanStop; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(null!=tmpLine && Math.abs(refOffset-tmpLine.getLineIntercept())<5){
					tmpVPts = tmpLine.getValidPoints();
					ratio = (double)tmpVPts/peaks.get(idx);
					if(ratio>0.95 && bestRsq<tmpLine.getLineRSQ()){
						bestRsq = tmpLine.getLineRSQ();
						bestIdx = idx+i;
					}
					if(maxVPts<tmpVPts) maxVPts = tmpVPts;
				}
			}
			tmpLine = allPossibleLines.get(bestIdx);
			
			if(11==adjustLines.size()){
				System.out.print("");
			}
			
			ratio = 1.0;
			if(adjustLines.size()>1){
				lastOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
				tmpVPts = maxValidPts.get(maxValidPts.size()-1);
				if(tmpVPts>0){
					lastBestIdx = possLinesIdx.get(possLinesIdx.size()-1);
					minValidPts = tmpLine.getValidPoints();
					for(int k=lastBestIdx; k<=bestIdx; k++){
						if(minValidPts>allPossibleLines.get(k).getValidPoints()) minValidPts=allPossibleLines.get(k).getValidPoints();
					}
					if(tmpVPts!=minValidPts){
						baseThr = (tmpVPts-minValidPts)*0.2+minValidPts;
						baseLine = 0.0; basePts = 0;
						for(int k=lastBestIdx; k<=bestIdx; k++){
							if(allPossibleLines.get(k).getValidPoints()<baseThr){
								baseLine += allPossibleLines.get(k).getValidPoints();
								basePts++;
							}
						}
						if(basePts>0){
							baseLine = baseLine / basePts;
							ratio = (double)(tmpLine.getValidPoints()-baseLine)/(tmpVPts-baseLine);
						}else{
							ratio = (double)(tmpLine.getValidPoints()-minValidPts)/(tmpVPts-minValidPts);
						}
					}
				}
			}
			
			if(0==lastOffset || lastOffset>0 && tmpLine.getLineIntercept()-lastOffset>=5){
				if(lastOffset>0 && ratio<=0.2){
					peakFlag = offsetInSamePeakEx(allPossibleLines,lastOffset,refOffset);
					if(peakFlag>=1){
						continue;
					}else if(adjustLines.size()>3){
						ratio = (refOffset-lastOffset)/(adjustLines.get(adjustLines.size()-2).getLineIntercept()-adjustLines.get(adjustLines.size()-3).getLineIntercept());
						if(ratio<minOffsetChgRate) continue;
					}
				}
				if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, defaultVal);
				adjustLines.add(tmpLine);
				maxValidPts.add(maxVPts);
				possLinesIdx.add(bestIdx);
			}
		}
		
		return adjustLines;
	}
	
	private ImgExtractLine searchLine(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, double startSearchOffset, double stopSearchOffset, double mySearchSlope, int maxSearchRange){
		ImgExtractLine finalLine = null;
//		finalLine = getLineBtw(startSearchOffset,stopSearchOffset);
//		if(null!=finalLine){
//			if(0==finalLine.getXAxisStart()) finalLine = setLineBoundary(finalLine, imgGrays, defaultVal);
//			return finalLine;
//		}
		
		boolean bLineFound = false;
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int validCnt = 0, nearCol = 0, noisePoints = 0, realPoints = 0;
		int invalidCnt = 0, minValidCol = imgWidth*2, maxValidCol = -1;
		double noiseRate = 0.0, slopeDelta = 0.0, validRate = 0.0;
		double offsetDelta1 = 0.0, offsetDelta2 = 0.0, offsetDelta3 = 0.0, offsetDelta = 0.0;
		double invalidRatio = 0.0, maxColDelta = 3.0;
		int searchMinCol = 0, searchMaxCol = 0;
		int lineSearchingRng = lineScanRange / 2;//Two sides searching
		if(maxSearchRange<lineScanRange) lineSearchingRng = maxSearchRange/2;
		if(lineSearchingRng<=0) return null;
		
		int[][] searchingLinesData = new int[imgWidth][imgHeight];
		for(int i=0; i<imgWidth; i++){
			searchingLinesData[i] = peakVals[i].clone();
		}
		
		int fittingMinPoints = (int)(imgWidth * minValidRatio * 0.8);
		double[] lineCoef = null;
		finalLine = new ImgExtractLine();
		
		LinkedHashMap<Integer,ImgExtractLine> possibleLines = new LinkedHashMap<Integer,ImgExtractLine>();
		int possibleLineIdx = -1, bestValidRateIdx = -1;
		double bestValidRate = 0.0;
		
		if(stopSearchOffset>imgHeight) stopSearchOffset=imgHeight;
		if(imgWidth > fittingMinPoints && imgHeight > lineSearchingRng){
			for(int i=lineSearchingRng; i<=(maxSearchRange-lineSearchingRng); i++){
				minValidCol = imgWidth*2; maxValidCol = -1;
				ImgExtractLine extractLine = new ImgExtractLine();
				ImgExtractLine.setMinRSQ(0.7f);
				
				for(int j=(imgWidth-1); j>=0; j--){
					nearCol = (int)(j*mySearchSlope+startSearchOffset)+i;
					searchMinCol = (int)(j*mySearchSlope+startSearchOffset);
					searchMaxCol = (int)(j*mySearchSlope+stopSearchOffset);
					if(searchMinCol<0 || searchMinCol>(imgHeight-1)) continue;
					if(searchMaxCol<0 || searchMaxCol>(imgHeight-1)) continue;
					
					if((nearCol-lineSearchingRng)>=0 && nearCol<=(searchMaxCol-lineSearchingRng)){
						for(int k=-lineSearchingRng; k<=lineSearchingRng; k++){
							if(peakVals[j][nearCol+k]<lineFitGrayThr){
								extractLine.addPoint(j, nearCol+k, peakVals[j][nearCol+k]);
								if((nearCol+k)<minValidCol) minValidCol = nearCol+k;
								if((nearCol+k)>maxValidCol) maxValidCol = nearCol+k;
								if(Math.abs(k)<=1) extractLine.addRealPoints(j, nearCol+k, 1);
							}
							if(imgGrays[j][nearCol+k]>=noiseGrayThr) extractLine.addInvalidPoints(1);
						}
					}
				}
				
				if(i>=lineSearchingRng){
//					saveSearchingLines(searchingLinesData,mySearchSlope,startSearchOffset,i+500);
				}
				
				validCnt = extractLine.getValidPoints();
				realPoints = extractLine.getRealPoints();
				invalidCnt = extractLine.getInvalidPoints();
				invalidRatio = (double)invalidCnt / (lineSearchingRng*2+1) / imgWidth;
				if((validCnt>=fittingMinPoints 
						|| maxSearchRange<=3 
						|| realPoints>=fittingMinPoints*0.8) 
						&& invalidRatio<maxInvalidRatio){
					lineCoef = extractLine.getLineCoef(false);
					slopeDelta = Math.abs(mySearchSlope-extractLine.getLineSlope());
					offsetDelta1 = lineCoef[1] - startSearchOffset;
					offsetDelta2 = (lineCoef[0]-mySearchSlope)*imgWidth/2+lineCoef[1]-startSearchOffset;
					offsetDelta3 = (lineCoef[0]-mySearchSlope)*(imgWidth-1)+lineCoef[1]-startSearchOffset;
					offsetDelta = (offsetDelta1+offsetDelta2+offsetDelta3)/3;
					
					if(maxValidCol-minValidCol>maxColDelta){
						validRate = extractLine.getValidRateByYAxis((maxValidCol+minValidCol)/2-1, (maxValidCol+minValidCol)/2+1);
					}else{
						validRate = 1.0;
					}
					
					if(slopeDelta<maxSlopeDelta 
							&& offsetDelta1>0 && offsetDelta2>0 && offsetDelta3>0 
							&& offsetDelta>minOffsetDelta*0.5){
						possibleLineIdx++;
						possibleLines.put(possibleLineIdx, extractLine);
						if(bestValidRate<validRate){
							bestValidRate = validRate;
							bestValidRateIdx = possibleLineIdx;
						}
					}
					
					if(null!=lineCoef && (ImgExtractLine.getMinRSQ()<=lineCoef[2] 
							|| (maxValidCol-minValidCol)<=maxColDelta 
							|| validRate>minValidRate) 
							&& slopeDelta<maxSlopeDelta 
							&& offsetDelta1>0 && offsetDelta2>0 && offsetDelta3>0
							&& offsetDelta>minOffsetDelta*0.5){
						for(int k=0; k<imgWidth; k++){
							nearCol = (int)(k*lineCoef[0]+lineCoef[1]);
							if(nearCol>noiseScanRng && nearCol<(imgHeight-noiseScanRng)){
								noisePoints = 0;
								for(int n=-noiseScanRng; n<=noiseScanRng; n++){
									if(peakVals[k][nearCol+n]<noiseGrayThr){
										if(Math.abs(n)>1){
											noisePoints++;
										}else{
											extractLine.addOnlinePoint();
										}
									}
								}
								if(noisePoints>0) extractLine.addSideNoise(noisePoints);
							}else{
								break;
							}
						}
						
						noiseRate = (double)extractLine.getNoisePoints() / extractLine.getOnlinePoints();
						if(extractLine.getOnlinePoints()>=(fittingMinPoints*0.8) 
							&& noiseRate<maxNoiseRate){
							
							extractLine = setLineBoundary(extractLine, imgGrays, defaultVal);
							finalLine = extractLine;
							bLineFound = true;
							break;
						}
					}
				}
			}
		}
		
		if(!bLineFound){
			if(possibleLines.size()>0 && bestValidRateIdx>=0){
				finalLine = possibleLines.get(bestValidRateIdx);
				finalLine = setLineBoundary(finalLine, imgGrays, defaultVal);
			}else{
				finalLine = null;
			}
		}
		
		if(null!=finalLine){
			if(logEnabled){
				LogUtils.rawLog("researchLineParas_", finalLine.printLineParas(0,true));
			}
		}
		
		return finalLine;
	}
	
	private LinkedHashMap<Integer,Double> getSharpChgPosition(double[] chgs){
		LinkedHashMap<Integer, Double> sharpChgPos = new LinkedHashMap<Integer, Double>();
		
		int col = chgs.length;
		int scanPoints = 4;//Two sides scanning
		int meatCndCnt = 0;
		if(col>8){
			for(int j=scanPoints; j<(col-scanPoints); j++){
				meatCndCnt = 0;
				for(int k=scanPoints; k>0; k--){
					if(0!=chgs[j] && chgs[j]<=chgs[j-k] && chgs[j]<=chgs[j+k]){
						meatCndCnt++;
					}
				}
				if(meatCndCnt==scanPoints){
					sharpChgPos.put(j, chgs[j]);
					j += scanPoints;
				}
			}
		}
		
		return sharpChgPos;
	}
	
	private void setLinesSharpChgPosition(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, int targetLinesQty){
		ImgExtractLine extLine = null;
		double lineSlope, lineOffset, stdevRatio = 0.0;
		double[] Xs = new double[10], Ys = new double[10], chgs = null, tmp = null;
		int firstChgPos = 0, nearCol = 0, imgHeight = imgGrays[0].length, size = 0;
		int start = -1, stop = -1, chgStopPos = 0;
		int[] grays = null;
		String str1 = "", str2 = "";
		String[] sGrays = new String[11];
		
		for(int lineIdx:linesMap.keySet()){
			extLine = linesMap.get(lineIdx);
			if(null!=extLine){
				lineSlope = extLine.getLineSlope();
				lineOffset = extLine.getLineIntercept()+extLine.getLineInterceptDelta();
				firstChgPos = extLine.getXAxisStart()+10;
				chgStopPos = extLine.getXAxisStop();
				chgs = new double[firstChgPos];
				grays = new int[firstChgPos];
				str1 = ""; str2 = "";
				for(int k=0; k<11; k++){
					sGrays[k] = "";
				}
				
				for(int i=firstChgPos; i>0;i--){
					size = 0;
					for(int k=0; k<10; k++){
						nearCol = (int)(k*lineSlope+lineOffset);
						if(nearCol>=0 && nearCol<imgHeight){
							try {
								Xs[k] = i + k;
								Ys[k] = imgGrays[(int)Xs[k]][nearCol];
								size++;
							} catch (Exception e) {
								System.out.println(Xs[k]+":"+i+"/"+k);
							}
						}
					}
					tmp = MathUtils.lineFitting(Xs, Ys, size);
					chgs[i-1] = tmp[0];
					nearCol = (int)(i*lineSlope+lineOffset);
					if(nearCol>=0 && nearCol<imgHeight){
						if(i<imgGrays.length) grays[i-1] = imgGrays[i][nearCol];
					}
					for(int k=-5; k<=5; k++){
						if((nearCol+k)>=0 && (nearCol+k)<imgHeight && i<imgGrays.length){
							sGrays[k+5] += "," + imgGrays[i][nearCol+k];
						}else{
							sGrays[k+5] += ",0";
						}
					}
					
					str1 += "," + i;
					str2 += "," + chgs[i-1];
				}
				
				LinkedHashMap<Integer,Double> sharpChgPos = getSharpChgPosition(chgs);
				LinkedHashMap<Integer,LinkedHashMap<SharpChgItems,Double>> sharpChgPosParas = new LinkedHashMap<Integer,LinkedHashMap<SharpChgItems,Double>>();
				size = -1;
				for(int key:sharpChgPos.keySet()){
					size++;
					if(start<0){
						start = key;
						continue;
					}else{
						stop = key;
					}
					LinkedHashMap<SharpChgItems,Double> statisticParas = new LinkedHashMap<SharpChgItems,Double>();
					tmp = extLine.getLineStatisticParas(linesMap, start, (start+stop)/2, imgGrays, lineIdx, evenLineLonger);
					stdevRatio = tmp[3];
					if(1==size){
						LinkedHashMap<SharpChgItems,Double> sttParas = new LinkedHashMap<SharpChgItems,Double>();
						double[] weightOfBeingLine = extLine.weightOfBeingLine(linesMap,firstChgPos-10, chgStopPos, 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, true, curLineIsLonger(lineIdx,evenLineLonger), false);
						sttParas.put(SharpChgItems.STDEV, tmp[3]);
						sttParas.put(SharpChgItems.STDEVRATIO, weightOfBeingLine[0]);
						sttParas.put(SharpChgItems.AREARATIO, tmp[4]);
						
						tmp = extLine.getLineStatisticParas(linesMap, firstChgPos-10, chgStopPos, imgGrays, lineIdx, evenLineLonger);
						sttParas.put(SharpChgItems.INNERGRAYRATIO, tmp[5]);
						sharpChgPosParas.put(start, sttParas);
					}
					tmp = extLine.getLineStatisticParas(linesMap, (start+stop)/2, stop, imgGrays, lineIdx, evenLineLonger);
					stdevRatio = tmp[3] / stdevRatio;
					
					statisticParas.put(SharpChgItems.STDEV, tmp[3]);
					statisticParas.put(SharpChgItems.STDEVRATIO, stdevRatio);
					statisticParas.put(SharpChgItems.AREARATIO, tmp[4]);
					statisticParas.put(SharpChgItems.INNERGRAYRATIO, tmp[5]);
					sharpChgPosParas.put(key, statisticParas);
					start = key;
				}
				extLine.setSharpChgPos(sharpChgPos);
				extLine.setSharpChgPosParas(sharpChgPosParas);
				
				if(logEnabled){
					LogUtils.rawLog("sharpChgGrays_", "X"+lineIdx+str1);
					LogUtils.rawLog("sharpChgGrays_", "S"+lineIdx+str2);
					for(int k=-5; k<=5; k++){
						LogUtils.rawLog("sharpChgGrays_", "G"+lineIdx+"("+k+")"+sGrays[k+5]);
					}
					LogUtils.rawLog("sharpChgPos_", extLine.printSharpChgPos(lineIdx));
				}
			}
		}
	}
	
	private double boundaryNewThreshold(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal, int boundaryIdx, int dblCfmDataPts){
		int imgWidth = imgGrays.length;
		int imgHeight = imgGrays[0].length;
		int counter1 = 0, nearCol = 0;
		
		double sumGray1 = 0.0, grayThr1 = lineFitGrayThr;
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		
		for(int k=boundaryIdx; k<imgWidth; k++){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(k<0 || nearCol<0 || nearCol>=imgHeight) continue;
			if(imgGrays[k][nearCol]<noiseGrayThr){
				counter1++;
				sumGray1 += imgGrays[k][nearCol];
			}
			if(counter1>=dblCfmDataPts) break;
		}
		if(counter1>0){
			grayThr1 = sumGray1 / counter1;
			grayThr1 = grayThr1 + (defaultVal - grayThr1)*0.25;
		}
		
		return grayThr1;
	}
	
	private boolean boundaryIsOK(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal, int boundaryIdx, int backwardPts, double grayThr1){
		boolean ok = false;
		int imgHeight = imgGrays[0].length;
		int nearCol = 0, continueCnt1 = 0;
		
		double minGray = 0.0;
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		
		for(int k=boundaryIdx; k>=boundaryIdx-backwardPts; k--){
			if(k<0) break;
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			
			//Check +/-1 tracks
			minGray = imgGrays[k][nearCol];
			if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
			if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
			
			if(minGray<grayThr1){
				if(continueCnt1<5) continueCnt1 = 0;
			}else{
				continueCnt1++;
			}
		}
		
		if(continueCnt1>=5) ok = true;
		return ok;
	}
	
	private ImgExtractLine setLineBoundary(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal){
		int imgWidth = imgGrays.length;
		int imgHeight = imgGrays[0].length;
		int start = (int)(imgWidth*0.5);
		int counter1 = 0, counter2 = 0, nearCol = 0, contCntThr = 5;
		int continueCnt1 = 0, continueCnt2 = 0, minGray = 0, continueCnt3 = 0;
		double sumGray1 = 0.0, grayThr1 = lineFitGrayThr, newGrayThr1 = grayThr1;
		double sumGray2 = 0.0, grayThr2 = lineFitGrayThr, meanGray2 = 150.0, grayThr3 = noiseGrayThr2;
		
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		for(int k=start; k<imgWidth; k++){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			if(imgGrays[k][nearCol]<noiseGrayThr){
				counter1++;
				sumGray1 += imgGrays[k][nearCol];
			}
		}
		if(counter1>0){
			grayThr1 = sumGray1 / counter1;
			grayThr1 = grayThr1 + (defaultVal - grayThr1)*0.25;
		}
		
		for(int k=start; k>=0; k--){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			
			//Check +/-1 tracks
			minGray = imgGrays[k][nearCol];
			if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
			if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
			
			if(minGray<grayThr1){
				if(continueCnt1<contCntThr) continueCnt1 = 0;//Reset only when the X Axis Start is not found
			}else{
				continueCnt1++;
			}
			if(contCntThr==continueCnt1){
				newGrayThr1 = boundaryNewThreshold(extractLine,imgGrays,defaultVal,k+contCntThr,30);//Renew the threshold for a double confirmation
				if(boundaryIsOK(extractLine,imgGrays,defaultVal,k+contCntThr,contCntThr+2,newGrayThr1)){
					extractLine.setXAxisStart(k+contCntThr);
					extractLine.setMeanGray((int)grayThr1);
				}else{
					grayThr1 = newGrayThr1;
					continueCnt1 = 0;
				}
			}
			
			//To find X Axis Stop after X Axis Start is found
			if(contCntThr<=continueCnt1){
				counter2++;
				sumGray2 += imgGrays[k][nearCol];
				meanGray2 = sumGray2 / counter2;
				grayThr2 = (meanGray2 + defaultVal) / 2;
				
				minGray = imgGrays[k][nearCol];
				if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
				if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
				
				if(minGray>=grayThr2){
					continueCnt2++;
				}else{
					if(continueCnt2<contCntThr) continueCnt2=0;
				}
				
				if(minGray>=grayThr3){
					continueCnt3++;
				}else{
					if(continueCnt3<contCntThr) continueCnt3=0;
				}
				
				if(contCntThr<=continueCnt2 || contCntThr<=continueCnt3){
					extractLine.setXAxisStop(k+contCntThr);
					break;
				}
			}
		}
		
		return extractLine;
	}
	
	private ImgExtractLine getBaseLine(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int continueCnt = 0, minHeight = imgHeight, maxHeight = 0;
		int startY = 0, stopY = 0, contCntThr = 5, baseAvgPts = 10;
		int[][] startLine = new int[imgWidth][imgHeight];
		double baseGVal = 0.0, baseFactor = 0.9;
		String title = "", data = "";
		
		for(int i=0; i<imgWidth; i++){
			startLine[i] = imgGrays[i].clone();
		}
		
		int nearCol = 0;
		ImgExtractLine extractLine = new ImgExtractLine();
		LinkedHashMap<Integer,Integer> baseLineXY = new LinkedHashMap<Integer,Integer>();
		
		for(int i=(imgWidth-1); i>(int)(imgWidth*0.45); i-=10){
			continueCnt = 0; baseGVal = 0.0;
			for(int j=0; j<baseAvgPts; j++){
				baseGVal += imgGrays[i][j];
			}
			baseGVal = baseGVal / baseAvgPts * baseFactor;
			
			for(int j=baseAvgPts; j<imgHeight; j++){
				if(imgGrays[i][j]<baseGVal){
					continueCnt++;
				}else{
					baseGVal = 0.0;
					for(int k=j; k>j-baseAvgPts; k--){
						baseGVal += imgGrays[i][k];
					}
					baseGVal = baseGVal / baseAvgPts * baseFactor;
					continueCnt = 0;
				}
				if(continueCnt>=contCntThr){
					if(minHeight>(j-contCntThr)) minHeight = j-contCntThr;
					if(maxHeight<(j-contCntThr)) maxHeight = j-contCntThr;
					extractLine.addPoint(i, j-contCntThr, imgGrays[i][j-contCntThr]);
					baseLineXY.put(i, j-contCntThr);
					break;
				}
			}
		}
		extractLine.getLineCoef(false);
		
		//Fetch base line raw data
		if(logEnabled){
			if(baseLineXY.size()>0){
				startY = minHeight - 20;
				stopY = maxHeight + 30;
				if(startY<0) startY = 0;
				if(stopY>=imgHeight) stopY = imgHeight - 1;
				
				title = "x,y,rawY";
				for(int y=startY; y<=stopY; y++){
					title += "," + y;
				}
				LogUtils.rawLog("baseLineXY_",title);
				for(Integer key:baseLineXY.keySet()){
					data = key + "," + baseLineXY.get(key) + ",gray";
					for(int y=startY; y<=stopY; y++){
						data += "," + imgGrays[key][y];
					}
					LogUtils.rawLog("baseLineXY_",data);
				}
			}
			
			double startLineSlope = extractLine.getLineSlope();
			double startLineOffset = extractLine.getLineIntercept();
			for(int k=0; k<imgWidth; k++){
				nearCol = (int)(k*startLineSlope+startLineOffset);
				if(nearCol>=0 && nearCol<imgHeight) startLine[k][nearCol] = 0;
			}
			saveImgData("graysStartLine_",startLine);
		}
		
		return extractLine;
	}
	
	private ImgExtractLine getBaseLineBackup(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int continueCnt = 0, minHeight = imgHeight, maxHeight = 0;
		int startY = 0, stopY = 0;
		int[][] startLine = new int[imgWidth][imgHeight];
		String title = "", data = "";
		
		for(int i=0; i<imgWidth; i++){
			startLine[i] = imgGrays[i].clone();
		}
		
		int nearCol = 0;
		ImgExtractLine extractLine = new ImgExtractLine();
		LinkedHashMap<Integer,Integer> baseLineXY = new LinkedHashMap<Integer,Integer>();
		
		for(int i=(imgWidth-1); i>(int)(imgWidth*0.45); i-=10){
			continueCnt = 0;
			for(int j=0; j<imgHeight; j++){
				if(imgGrays[i][j]<noiseGrayThr2){
					continueCnt++;
				}else{
					continueCnt = 0;
				}
				if(continueCnt>10){
					if(minHeight>(j-10)) minHeight = j-10;
					if(maxHeight<(j-10)) maxHeight = j-10;
					extractLine.addPoint(i, j-10, imgGrays[i][j-10]);
					baseLineXY.put(i, j-10);
					break;
				}
			}
		}
		
		//Fetch base line raw data
		if(baseLineXY.size()>0){
			startY = minHeight - 20;
			stopY = maxHeight + 30;
			if(startY<0) startY = 0;
			if(stopY>=imgHeight) stopY = imgHeight - 1;
			
			title = "x,y,rawY";
			for(int y=startY; y<=stopY; y++){
				title += "," + y;
			}
			LogUtils.rawLog("baseLineXY_",title);
			for(Integer key:baseLineXY.keySet()){
				data = key + "," + baseLineXY.get(key) + ",gray";
				for(int y=startY; y<=stopY; y++){
					data += "," + imgGrays[key][y];
				}
				LogUtils.rawLog("baseLineXY_",data);
			}
		}
		
		extractLine.getLineCoef(false);
		double startLineSlope = extractLine.getLineSlope();
		double startLineOffset = extractLine.getLineIntercept();
		for(int k=0; k<imgWidth; k++){
			nearCol = (int)(k*startLineSlope+startLineOffset);
			if(nearCol>=0 && nearCol<imgHeight) startLine[k][nearCol] = 0;
		}
		saveImgData("graysStartLine_",startLine);
		
		return extractLine;
	}
	
	private int[][] getPeakVals(int[][] imgGrays, int[][] initVals){
		int[][] peakVals = null;
		if(null != imgGrays){
			int row = imgGrays.length;
			int col = imgGrays[0].length;
			int scanPoints = 3;//Two sides scanning
			int positiveCnt = 0, negativeCnt = 0;
			peakVals = new int[row][col];
			if(col>5){
				for(int i=0; i<row; i++){
					peakVals[i] = initVals[i].clone();
					for(int j=scanPoints; j<col; j++){
						if((j+scanPoints)<col){
							positiveCnt = 0;
							negativeCnt = 0;
							for(int k=scanPoints; k>0; k--){
								if(imgGrays[i][j]>imgGrays[i][j-k] && imgGrays[i][j]>imgGrays[i][j+k]){
									positiveCnt++;
								}
								
								if(imgGrays[i][j]<imgGrays[i][j-k] && imgGrays[i][j]<imgGrays[i][j+k]){
									negativeCnt++;
								}
							}
							if(negativeCnt==scanPoints){
								peakVals[i][j] = imgGrays[i][j];
								j += scanPoints;
							}
							if(positiveCnt==scanPoints) j += scanPoints;
						}else{
							break;
						}
					}
				}
			}
		}
		
		if(null!=peakVals) saveImgData("graysPeakVals_",peakVals);
		return peakVals;
	}
	
	private void saveImgData(String filePrefix, int[][] data){
		if(logEnabled){
			int width = data.length;
			int height = data[0].length;
			String str = "";
			
	    	for (int i = 0; i < width; i++) {
	        	str = "";
	            for (int j = (height-1); j >= 0; j--) {
	                str += data[i][j]+",";
	            }
	            LogUtils.rawLog(filePrefix,str);
	        }
		}
	}
	
	private void saveSearchingLines(int[][] data, double slope, double offset, int index, String flag){
		if(logEnabled){
			int imgWidth = data.length, imgHeight = data[0].length, nearCol = 0;
			for(int k=0; k<imgWidth; k++){
				nearCol = (int)(k*slope+offset);
				if(nearCol>=0 && nearCol<imgHeight){
					if(data[k][nearCol]>230) data[k][nearCol] = 0;
				}
			}
			saveImgData("graysSeachingLine_"+flag+"_"+index+"_",data);
		}
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:50.990
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:50.990
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:50.990
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:50.993
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:50.993
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:51.013
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:597)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:51.015
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:597)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:51.029
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:51.031
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:52.140
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:52.143
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:52.160
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:898)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:767)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:716)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:639)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:631)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2019-03-31 15:09:52.162
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1215)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:898)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:767)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:716)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:639)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:631)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2019-03-31 15:09:55.015
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.sto.utils;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashMap;

import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.stream.ImageOutputStream;

import com.sto.base.PolePositionItems;
import com.sto.base.SharpChgItems;
import com.sto.data.ImgExtractLine;
import com.sto.data.ProductSpec;

public class ImageUtils {
	//Judge Criteria
	private final double minValidRatio = 0.15;//Very depending on the image quality
	private final double minValidRate = 0.7;//Check it in +/-1 line
	private final double maxInvalidRatio = 0.4;//There should be no much white area around the line
	private final double maxSlopeDelta = 0.1;//The lines should be parallel
	private final double minOffsetDelta = 3.0;//There should be some distance between two near line
	private final double maxNoiseRate = 0.4;//There should be no much noise around the line
	private final double maxOffsetChgRate = 1.4;//Check whether some line is missed
	private final double minOffsetChgRate = 0.7;//Check whether there is noise line
	private final int noiseScanRng = 2;//Two sides scanning
	private final int lineScanRange = 6;//One side scanning
	private int targetLinesQty = 16;//The total lines to extract
	private double lineFitGrayThr = 255 * 0.8;
	private final double noiseGrayThr = 255 * 0.9;
	private final double noiseGrayThr2 = 255 * 0.95;
	private final double noiseGrayThr3 = 255 * 0.15;
	private final double minBestRsq = 0.991;
	private final int lineIndexBase = 100;
	private boolean firstPoleIsLonger = false;
	private boolean firstPoleIsThicker = true;
	
	private int[][] finalData = null;
	private boolean logEnabled = true;
	private boolean evenPoleIsLonger = false;
	private long imgProcTime = 0;
	private long imgStartSavingT = 0;
	
	private ProductSpec productSpec = ProductSpec.getInstance();
	private LinkedHashMap<String, Object> criteria = null;
	
	private ArrayList<ImgExtractLine> allPossibleLines = new ArrayList<ImgExtractLine>();
	private ArrayList<ImgExtractLine> allPotentialLines = new ArrayList<ImgExtractLine>();
	private LinkedHashMap<String, Double> imgProcResultLength = new LinkedHashMap<String, Double>();
	private LinkedHashMap<String, Boolean> imgProcResultOK = new LinkedHashMap<String, Boolean>();
	private LinkedHashMap<String, Double> imgProcResultAngle = new LinkedHashMap<String, Double>();
	private LinkedHashMap<String, String> imgProcResultStr = new LinkedHashMap<String, String>();
	
	private void clearMemory(){
		allPossibleLines.clear();
		allPotentialLines.clear();
		imgProcResultLength.clear();
		imgProcResultOK.clear();
		imgProcResultAngle.clear();
	}
	
	public void setLogEnabled(boolean enabled){
		logEnabled = enabled;
	}
	
	public long getImgProcTime(){
		return imgProcTime;
	}
	
	public long getImgStartSavingTime(){
		return imgStartSavingT;
	}
	
	private PolePositionItems getPolePositionInImage(BufferedImage BI){
		PolePositionItems polePosition = PolePositionItems.TOPLEFT;
		int imgWidth = BI.getWidth(), imgHeight = BI.getHeight();
		int[] fourCornersGray = new int[4];
        int pixel = 0, minGray = 0, minGrayIdx = 0;
        
        int start = (int)(imgHeight*0.25), stop = start-10;
        int width = (int)(imgWidth*0.25);
        for(int height=start; height>stop; height--){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[0] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.25); stop = start-10;
        width = (int)(imgWidth*0.75);
        for(int height=start; height>stop; height--){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[1] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.75); stop = start+10;
        width = (int)(imgWidth*0.75);
        for(int height=start; height<stop; height++){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[2] += (pixel & 0xffffff - 0xffff00);
        }
        
        start = (int)(imgHeight*0.75); stop = start+10;
        width = (int)(imgWidth*0.25);
        for(int height=start; height<stop; height++){
        	pixel = BI.getRGB(width, height);
        	fourCornersGray[3] += (pixel & 0xffffff - 0xffff00);
        }
		
        minGray = fourCornersGray[0];
        minGrayIdx = 0;
        for(int i=0; i<fourCornersGray.length; i++){
        	if(fourCornersGray[i]<minGray){
        		minGray = fourCornersGray[i];
        		minGrayIdx = i;
        	}
        }
        
        switch(minGrayIdx){
        case 0:
        	polePosition = PolePositionItems.TOPLEFT;
        	break;
        case 1:
        	polePosition = PolePositionItems.TOPRIGHT;
        	break;
        case 2:
        	polePosition = PolePositionItems.BOTTOMRIGHT;
        	break;
        case 3:
        	polePosition = PolePositionItems.BOTTOMLEFT;
        	break;
        }
        
		return polePosition;
	}
	
	private LinkedHashMap<PolePositionItems,Integer> getLayersQty(){
		LinkedHashMap<PolePositionItems,Integer> layers = new LinkedHashMap<PolePositionItems,Integer>();
		
		layers.put(PolePositionItems.BOTTOMRIGHT, 
				Integer.parseInt(""+criteria.get("lowerRightCornerLayers")));
		
		layers.put(PolePositionItems.BOTTOMLEFT, 
				Integer.parseInt(""+criteria.get("lowerLeftCornerLayers")));
		
		layers.put(PolePositionItems.TOPRIGHT, 
				Integer.parseInt(""+criteria.get("topRightCornerLayers")));
		
		layers.put(PolePositionItems.TOPLEFT, 
				Integer.parseInt(""+criteria.get("topLeftCornerLayers")));
		
		return layers;
	}
	
	private void setFirstPoleConfig(){
		String c1 = (String) criteria.get("firstPoleIsShorter");
		String c2 = (String) criteria.get("firstPoleIsThicker");
		
		if(null!=c1) firstPoleIsLonger = (1==Integer.parseInt(c1)?false:true);
		if(null!=c2) firstPoleIsThicker = (1==Integer.parseInt(c2)?true:false);
	}
	
	private ArrayList<Object> edgeFoundParas(BufferedImage BI, PolePositionItems polePosition, double baseFactor, int layersQty, boolean searchWidth, int grapWidthStart, int grapWidthStop
		, int i, int baseAvgPts, int searchStart, int searchStop, int searchPos, int continueCnt1
		, int continueCntThr, int backOffPixels
		, double currGray, double baseGVal, double searchLineFactor, double grapFactor, int[] heightRng
		, ArrayList<Double> slopes, double[] searchParas){
		
		ArrayList<Object> edgeParas = new ArrayList<Object>();
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int edgeStart = 0, edgeStop = 0, maxLen = 0;
        boolean edgeFound = false, forwardSearch = searchStart>searchStop?false:true;
        
		if(currGray<baseGVal){
    		continueCnt1++;
    		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
    			if(searchStart<=i+continueCntThr){
    				searchLineFactor = searchLineFactor*(forwardSearch?0.8:1.25);
    				if(searchWidth){
    					searchStart = (int)(imgWidth*searchLineFactor);
    				}else{
    					searchStart = (int)(imgHeight*searchLineFactor);
    				}
    				if(forwardSearch && searchStart<imgWidth-baseAvgPts || !forwardSearch && searchStart>baseAvgPts){
    					i = searchStart;
    					searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, forwardSearch);
    					baseGVal = searchParas[1] * baseFactor;
    					slopes.clear();
    					slopes.add(searchParas[2]);
        				continueCnt1=0;
    				}
    			}
    			
    			if(forwardSearch){
	    			edgeStart = i + backOffPixels;
	    			if(edgeStart>maxLen) edgeStart = maxLen;
	    			if(searchWidth){
	    				edgeStop = edgeStart - (int)(imgWidth*grapFactor);
	    			}else{
	    				edgeStop = edgeStart - (int)(imgHeight*grapFactor);
	    			}
	    			if(edgeStop<0) edgeStop = 0;
    			}else{
    				edgeStart = i - backOffPixels;
        			if(edgeStart<0) edgeStart = 0;
        			if(searchWidth){
        				edgeStop = edgeStart + (int)(imgWidth*grapFactor);
        			}else{
        				edgeStop = edgeStart + (int)(imgHeight*grapFactor);
        			}
        			if(edgeStop>maxLen) edgeStop = maxLen;
    			}
    			
    			edgeFound = true;
    		}
    		if(searchWidth && currGray<noiseGrayThr3 && null==heightRng){//Already enter the very dark region(almost search to the picture edge)
    			heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
				searchPos = (heightRng[0]+heightRng[1])/2;
				searchStart = (int)(imgWidth*searchLineFactor);
				i = searchStart;
				searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
				baseGVal = searchParas[1] * baseFactor;
				slopes.clear();
				slopes.add(searchParas[2]);
				continueCnt1=0;
    		}
    	}else{
    		baseGVal = searchParas[1] * baseFactor;
    		continueCnt1=0;
    	}
		
		edgeParas.add(0, continueCnt1);
		edgeParas.add(1, searchStart);
		edgeParas.add(2, edgeStart);
		edgeParas.add(3, edgeStop);
		edgeParas.add(4, baseGVal);
		
		return edgeParas;
	}
	
	private int[] getImgProcEdges(BufferedImage BI, PolePositionItems polePosition, double baseFactor, int layersQty, boolean searchWidth, int grapWidthStart, int grapWidthStop){
		int edgeStart = 0, edgeStop = 0, backOffPixels = 50, baseAvgPts = 10, searchPos = 0;
		int continueCnt1 = 0, continueCntThr = 5, maxLen = 0, searchStart = 0, searchStop = 0;
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int[] heightRng = null;
		double baseGVal = 0.0, grapFactor = 0.0, searchLineFactor = 0.0, currGray = 0.0;
		double[] searchParas = null;
		ArrayList<Double> slopes = new ArrayList<Double>();
		ArrayList<Object> edgeParas = null;
		
		if(searchWidth){
			maxLen = imgWidth - 1;
			grapFactor = 0.375;
			if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
	        	searchLineFactor = 0.85;
	        	if(polePosition==PolePositionItems.TOPRIGHT) searchLineFactor = 0.15;
	        	searchPos = (int)(imgHeight*searchLineFactor);
	        	searchStart = baseAvgPts; searchStop = imgWidth-1;
	        	edgeStart = searchStart;
				edgeStop = searchStart + (int)(imgWidth*grapFactor);
			}else{
				searchLineFactor = 0.15;
	        	if(polePosition==PolePositionItems.BOTTOMLEFT) searchLineFactor = 0.85;
	        	searchPos = (int)(imgHeight*searchLineFactor);
	        	searchStart = imgWidth-baseAvgPts; searchStop = 0;
	        	edgeStart = searchStart;
				edgeStop = searchStart - (int)(imgWidth*grapFactor);
			}
		}else{
			maxLen = imgHeight - 1;
			if(layersQty<=8){
				grapFactor = 0.25;
	        }else{
	        	grapFactor = 0.28 / 8.0 * layersQty;
	        }
			
			if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.BOTTOMLEFT){
	        	searchLineFactor = 0.75;
	        	if(polePosition==PolePositionItems.BOTTOMLEFT) searchLineFactor = 0.25;
	        	if(grapWidthStart<0 || grapWidthStop<0){
	        		searchPos = (int)(imgWidth*searchLineFactor);
	        	}else{
	        		searchPos = (grapWidthStart + grapWidthStop)/2;
	        	}
	        	searchStart = baseAvgPts; searchStop = imgHeight-1;
	        	edgeStart = searchStart;
				edgeStop = searchStart + (int)(imgHeight*grapFactor);
			}else{
				searchLineFactor = 0.25;
				if(polePosition==PolePositionItems.TOPRIGHT) searchLineFactor = 0.75;
				if(grapWidthStart<0 || grapWidthStop<0){
	        		searchPos = (int)(imgWidth*searchLineFactor);
	        	}else{
	        		searchPos = (grapWidthStart + grapWidthStop) / 2;
	        	}
	        	searchStart = imgHeight-baseAvgPts; searchStop = 0;
	        	edgeStart = searchStart;
				edgeStop = searchStart - (int)(imgHeight*grapFactor);
			}
		}
		
		searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
		currGray = searchParas[0];
		baseGVal = searchParas[1] * baseFactor;
		slopes.add(searchParas[2]);
		
		if(searchStart>searchStop){
        	for(int i=searchStart; i>=searchStop; i--){
        		searchParas = getEdgeSearchParas(BI, i, baseAvgPts, searchPos, searchWidth, false);
        		currGray = searchParas[0];
        		slopes.add(searchParas[2]);
        		
        		if(currGray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){
            			if(searchStart>=i-continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            				searchLineFactor = searchLineFactor*1.25;
            				if(searchWidth){
            					searchStart = (int)(imgWidth*searchLineFactor);
            				}else{
            					searchStart = (int)(imgHeight*searchLineFactor);
            				}
            				if(searchStart>baseAvgPts){
            					i = searchStart;
            					searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
            					baseGVal = searchParas[1] * baseFactor;
            					slopes.clear();
            					slopes.add(searchParas[2]);
	            				continueCnt1=0;
	            				continue;
            				}
            			}
            			edgeStart = i - backOffPixels;
            			if(edgeStart<0) edgeStart = 0;
            			if(searchWidth){
            				edgeStop = edgeStart + (int)(imgWidth*grapFactor);
            			}else{
            				edgeStop = edgeStart + (int)(imgHeight*grapFactor);
            			}
            			if(edgeStop>maxLen) edgeStop = maxLen;
            			break;
            		}
            		
            		if(searchWidth && currGray<noiseGrayThr3 && null==heightRng){//Already enter the very dark region(almost search to the picture edge)
            			heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
        				searchPos = (heightRng[0]+heightRng[1])/2;
        				searchStart = (int)(imgWidth*searchLineFactor);
        				i = searchStart;
        				searchParas = getEdgeSearchParas(BI, searchStart, baseAvgPts, searchPos, searchWidth, searchStart>searchStop?false:true);
    					baseGVal = searchParas[1] * baseFactor;
    					slopes.clear();
    					slopes.add(searchParas[2]);
        				continueCnt1=0; 
        				continue;
            		}
            	}else{
            		baseGVal = searchParas[1] * baseFactor;
            		continueCnt1=0;
            	}
        	}
        }else{
        	for(int i=searchStart; i<=searchStop; i++){
        		searchParas = getEdgeSearchParas(BI, i, baseAvgPts, searchPos, searchWidth, true);
        		currGray = searchParas[0];
        		slopes.add(searchParas[2]);
        		
        		edgeParas = edgeFoundParas(BI, polePosition, baseFactor, layersQty, searchWidth, grapWidthStart, grapWidthStop
        				, i, baseAvgPts, searchStart, searchStop, searchPos, continueCnt1
        				, continueCntThr, int backOffPixels
        				, double currGray, double baseGVal, double searchLineFactor, double grapFactor, int[] heightRng
        				, ArrayList<Double> slopes, double[] searchParas);
        	}
        }
        
		return new int[]{edgeStart, edgeStop};
	}
	
	private double[] getEdgeSearchParas(BufferedImage BI, int currIdx, int baseAvgPts, int searchPos, boolean searchWidth, boolean forwardSearch){
		ArrayList<Integer> xAxis = new ArrayList<Integer>();
		ArrayList<Integer> yAxis = new ArrayList<Integer>();
		int pixel = 0, gray = 0, start = 0, stop = 0, currGray = 0;
		double avgGray = 0.0;
		double[] coef = null;
		
		if(forwardSearch){
			start = currIdx - baseAvgPts + 1; stop = currIdx;
		}else{
			start = currIdx; stop = currIdx + baseAvgPts - 1;
		}
		
		if(searchWidth){
			pixel = BI.getRGB(currIdx, searchPos);
			currGray = (pixel & 0xffffff - 0xffff00);
		}else{
			pixel = BI.getRGB(searchPos, currIdx);
			currGray = (pixel & 0xffffff - 0xffff00);
		}
		
		for(int i=start; i<=stop; i++){
			if(searchWidth){
    			pixel = BI.getRGB(i, searchPos);
            	gray = (pixel & 0xffffff - 0xffff00);
    		}else{
    			pixel = BI.getRGB(searchPos, i);
            	gray = (pixel & 0xffffff - 0xffff00);
    		}
			xAxis.add(i);
			yAxis.add(gray);
			avgGray += gray;
		}
		
		avgGray = avgGray / baseAvgPts;
		coef = MathUtils.lineFitting(xAxis, yAxis);
		
		return new double[]{(double)currGray,avgGray,coef[0]*coef[0]};
	}
	
	private int[] getImgProcWidthRng(BufferedImage BI, PolePositionItems polePosition, int layersQty){
		int[] widthRng = new int[2];
		int[] heightRng = null;
		int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int grapWidthStart = 0, grapWidthStop = 0, backOffPixels = 50, baseAvgPts = 10;
        int continueCnt1 = 0, start = 0, stop = 0, pixel = 0, gray = 0, continueCntThr = 5;
        double heightFactor = 0.0, widthFactor = 0.0, baseGVal = 0.0, baseFactor = 0.95;
		String strX = "X", strG = "G";
		
        if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
        	heightRng = null;
        	widthFactor = 0.25; heightFactor = 0.85;
        	if(polePosition==PolePositionItems.TOPRIGHT) heightFactor = 0.15;
        	start = (int)(imgWidth*widthFactor); stop = imgWidth-1;
        	int h = (int)(imgHeight*heightFactor);
        	
        	grapWidthStart = start;
			grapWidthStop = grapWidthStart + (int)(imgWidth*0.375);
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start-baseAvgPts; k<start; k++){
	        		pixel = BI.getRGB(k, h);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		widthFactor = widthFactor*0.8;
    				start = (int)(imgWidth*widthFactor);
    				if(start<=baseAvgPts){
    					start = baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int w=start; w<stop; w++){
        		pixel = BI.getRGB(w, h);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strX += "," + w;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){
            			if(start>=w-continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            				widthFactor = widthFactor*0.8;
            				start = (int)(imgWidth*widthFactor);
            				if(start>baseAvgPts){
            					w = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start-baseAvgPts; k<start; k++){
	            	        		pixel = BI.getRGB(k, h);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapWidthStart = w - backOffPixels;
            			if(grapWidthStart<0) grapWidthStart = 0;
            			grapWidthStop = grapWidthStart + (int)(imgWidth*0.375);
            			if(grapWidthStop>=imgWidth) grapWidthStop = imgWidth - 1;
            			break;
            		}
            		if(gray<noiseGrayThr3){//Already enter the very dark region(almost search to the picture edge)
            			if(null!=heightRng){
            				//If the height range is fixed, fixed the width range by guessing
	            			grapWidthStart = (int)(imgWidth*0.75);
	            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
	            			break;
            			}else{
            				heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
            				h = (heightRng[0]+heightRng[1])/2;
            				widthFactor = 0.25;
            				start = (int)(imgWidth*widthFactor);
            				w = start; continueCnt1=0; continue;
            			}
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=w; k>w-baseAvgPts; k--){
                		pixel = BI.getRGB(k, h);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(polePosition==PolePositionItems.TOPLEFT || polePosition==PolePositionItems.BOTTOMLEFT){
        	heightRng = null;
        	widthFactor = 0.75; heightFactor = 0.15;
        	if(polePosition==PolePositionItems.BOTTOMLEFT) heightFactor = 0.85;
        	start = (int)(imgWidth*widthFactor); stop = 0;
        	int h = (int)(imgHeight*heightFactor);
        	
        	grapWidthStart = start;
			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start+baseAvgPts; k>start; k--){
	        		pixel = BI.getRGB(k, h);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		widthFactor = widthFactor*1.25;
    				start = (int)(imgWidth*widthFactor);
    				if(start>=imgWidth-baseAvgPts){
    					start = imgWidth-baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int w=start; w>stop; w--){
        		pixel = BI.getRGB(w, h);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strX += "," + w;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start<=w+continueCntThr){
            				widthFactor = widthFactor*1.25;
            				start = (int)(imgWidth*widthFactor);
            				if(start<imgWidth-baseAvgPts){
            					w = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start+baseAvgPts; k>start; k--){
	            	        		pixel = BI.getRGB(k, h);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapWidthStart = w + backOffPixels;
            			if(grapWidthStart>=imgWidth) grapWidthStart = imgWidth - 1;
            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
            			if(grapWidthStop<0) grapWidthStop = 0;
            			break;
            		}
            		if(gray<noiseGrayThr3){//Already enter the very dark region(almost search to the picture edge)
            			if(null!=heightRng){
            				//If the height range is fixed, fixed the width range by guessing
	            			grapWidthStart = (int)(imgWidth*0.75);
	            			grapWidthStop = grapWidthStart - (int)(imgWidth*0.375);
	            			break;
            			}else{
            				heightRng = getImgProcHeightRng(BI,polePosition,layersQty,-1,-1);
            				h = (heightRng[0]+heightRng[1])/2;
            				widthFactor = 0.75;
            				start = (int)(imgWidth*widthFactor);
            				w = start; continueCnt1=0; continue;
            			}
            		}
            	}else{
            		baseGVal = 0.0;
    	        	for(int k=start; k<start+baseAvgPts; k++){
    	        		pixel = BI.getRGB(k, h);
    	            	gray = (pixel & 0xffffff - 0xffff00);
    	        		baseGVal += gray;
    	        	}
    	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
    	        	
            		continueCnt1=0;
            	}
        	}
        }
		
        if(logEnabled){
        	LogUtils.rawLog("imgProcRegion_", strX);
        	LogUtils.rawLog("imgProcRegion_", strG);
        }
        
        widthRng[0] = grapWidthStart;
        widthRng[1] = grapWidthStop;
		return widthRng;
	}
	
	private int[] getImgProcHeightRng(BufferedImage BI, PolePositionItems polePosition, int layersQty, int grapWidthStart, int grapWidthStop){
		int[] heightRng = new int[2];
		int imgHeight = BI.getHeight();
		int imgWidth = BI.getWidth();
        int grapHeightStart = 0, grapHeightStop = 0, backOffPixels = 30, baseAvgPts = 10;
        int width = 0, continueCnt1 = 0, start = 0, stop = 0, pixel = 0, gray = 0, continueCntThr = 5;
        double heightFactor = 0.0, grapHeightFactor = 0.5, baseGVal = 0.0, baseFactor = 0.95;
        String strY = "Y", strG = "G";
        
        if(layersQty<=8){
        	grapHeightFactor = 0.25;
        }else{
        	grapHeightFactor = 0.28 / 8.0 * layersQty;
        }
		
        if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.BOTTOMLEFT){
        	heightFactor = 0.375;
        	start = (int)(imgHeight*heightFactor); stop = imgHeight-1;
        	
        	grapHeightStart = start;
			grapHeightStop = grapHeightStart + (int)(imgHeight*grapHeightFactor);
        	
        	if(grapWidthStart<0 || grapWidthStop<0){
        		if(polePosition==PolePositionItems.BOTTOMRIGHT) width = (int)(imgWidth*0.75);
        		if(polePosition==PolePositionItems.BOTTOMLEFT) width = (int)(imgWidth*0.25);
        	}else{
        		width = (grapWidthStart + grapWidthStop)/2;
        	}
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start-baseAvgPts; k<start; k++){
	        		pixel = BI.getRGB(width, k);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		heightFactor = heightFactor*0.8;
    				start = (int)(imgHeight*heightFactor);
    				if(start<=baseAvgPts){
    					start = baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int height=start; height<stop; height++){
        		pixel = BI.getRGB(width, height);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strY += "," + height;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start>=height-continueCntThr){
            				heightFactor = heightFactor*0.8;
            				start = (int)(imgHeight*heightFactor);
            				if(start>baseAvgPts){
            					height = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start-baseAvgPts; k<start; k++){
	            	        		pixel = BI.getRGB(width, k);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapHeightStart = height - backOffPixels;
            			if(grapHeightStart<0) grapHeightStart = 0;
            			grapHeightStop = grapHeightStart + (int)(imgHeight*grapHeightFactor);
            			if(grapHeightStop >= imgHeight){
            				grapHeightStart = grapHeightStart - (grapHeightStop-imgHeight);
            				grapHeightStop = imgHeight - 1;
            			}
            			break;
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=start; k>start-baseAvgPts; k--){
                		pixel = BI.getRGB(width, k);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(polePosition==PolePositionItems.TOPRIGHT || polePosition==PolePositionItems.TOPLEFT){
        	heightFactor = 0.625;
        	start = (int)(imgHeight*heightFactor); stop = 0;
        	
        	grapHeightStart = start;
			grapHeightStop = grapHeightStart - (int)(imgHeight*grapHeightFactor);
        	
        	if(grapWidthStart<0 || grapWidthStop<0){
        		if(polePosition==PolePositionItems.TOPRIGHT) width = (int)(imgWidth*0.75);
        		if(polePosition==PolePositionItems.TOPLEFT) width = (int)(imgWidth*0.25);
        	}else{
        		width = (grapWidthStart + grapWidthStop) / 2;
        	}
        	
        	while(true){
	        	baseGVal = 0.0;
	        	for(int k=start+baseAvgPts; k>start; k--){
	        		pixel = BI.getRGB(width, k);
	            	gray = (pixel & 0xffffff - 0xffff00);
	        		baseGVal += gray;
	        	}
	        	baseGVal = baseGVal / baseAvgPts;
	        	if(baseGVal>=noiseGrayThr){
	        		break;
	        	}else{
	        		heightFactor = heightFactor*1.25;
    				start = (int)(imgHeight*heightFactor);
    				if(start>=imgHeight-baseAvgPts){
    					start = imgHeight - baseAvgPts;
    					break;
    				}
	        	}
        	}
        	baseGVal = baseGVal * baseFactor;
        	
        	for(int height=start; height>stop; height--){
        		pixel = BI.getRGB(width, height);
            	gray = (pixel & 0xffffff - 0xffff00);
            	if(logEnabled){
	            	strY += "," + height;
	            	strG += "," + gray;
            	}
            	
            	if(gray<baseGVal){
            		continueCnt1++;
            		if(continueCnt1>=continueCntThr){//The starting position could be in the pole region, need to enlarge the window
            			if(start<=height+continueCntThr){
            				heightFactor = heightFactor*1.25;
            				start = (int)(imgHeight*heightFactor);
            				if(start<imgHeight-baseAvgPts){
            					height = start;
	            				continueCnt1=0;
	            				
	            				baseGVal = 0.0;
	            	        	for(int k=start+baseAvgPts; k>start; k--){
	            	        		pixel = BI.getRGB(width, k);
	            	            	gray = (pixel & 0xffffff - 0xffff00);
	            	        		baseGVal += gray;
	            	        	}
	            	        	baseGVal = baseGVal / baseAvgPts * baseFactor;
	            				continue;
            				}
            			}
            			grapHeightStart = height + backOffPixels;
            			if(grapHeightStart>=imgHeight) grapHeightStart = imgHeight - 1;
            			grapHeightStop = grapHeightStart - (int)(imgHeight*grapHeightFactor);
            			if(grapHeightStop<0){
            				grapHeightStart = grapHeightStart - grapHeightStop;
            				grapHeightStop = 0;
            			}
            			break;
            		}
            	}else{
            		baseGVal = 0.0;
                	for(int k=start; k<start+baseAvgPts; k++){
                		pixel = BI.getRGB(width, k);
                    	gray = (pixel & 0xffffff - 0xffff00);
                		baseGVal += gray;
                	}
                	baseGVal = baseGVal / baseAvgPts * baseFactor;
                	
            		continueCnt1=0;
            	}
        	}
        }
        
        if(logEnabled){
        	LogUtils.rawLog("imgProcRegion_", strY);
        	LogUtils.rawLog("imgProcRegion_", strG);
        }
        
        heightRng[0] = grapHeightStart;
        heightRng[1] = grapHeightStop;
		return heightRng;
	}
	
	private int[] getImageProcRegion(BufferedImage BI, PolePositionItems polePosition, int layersQty){
		int[] grapImgStart = new int[4];
		int[] grapImgWidthRng = null, grapImgHeightRng = null;
		
		grapImgWidthRng = getImgProcWidthRng(BI,polePosition,layersQty);
		grapImgHeightRng = getImgProcHeightRng(BI,polePosition,layersQty,grapImgWidthRng[0],grapImgWidthRng[1]);
		
        grapImgStart[0] = grapImgHeightRng[0];
        grapImgStart[1] = grapImgHeightRng[1];
        grapImgStart[2] = grapImgWidthRng[0];
        grapImgStart[3] = grapImgWidthRng[1];
        
		return grapImgStart;
	}
	
	public boolean procImage(String imgRootDir, String imgFileName, boolean outImg, String specifiedSpec){
		boolean imgPassed = false;
		
        try {
			imgPassed = procImageEx(imgRootDir, imgFileName, outImg, specifiedSpec);
			clearMemory();
		} catch (Exception e) {
			LogUtils.errorLog("Process "+imgRootDir+File.separator+imgFileName+" error:"+e.getMessage());
		}
        
        return imgPassed;
	}
	
	private boolean procImageEx(String imgRootDir, String imgFileName, boolean outImg, String specifiedSpec){
		String src = imgRootDir + File.separator + imgFileName;
		criteria = productSpec.getData(imgRootDir);
		if(null==criteria){
			if(null!=specifiedSpec && !"".equals(specifiedSpec.trim())) criteria = productSpec.getData(specifiedSpec);
			if(null==criteria){
				System.out.println("Product Spec for "+imgRootDir+" is not set yet!");
				return false;
			}
		}
		
		long startProcTime = System.currentTimeMillis();
		File file = new File(src);
        BufferedImage BI = null;
        try{
            BI = ImageIO.read(file);
            if(null==BI){
            	System.out.println("Read "+src+" failed");
            	return false;
            }
        }catch(Exception e){
            e.printStackTrace();
            return false;
        }
        
        int imgWidth = BI.getWidth();
        int imgHeight = BI.getHeight();
        int grapHeightStart = 0, grapHeightStop = 0, grapHeight = 0;
        int grapWidthStart = 0, grapWidthStop = 0, grapWidth = 0;
        int[][] imgGrays = null, initVals = null, peakVals = null;
        int pixel = 0, gray = 0;
        
        PolePositionItems polePosition = getPolePositionInImage(BI);
        System.out.println("Pole Position:"+polePosition);
        
        LinkedHashMap<PolePositionItems,Integer> layers = getLayersQty();
        targetLinesQty = layers.get(polePosition)*2;
        if(targetLinesQty<=0) return false;
        LogUtils.clearLog(true);
        
        int[] imgProcRegion = getImageProcRegion(BI,polePosition,targetLinesQty/2);
        grapHeightStart = imgProcRegion[0]; grapHeightStop = imgProcRegion[1];
        grapWidthStart = imgProcRegion[2]; grapWidthStop = imgProcRegion[3];
        grapHeight = Math.abs(grapHeightStart-grapHeightStop);
        grapWidth = Math.abs(grapWidthStart-grapWidthStop);
        imgGrays = new int[grapWidth][grapHeight];
    	initVals = new int[imgGrays.length][imgGrays[0].length];
    	
    	if(grapWidthStop > grapWidthStart){
    		if(grapHeightStop > grapHeightStart){
    			//Bottom-right
    			for(int i=grapWidthStart; i<grapWidthStop; i++){
            		for(int j=grapHeightStart; j<grapHeightStop; j++){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[i-grapWidthStart][j-grapHeightStart] = gray;
            			initVals[i-grapWidthStart][j-grapHeightStart] = 255;
            		}
            	}
    		}else{
    			//Top-right
    			for(int i=grapWidthStart; i<grapWidthStop; i++){
            		for(int j=grapHeightStart; j>grapHeightStop; j--){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[i-grapWidthStart][grapHeightStart-j] = gray;
            			initVals[i-grapWidthStart][grapHeightStart-j] = 255;
            		}
            	}
    		}
    	}else{
    		if(grapHeightStop < grapHeightStart){
    			//Top-left
    			for(int i=grapWidthStart; i>grapWidthStop; i--){
            		for(int j=grapHeightStart; j>grapHeightStop; j--){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[grapWidthStart-i][grapHeightStart-j] = gray;
            			initVals[grapWidthStart-i][grapHeightStart-j] = 255;
            		}
            	}
    		}else{
    			//Bottom-left
    			for(int i=grapWidthStart; i>grapWidthStop; i--){
            		for(int j=grapHeightStart; j<grapHeightStop; j++){
            			pixel = BI.getRGB(i, j);
                    	gray = (pixel & 0xffffff - 0xffff00);
            			imgGrays[grapWidthStart-i][j-grapHeightStart] = gray;
            			initVals[grapWidthStart-i][j-grapHeightStart] = 255;
            		}
            	}
    		}
    	}
    	
        //Start image processing
        boolean imgPassed = false;
        allPossibleLines.clear();
        allPotentialLines.clear();
        imgProcResultLength.clear();
        imgProcResultOK.clear();
        imgProcResultAngle.clear();
        if(null!=imgGrays){
        	peakVals = getPeakVals(imgGrays,initVals);
            if(null!=peakVals){
            	setFirstPoleConfig();
            	ImgExtractLine baseLine = getBaseLine(peakVals,initVals,imgGrays,255);
            	if(null!=baseLine && baseLine.getLineRSQ()>0){
            		ArrayList<ImgExtractLine> extractLines = searchLines(peakVals,initVals,imgGrays,255,baseLine);
            		if(extractLines.size()>0){
            			imgPassed = checkLines(peakVals,initVals,imgGrays,255,baseLine,extractLines);
            		}
            	}else{
            		System.out.println("getBaseLine failed");
            	}
            }
        }
        
        //Save output image
        if(outImg){
        	BI = createBufferedImage(BI);
        	if(null!=finalData && finalData.length>0){
        		int realX = 0, realY = 0;
        		int firstLen = finalData.length, secondLen = finalData[0].length;
        		for(int i=0; i<firstLen; i++){
        			if(grapWidthStart>grapWidthStop){
    					realX = grapWidthStart - i;
    				}else{
    					realX = grapWidthStart + i;
    				}
        			
        			for(int j=0; j<secondLen; j++){
        				if(grapHeightStart>grapHeightStop){
        					realY = grapHeightStart - j;
        				}else{
        					realY = grapHeightStart + j;
        				}
        				
        				if(finalData[i][j]<255){
        					pixel = BI.getRGB(realX, realY);
        					if(4==finalData[i][j]){
        						BI.setRGB(realX, realY, Color.RED.getRGB());
        					}else{
        						if(evenPoleIsLonger && 0==finalData[i][j]%2 || !evenPoleIsLonger && 1==finalData[i][j]%2){
        							BI.setRGB(realX, realY, Color.ORANGE.getRGB());
        						}else{
        							BI.setRGB(realX, realY, Color.BLACK.getRGB());
        						}
        					}
        				}
        			}
        		}
        	}
        	
	        Iterator<ImageWriter> it = ImageIO.getImageWritersByFormatName("png");//
	        ImageWriter writer = it.next();
	        ImageOutputStream ios;
			try {
				writeProcResultInfo(imgFileName,BI,polePosition,imgPassed,imgWidth,imgHeight,startProcTime);
				if(imgPassed){
					ios = ImageIO.createImageOutputStream(new File(src+".OK.png"));
				}else{
					ios = ImageIO.createImageOutputStream(new File(src+".NG.png"));
				}
				writer.setOutput(ios);
		        writer.write(BI);
		        BI.flush();
		        ios.flush();
		        ios.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
        }
        
        String[] imgProcRslt = getImgProcRsltData(imgFileName);
        imgProcRslt[0] = imgProcRslt[0]+",imgSavingT(ms)";
        imgProcRslt[1] = imgProcRslt[1]+","+(System.currentTimeMillis()-getImgStartSavingTime());
        setImgProcRsltData(imgFileName,imgProcRslt[0],imgProcRslt[1]);
        
        return imgPassed;
	}
	
	private BufferedImage createBufferedImage(BufferedImage baseBI){
		int width = baseBI.getWidth();
		int height = baseBI.getHeight();
		
		BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
        bi.getGraphics().drawImage(baseBI, 0, 0,width, height, null);
        baseBI = null;
        
        return bi;
	}
	
	private void writeProcResultInfo(String imgFileName, BufferedImage BI, PolePositionItems polePosition, boolean imgPassed, int imgWidth, int imgHeight, long startProcTime){
		int txtX = 0, txtY = 0, txtOffset = 25, txtLine = 0, oriY = 0;
		double minL = 1000.0, maxL = -1000.0, curL = 0.0;
		String lenInfo = "", procRsltTitle = "", procRsltData = "";
		DecimalFormat df = new DecimalFormat("0.000");
		DecimalFormat df1 = new DecimalFormat("0.0");
		Graphics g = BI.getGraphics();
		g.setFont(new Font("Serif",Font.BOLD,54));
		g.setColor(imgPassed?Color.DARK_GRAY:Color.RED);
		if(polePosition==PolePositionItems.TOPLEFT || polePosition==PolePositionItems.BOTTOMLEFT){
			txtX = (int)(imgWidth*0.75);
			txtY = (int)(imgHeight*0.25);
		}else if(polePosition==PolePositionItems.BOTTOMRIGHT || polePosition==PolePositionItems.TOPRIGHT){
			txtX = (int)(imgWidth*0.15);
			txtY = (int)(imgHeight*0.25);
		}
		oriY = txtY;
		
		g.drawString(imgPassed?"OK":"NG", txtX, txtY);
		g.setFont(new Font("Serif",Font.BOLD,18));
		txtLine = 3;
		txtY += txtOffset * txtLine;
		for(String key:imgProcResultLength.keySet()){
			txtY += txtOffset;
			curL = imgProcResultLength.get(key);
			lenInfo = key+" = "+df.format(curL);
			procRsltTitle += ","+key;
			procRsltData += ","+df.format(curL);
			
			if(null!=imgProcResultAngle.get(key)){
				lenInfo += " ["+df1.format(imgProcResultAngle.get(key))+"deg]";
			}
			
			if(imgProcResultOK.get(key)){
				g.setColor(Color.DARK_GRAY);
			}else{
				g.setColor(Color.RED);
			}
			g.drawString(lenInfo, txtX, txtY);
			if(minL>curL) minL = curL;
			if(maxL<curL) maxL = curL;
		}
		imgStartSavingT = System.currentTimeMillis();
		imgProcTime = imgStartSavingT-startProcTime;
		g.setColor(Color.DARK_GRAY);
		g.drawString("PRO_T = "+imgProcTime+" ms", txtX, oriY+txtOffset);
		g.drawString("MIN_L = "+df.format(minL)+" mm", txtX, oriY+txtOffset*2);
		g.drawString("MAX_L = "+df.format(maxL)+" mm", txtX, oriY+txtOffset*3);
		
		procRsltTitle = "procT(ms),MIN_L,MAX_L"+procRsltTitle;
		procRsltData = imgProcTime+","+df.format(minL)+","+df.format(maxL)+procRsltData;
		setImgProcRsltData(imgFileName,procRsltTitle,procRsltData);
	}
	
	public void clearImgProcRsltData(String imgFileName){
		imgProcResultStr.remove(imgFileName);
	}
	
	private void setImgProcRsltData(String imgFileName, String rsltTitle, String rsltData){
		imgProcResultStr.put(imgFileName, rsltTitle+"\r\n"+rsltData);
	}
	
	public String[] getImgProcRsltData(String imgFileName){
		String[] rsltStr = new String[]{"",""};
		String rslt = imgProcResultStr.get(imgFileName);
		if(null!=rslt) rsltStr = rslt.split("\r\n");
		return rsltStr;
	}
	
	private ArrayList<Object> getLinesTendencyParas(ArrayList<ImgExtractLine> extractLines, LinkedHashMap<Integer,ImgExtractLine> linesMap, int targetLinesQty){
		ArrayList<Object> tdcParas = new ArrayList<Object>();
		double[] coef = null, slope = null, offset = null;
		int reliableMaxIdx = 0, evenPoleCnt = 0, oddPoleCnt = 0;
		double evenPoleAvgOffset = 0.0, oddPoleAvgOffset = 0.0, finalRsq = 0.0;
		double evenMinOffset = 0.0, evenMaxOffset = 0.0, oddMinOffset = 0.0, oddMaxOffset = 0.0, curOffset = 0.0;
		
		LinkedHashMap<Double,Double> tendencyDt = new LinkedHashMap<Double,Double>();
		ArrayList<Double> tdcSlope = new ArrayList<Double>();
		ArrayList<Double> tdcOffset = new ArrayList<Double>();
		ArrayList<Double> tdcRsq = new ArrayList<Double>();
		
		if(null!=extractLines && extractLines.size()>0){
			if(null==linesMap){
				linesMap = new LinkedHashMap<Integer,ImgExtractLine>();
			}else if(!linesMap.isEmpty()){
				linesMap.clear();
			}
			
			for(int i=0; i<extractLines.size(); i++){
				if(i<targetLinesQty){
					linesMap.put(i, extractLines.get(i));
					tendencyDt.put((double)i, extractLines.get(i).getLineIntercept());
					if(i<2){
						tdcSlope.add(i,0.0);
						tdcOffset.add(i,0.0);
						tdcRsq.add(i,1.0);
						reliableMaxIdx = i;
					}else{
						coef = MathUtils.lineFitting(tendencyDt);
						tdcSlope.add(i,coef[0]);
						tdcOffset.add(i,coef[1]);
						tdcRsq.add(i,coef[2]);
						if(coef[2]>minBestRsq){
							reliableMaxIdx = i;
							finalRsq = coef[2];
						}
					}
				}else{
					break;
				}
			}
			
			//Recalculate the tendency
			if(reliableMaxIdx>5 && tdcRsq.get(reliableMaxIdx) < minBestRsq){
				LinkedHashMap<Double,Double> fittingDt = new LinkedHashMap<Double,Double>();
				for(int i=1; i<=reliableMaxIdx; i++){
					fittingDt.put((double)i, extractLines.get(i).getLineIntercept());
				}
				coef = MathUtils.lineFitting(fittingDt);
				finalRsq = coef[2];
			}
			
			//Calculate average offset of even & odd pole to its previous most-closed pole
			evenPoleAvgOffset=0.0; oddPoleAvgOffset=0.0;
			for(int i=1; i<=reliableMaxIdx; i++){
				curOffset = linesMap.get(i).getLineIntercept() - linesMap.get(i-1).getLineIntercept();
				if(0==i%2){
					evenPoleCnt++;
					evenPoleAvgOffset += curOffset;
					if(1==evenPoleCnt){
						evenMinOffset = curOffset; evenMaxOffset = curOffset;
					}else{
						if(evenMinOffset>curOffset) evenMinOffset = curOffset;
						if(evenMaxOffset<curOffset) evenMaxOffset = curOffset;
					}
				}else{
					oddPoleCnt++;
					oddPoleAvgOffset += curOffset;
					if(1==oddPoleCnt){
						oddMinOffset = curOffset; oddMaxOffset = curOffset;
					}else{
						if(oddMinOffset>curOffset) oddMinOffset = curOffset;
						if(oddMaxOffset<curOffset) oddMaxOffset = curOffset;
					}
				}
			}
			evenPoleAvgOffset = (evenPoleCnt>2)?(evenPoleAvgOffset-evenMinOffset-evenMaxOffset) / (evenPoleCnt-2):evenPoleAvgOffset / evenPoleCnt;
			oddPoleAvgOffset = (oddPoleCnt>2)?(oddPoleAvgOffset-oddMinOffset-oddMaxOffset) / (oddPoleCnt-2):oddPoleAvgOffset / oddPoleCnt;
		}
		
		tdcParas.add(0,finalRsq);
		tdcParas.add(1,evenPoleAvgOffset);
		tdcParas.add(2,oddPoleAvgOffset);
		tdcParas.add(3,reliableMaxIdx);
		if(tdcSlope.size()>0){
			slope = new double[tdcSlope.size()];
			offset = new double[tdcOffset.size()];
			for(int i=0; i<tdcSlope.size(); i++){
				slope[i] = tdcSlope.get(i);
				offset[i] = tdcOffset.get(i);
			}
		}
		tdcParas.add(4,slope);
		tdcParas.add(5,offset);
		
		return tdcParas;
	}
	
	private boolean checkLines(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, ImgExtractLine myBaseline, ArrayList<ImgExtractLine> extractLines){
		boolean bPassed = false;
		int extLinesQty = 0, bestRsqIdx = 0;
		double oddPoleAvgOffset = 0.0, evenPoleAvgOffset = 0.0;
		double[] slope = null, offset = null;
		
		LinkedHashMap<Integer,ImgExtractLine> linesMap = new LinkedHashMap<Integer,ImgExtractLine>();
		ArrayList<Object> tdcParas = null;
		
		extLinesQty = extractLines.size();
		if(extLinesQty>3){
			tdcParas = getLinesTendencyParas(extractLines, linesMap, targetLinesQty);
			if((double)tdcParas.get(0)<minBestRsq){
				System.out.println("RSQ NG:"+(double)tdcParas.get(0)+"(<"+minBestRsq+")");
				return bPassed;
			}
			evenPoleAvgOffset = (double)tdcParas.get(1);
			oddPoleAvgOffset = (double)tdcParas.get(2);
			bestRsqIdx = (int)tdcParas.get(3);
			slope = (double[]) tdcParas.get(4);
			offset = (double[]) tdcParas.get(5);
			
			//Recalculate the missing lines
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,false);
			}
			
			//Double check all lines
			evenPoleIsLonger = evenLineIsLonger(linesMap,imgGrays);
			System.out.println("bestIdx/evenOffset/oddOffset:"+bestRsqIdx
					+"/"+evenPoleAvgOffset+"/"+oddPoleAvgOffset
					+"/"+((currToLastOffsetDeltaIsBigger(2,evenPoleIsLonger)?
							((evenPoleAvgOffset>oddPoleAvgOffset)?"Correct":"Wrong"):
							((evenPoleAvgOffset<oddPoleAvgOffset)?"Correct":"Wrong"))));
			
			//Check one more layer inside if the first layer is longer
			if(evenPoleIsLonger && !firstPoleIsLonger){
				targetLinesQty = targetLinesQty + 1;
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,true);
			}
			
			//Compensate the longer layers
			linesMap = adjustLongerLines(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty,true);
			
			//Adjust all layers' index
			linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = searchMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty,true);
				linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			}
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = addMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
				linesMap = doubleCheckAllLinesNew(linesMap, peakVals,initVals,imgGrays, evenPoleIsLonger, targetLinesQty,evenPoleAvgOffset,oddPoleAvgOffset,slope[bestRsqIdx],offset[bestRsqIdx]);
			}
			if(thereIsMissingLines(linesMap,targetLinesQty)){
				linesMap = addMissingLines(linesMap,myBaseline,peakVals,initVals,imgGrays,defaultVal,slope,offset,bestRsqIdx,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
			}
			
			//Set all lines sharp change position
			linesMap = adjustLongerLines(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty,true);
			setLinesSharpChgPosition(linesMap,imgGrays,peakVals,evenPoleIsLonger,targetLinesQty);
			
			//Calculate the final result
			twoNearLayersOffsetCorrect(linesMap,evenPoleIsLonger);
			setLongerPolesLength(linesMap,imgGrays,peakVals,evenPoleIsLonger,evenPoleAvgOffset,oddPoleAvgOffset,targetLinesQty);
			bPassed = calculateFinalResult(linesMap,evenPoleIsLonger,imgGrays,defaultVal,targetLinesQty,peakVals,evenPoleAvgOffset,oddPoleAvgOffset);
		}else{
			System.out.println("Extract Lines Qty:"+extractLines.size()+" is NG");
		}
		
		saveImgData("graysFinalLines_",finalData);
		System.out.println("Proc Result:"+(bPassed?"OK":"NG"));
		return bPassed;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> adjustLongerLines(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, int targetLinesQty, boolean bNotSetInterceptDelta){
		double[] weightOfLine = null;
		for(int lineIdx=0; lineIdx<targetLinesQty; lineIdx++){
			ImgExtractLine exLine = oriLinesMap.get(lineIdx);
			if(null!=exLine && 0==exLine.getXAxisStart()){
				exLine = setLineBoundary(exLine, imgGrays, 255);
				oriLinesMap.put(lineIdx, exLine);
			}
			
			if(curLineIsLonger(lineIdx,evenLineLonger)){
				if(null!=exLine){
					weightOfLine = exLine.weightOfBeingLine(oriLinesMap, exLine.getXAxisStop(), exLine.getXAxisStart(), 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, bNotSetInterceptDelta, curLineIsLonger(lineIdx,evenLineLonger), false);
					oriLinesMap.put(lineIdx, exLine);
					if(weightOfLine[0]<0.5) System.out.println("Weight of line("+lineIdx+"):"+weightOfLine[0]);
				}
			}
		}
		
		return oriLinesMap;
	}
	
	private int[] getPolePosX(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger, int targetLinesQty){
		double xPositionSum1 = 0.0, xPositionSum2 = 0.0;
		int counter1 = 0, counter2 = 0;
		int[] polePosX = new int[]{-1,-1};
		ImgExtractLine exLine = null;
		for(int lineIdx=0; lineIdx<targetLinesQty; lineIdx++){
			exLine = linesMap.get(lineIdx);
			if(null==exLine) continue;
			if(curLineIsLonger(lineIdx,evenLineLonger)){
				xPositionSum1 += exLine.getXAxisStop();
				counter1++;
			}else{
				xPositionSum2 += exLine.getXAxisStart();
				counter2++;
			}
		}
		if(counter1>0) polePosX[0] = (int)(xPositionSum1/counter1);
		if(counter2>0) polePosX[1] = (int)(xPositionSum2/counter2);
		return polePosX;
	}
	
	private boolean twoNearLayersOffsetCorrect(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger){
		boolean correct = true;
		ImgExtractLine currLine = null, lastLine = null;
		double evenPoleOffsetSum = 0.0, oddPoleOffsetSum = 0.0, offsetDelta = 0.0;
		double evenPoleAvgOffset = 0.0, oddPoleAvgOffset = 0.0;
		int evenPoleCnt = 0, oddPoleCnt = 0;
		
		for(Integer idx:linesMap.keySet()){
			currLine = linesMap.get(idx);
			lastLine = linesMap.get(idx-1);
			
			if(null!=currLine && null!=lastLine){
				offsetDelta = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				offsetDelta = offsetDelta-lastLine.getLineIntercept()-lastLine.getLineInterceptDelta();
				if(0==idx%2){
					evenPoleOffsetSum += offsetDelta;
					evenPoleCnt++;
				}else{
					oddPoleOffsetSum += offsetDelta;
					oddPoleCnt++;
				}
			}
		}
		if(evenPoleCnt>0) evenPoleAvgOffset=evenPoleOffsetSum/evenPoleCnt;
		if(oddPoleCnt>0) oddPoleAvgOffset=oddPoleOffsetSum/oddPoleCnt;
		correct = ((currToLastOffsetDeltaIsBigger(2,evenLineLonger)?
				((evenPoleAvgOffset>oddPoleAvgOffset)?true:false):
				((evenPoleAvgOffset<oddPoleAvgOffset)?true:false)));
		
		System.out.println("evenPoleAvgOffset/oddPoleAvgOffset:"
				+"/"+evenPoleAvgOffset+"/"+oddPoleAvgOffset
				+"/"+(correct?"Correct":"Wrong"));
		
		return correct;
	}
	
	private void setLongerPolesLength(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty){
		//Check the logic carefully
		int imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		int[][] tmpGrays = new int[imgWidth][imgHeight];
		for(int k=0; k<imgWidth; k++){
			tmpGrays[k] = imgGrays[k].clone();
		}
		double tmpSlope = 0.0, tmpOffset = 0.0, poleLength = 0.0;
		double oriSlope = tmpSlope, oriOffset = tmpOffset;
		double maxDnChkOffset = 0.0;
		boolean curLinePassed = false;
		int newXAxisStop = -1, wrinkleLineMaxOffset = 0;
		ImgExtractLine tmpLine = null, exLine = null;
		int[] polePosX = getPolePosX(linesMap,evenLineLonger,targetLinesQty);
		if(polePosX[0]<0 || polePosX[1]<0) return;
		
		int refPos = 0, minIdx = -1, oriCol = 0;
		int stopChkPos = 0, nearCol = 0, defaultVal = 255, lineFlag = 0;
		
		double maxPoleAngle = Double.parseDouble(""+criteria.get("maxPoleAngle"));
		double onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		double minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		double maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		
		for(int i=0; i<targetLinesQty; i++){
			if(i>=linesMap.size() || i>=10) break;
			if(!curLineIsLonger(i,evenLineLonger)) continue;
			exLine = linesMap.get(i);
			if(null==exLine || null==linesMap.get(i+1) || null==linesMap.get(i-1)) continue;
			if(i>0 && linesMap.get(i-1).getXAxisStart()-exLine.getXAxisStop()<minDistance) continue;
			if(i+1<linesMap.size() && linesMap.get(i+1).getXAxisStart()-exLine.getXAxisStop()<minDistance) continue;
			refPos = exLine.getXAxisStop();
			if(refPos-polePosX[0]<5) continue;
			
			curLinePassed = false;
			lineFlag = exLine.getLineFlag();
			tmpSlope = exLine.getLineSlope();
			tmpOffset = exLine.getLineIntercept();
			oriSlope = tmpSlope; oriOffset = tmpOffset;
			wrinkleLineMaxOffset = (int)(evenPoleAvgOffset+oddPoleAvgOffset)/2;
			maxDnChkOffset = (evenPoleAvgOffset+oddPoleAvgOffset)/2;
			
			tmpLine = exLine;
			if(null!=linesMap.get(i+2)){
				maxDnChkOffset = linesMap.get(i+2).getLineIntercept()+linesMap.get(i+2).getLineInterceptDelta();
				maxDnChkOffset = maxDnChkOffset - tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
			}else{
				maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i+1).getLineIntercept()-linesMap.get(i+1).getLineInterceptDelta();
				maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
			}
			
			minIdx = -1;
			stopChkPos = refPos - (int)maxDistance;
			if(stopChkPos<0) stopChkPos = 0;
			
			//Check down side
			LinkedHashMap<Double,Double> dnSideWrinkleLine = new LinkedHashMap<Double,Double>();
			dnSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,refPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
			
			double[] dnLineParas = null;
			double dnSideAngle = 0.0;
			if(dnSideWrinkleLine.size()>=5){
				dnLineParas = MathUtils.lineFitting(dnSideWrinkleLine);
				dnSideAngle = 90.0;
				if(-1!=tmpSlope*dnLineParas[0]){
					dnSideAngle = Math.abs((tmpSlope-dnLineParas[0])/(1+tmpSlope*dnLineParas[0]));
					dnSideAngle = Math.toDegrees(Math.atan(dnSideAngle));
				}
			}else{
				continue;
			}
			
			if(dnSideAngle>0){
				if(dnSideAngle<=maxPoleAngle){
					storeLayerAngle(evenLineLonger, i, dnSideAngle, 0);
					minIdx = imgWidth;
					for(double k:dnSideWrinkleLine.keySet()){
						if(k<minIdx) minIdx=(int)k;
					}
					newXAxisStop = minIdx;
					for(int k=refPos; k>=minIdx; k--){
						nearCol = (int)(k*tmpSlope+tmpOffset);
						for(int n=(int)maxDnChkOffset;n>0;n--){
							if(nearCol+n>=0 && nearCol+n<imgHeight){
								if(imgGrays[k][nearCol+n]<defaultVal){
									if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
										tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
									}
								}
							}
						}
					}
				}else{
					newXAxisStop = (int)((tmpOffset-dnLineParas[1])/(dnLineParas[0]-tmpSlope));
				}
			}
			
			if(newXAxisStop>=0){
				tmpLine.setXAxisStop(newXAxisStop);
				if(tmpLine.getXAxisStart()<newXAxisStop) tmpLine.setXAxisStart(newXAxisStop);
				tmpLine.setPolePosition(newXAxisStop);
				if(curLineIsLonger(i,evenLineLonger)){
					linesMap.put(i, tmpLine);
				}else{
					linesMap.put(i-1, tmpLine);
				}
				
				poleLength = linesMap.get(i-1).getXAxisStart()-tmpLine.getXAxisStop();
				if(poleLength>=minDistance && poleLength<=maxDistance) curLinePassed = true;
				
				if(!curLinePassed){
					lineFlag = 4;
				}else{
					lineFlag = lineIndexBase + i;
				}
				if(null!=dnLineParas && dnSideAngle<=maxPoleAngle){
					tmpSlope = dnLineParas[0];
					tmpOffset = dnLineParas[1];
					tmpLine.setCrossX(refPos);
					for(int k=newXAxisStop; k<=refPos; k++){
						nearCol = (int)(k*tmpSlope+tmpOffset);
						oriCol = (int)(k*oriSlope+oriOffset);
						if(nearCol<oriCol) nearCol = oriCol;
						if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
					}
				}
			}
		}
	}
	
	private boolean curLineIsLonger(int lineIdx, boolean evenLineLonger){
		boolean curLineLonger = false;
		if(0==lineIdx%2 && evenLineLonger || 1==lineIdx%2 && !evenLineLonger) curLineLonger = true;
		return curLineLonger;
	}
	
	private boolean currToLastOffsetDeltaIsBigger(int lineIdx, boolean evenLineLonger){
		boolean bigger = false;
		
		if(0==lineIdx%2 && firstPoleIsThicker || 1==lineIdx%2 && !firstPoleIsThicker){
			if(firstPoleIsLonger && evenLineLonger 
				|| !firstPoleIsLonger && !evenLineLonger) bigger=true;
		}
		
		return bigger;
	}
	
	private int[] getWeightChkRange(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap,LinkedHashMap<Integer, ImgExtractLine> newLinesMap,int oriLineIdx,int newLineIdx){
		int[] chkRange = new int[2];
		//Get the max range(Max start and Min stop) of the near three lines
		ImgExtractLine curLine = oriLinesMap.get(oriLineIdx);
		ImgExtractLine lastLine = newLinesMap.get(newLineIdx-1);
		ImgExtractLine nextLine = oriLinesMap.get(oriLineIdx+1);
		
		chkRange[0] = curLine.getXAxisStart();
		chkRange[1] = curLine.getXAxisStop();
		if(null!=lastLine){
			if(lastLine.getXAxisStart()>chkRange[0]) chkRange[0] = lastLine.getXAxisStart();
			if(lastLine.getXAxisStop()<chkRange[1]) chkRange[1] = lastLine.getXAxisStop();
		}
		if(null!=nextLine){
			if(nextLine.getXAxisStart()>chkRange[0]) chkRange[0] = nextLine.getXAxisStart();
			if(nextLine.getXAxisStop()<chkRange[1]) chkRange[1] = nextLine.getXAxisStop();
		}
		
		return chkRange;
	}
	
	private int[] shiftLineIndex(int[] oriLineIdx,int startIdx,int stopIdx,int shiftVal){
		int start = 0, stop = 0, baseVal = 0;
		if(startIdx<0) startIdx = 0;
		if(startIdx>=oriLineIdx.length) startIdx = oriLineIdx.length - 1;
		if(stopIdx<0) stopIdx = 0;
		if(stopIdx>=oriLineIdx.length) stopIdx = oriLineIdx.length - 1;
		
		if(startIdx>stopIdx){
			start = stopIdx;
			stop = startIdx;
		}else{
			start = startIdx;
			stop = stopIdx;
		}
		
		if(shiftVal<0){
			for(int k=start;k<=stop;k++){
				oriLineIdx[k] = oriLineIdx[k] + shiftVal;
			}
		}else{
			baseVal = oriLineIdx[start];
			for(int k=start;k<=stop;k++){
				baseVal = baseVal + shiftVal;
				if(oriLineIdx[k]<baseVal) oriLineIdx[k] = oriLineIdx[k] + shiftVal;
			}
		}
		
		return oriLineIdx;
	}
	
	private int shiftCurrentLineNext(ImgExtractLine currLine, ImgExtractLine lastLine, ImgExtractLine nextLine, int currLineIdx, int targetLinesQty, 
										double[] weightCurLine, double[] weightLastLine, double[] weightNextLine, boolean curLineIsLonger, int[][] imgGrays,
										LinkedHashMap<Integer, ImgExtractLine> linesMap, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean curLineIsThicker = false, curLineOffsetIsOK = false, curLineLengthIsOK = false, overhangFailed = false;
		boolean lastLineLengthIsOK = false, nextLineLengthIsOK = false;
		double curLineOffset = 0.0, lastLineOffset = 0.0, nextLineOffset = 0.0;
		double offsetChgR0 = 0.0, offsetChgR1 = 0.0, weightDiff = 0.0;
		int maxValidPtsLineIdxDelta = 0, shiftFlag = 0, peakFlag = 0;
		
		shiftFlag = 0;//Default is no need to shift current line
		curLineOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
		if(null!=lastLine){
			lastLineOffset = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
		}else{
			return shiftFlag;
		}
		
		if(1==currLineIdx%2){
			offsetChgR0 = (curLineOffset - lastLineOffset) / oddPoleAvgOffset;
		}else{
			offsetChgR0 = (curLineOffset - lastLineOffset) / evenPoleAvgOffset;
		}
		
		if(null!=nextLine){
			nextLineOffset = nextLine.getLineIntercept()+nextLine.getLineInterceptDelta();
			if(0==(currLineIdx+1)%2){
				offsetChgR1 = (nextLineOffset - curLineOffset) / evenPoleAvgOffset;
			}else{
				offsetChgR1 = (nextLineOffset - curLineOffset) / oddPoleAvgOffset;
			}
		}
		
		curLineLengthIsOK = (curLineIsLonger && weightCurLine[0]>=0.5 || !curLineIsLonger && weightCurLine[0]<0.5);
		curLineOffsetIsOK = (offsetChgR0>minOffsetChgRate && offsetChgR0<maxOffsetChgRate);
		
		lastLineLengthIsOK = (curLineIsLonger && weightLastLine[0]<0.5 || !curLineIsLonger && weightLastLine[0]>=0.5);
		if(null!=nextLine){
			nextLineLengthIsOK = (curLineIsLonger && weightNextLine[0]<0.5 || !curLineIsLonger && weightNextLine[0]>=0.5);
			weightDiff = Math.abs(weightCurLine[0]-weightNextLine[0]);
		}
		
		//Pre-screen conditions
		if(curLineLengthIsOK && lastLineLengthIsOK && nextLineLengthIsOK) return shiftFlag;
		
		if(curLineLengthIsOK && curLineOffsetIsOK){
			if(null!=nextLine && currLineIdx==targetLinesQty-2){
				if(offsetChgR0>maxOffsetChgRate*0.8 || offsetChgR1>maxOffsetChgRate || offsetChgR1<minOffsetChgRate){
					peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
					if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
					if(0==peakFlag){
						shiftFlag = 1;//Current line shift next
					}else if(!curLineIsLonger && weightNextLine[0]>weightCurLine[0] && weightDiff>0.2){
						//Suppose current line is correct
					}else if(offsetChgR0>maxOffsetChgRate*0.8){
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
						if(overhangFailed && weightDiff>0.2){
							maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
									-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
							if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
						}
					}
				}
			}
		}else{
			if(curLineLengthIsOK && offsetChgR0<=minOffsetChgRate){
				return shiftFlag;
			}else if(curLineLengthIsOK && offsetChgR0>=maxOffsetChgRate || !curLineLengthIsOK && curLineOffsetIsOK){//Possibly need to shift next
				if(currLineIdx!=targetLinesQty-2){
					if(thereIsPoleBtw(imgGrays,currLine,lastLine,true)){
						shiftFlag = 1;//Current line shift next
					}else{
						return shiftFlag;
					}
				}else{
					curLineIsThicker = lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0);
					if(firstPoleIsThicker && curLineIsThicker) return shiftFlag;
					
					if(null!=nextLine){
						if(curLineOffsetIsOK && lastLineLengthIsOK && nextLineLengthIsOK && offsetChgR1>minOffsetChgRate && offsetChgR1<maxOffsetChgRate
							&& !curLineIsLonger && weightNextLine[0]-weightCurLine[0]>0.2){
							//Suppose current line is correct
						}else{
							overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
							if(overhangFailed){
								peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
								if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
								if(offsetChgR1>maxOffsetChgRate || offsetChgR1<minOffsetChgRate){//Next line is out of expectation
									if(0==peakFlag){
										shiftFlag = 1;//Current line shift next
									}else{
										if(!curLineLengthIsOK){
											if(weightDiff>0.2) shiftFlag = 1;//Current line shift next(Give it a try)
										}
									}
								}else{
									if(curLineLengthIsOK){
										if(0==peakFlag) shiftFlag = 1;//Current line shift next
									}else{
										if(weightDiff>0.2) shiftFlag = 1;//Current line shift next(Give it a try)
									}
								}
							}else{
								if(!curLineLengthIsOK){
									if(offsetChgR0>maxOffsetChgRate*0.72){
										if(weightDiff>0.2){
											shiftFlag = 1;//Current line shift next(Give it a try)
										}else{
											maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
													-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
											if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
										}
									}
								}
							}
						}
					}else{
						maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
								-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx-1,lastLine,currLine,weightLastLine[0],weightCurLine[0]);
						if(0==maxValidPtsLineIdxDelta && overhangFailed){//There is no potential line after current line and overhang is NG btw current line and last line
							shiftFlag = 1;//Current line shift next(Give it a try)
						}
					}
				}
			}else if(!curLineLengthIsOK && offsetChgR0<=minOffsetChgRate){//Current line is too closed to last line, should be skipped
				shiftFlag = -1;//Skip current line
			}else if(!curLineLengthIsOK && offsetChgR0>=maxOffsetChgRate){//Possibly need to shift next
				if(currLineIdx==targetLinesQty-2){
					curLineIsThicker = lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0);
					if(firstPoleIsThicker && curLineIsThicker) return shiftFlag;
					
					peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,lastLineOffset);
					if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,(curLineOffset+lastLineOffset)/2,curLineOffset);
					if(0==peakFlag){
						shiftFlag = 1;//Current line shift next
					}else if(offsetChgR0>maxOffsetChgRate*0.8 && null!=nextLine){
						overhangFailed = twoNearLinesOverhangFailed(currLineIdx,currLine,nextLine,weightCurLine[0],weightNextLine[0]);
						if(overhangFailed && weightDiff>0.2){
							if(offsetChgR0>maxOffsetChgRate && weightDiff>0.5){
								shiftFlag = 1;
							}else{
								maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
										-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
								if(0==maxValidPtsLineIdxDelta) shiftFlag = 1;//Current line shift next(Give it a try)
							}
						}
					}
				}
			}
		}
		
		return shiftFlag;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> doubleCheckAllLinesNew(LinkedHashMap<Integer, ImgExtractLine> oriLinesMap, int[][] peakVals, int[][] initVals, int[][] imgGrays, boolean evenLineLonger, int targetLinesQty, double evenPoleAvgOffset, double oddPoleAvgOffset, double linesTendency_Slope, double linesTendency_Offset){
		LinkedHashMap<Integer, ImgExtractLine> linesMap = new LinkedHashMap<Integer, ImgExtractLine>();
		LinkedHashMap<Integer, ImgExtractLine> newLinesMap = new LinkedHashMap<Integer, ImgExtractLine>();
		ImgExtractLine currLine = null, nextLine = null, lastLine = null;
		
		for(int i=0; i<targetLinesQty; i++){
			if(null!=oriLinesMap.get(i)) linesMap.put(i, oriLinesMap.get(i));
		}
		int[] newLineIdx = new int[linesMap.size()];
		int[] oriLineIdx = new int[linesMap.size()];
		
		int idx = -1, lineIdx = -1, shiftFlag = 0, maxValidPtsLineIdxDelta = 0;
		int[] weightChkRange = null;
		boolean curLineIsLonger = false, curLineIsConfirmed = false, overhangFailed = false;
		boolean curLineLengthIsOK = false, curLineOffsetIsOK = false;
		boolean lastLineLengthIsOK = false, nextLineLengthIsOK = false;
		double[] weightCurLine = null, weightLastLine = null, weightNextLine = null, weight3 = null;
		double offsetChgR0 = 0.0, offsetChgR1 = 0.0, offsetChgR2 = 0.0;
		double nextLineOffset = 0.0, lastLineOffset = 0.0, curLineOffset = 0.0;
		
		for(int key:linesMap.keySet()){
			idx++;
			newLineIdx[idx] = key;//The final line index(will be adjusted in this routine)
			oriLineIdx[idx] = key;//The 1st guessing line index
		}
		
		for(int i=0; i<=idx; i++){
			if(newLineIdx[i]>=targetLinesQty) break;
			offsetChgR0 = 0.0; offsetChgR1 = 0.0; offsetChgR2 = 0.0;
			weightLastLine = null; weightNextLine = null;
			lastLineLengthIsOK = false; nextLineLengthIsOK = false;
			lineIdx = oriLineIdx[i];
			currLine = linesMap.get(lineIdx);//The line to be checked
			lastLine = newLinesMap.get(newLineIdx[i]-1);
			nextLine = linesMap.get(lineIdx+1);
			if(null!=currLine){
				if(currLine.getLineChecked()){
					newLinesMap.put(newLineIdx[i], currLine);
					continue;
				}
				curLineIsLonger = curLineIsLonger(newLineIdx[i],evenLineLonger);
				curLineOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				if(null!=lastLine){
					lastLineOffset = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
				}else{
					lastLineOffset = linesTendency_Slope*(newLineIdx[i]-1)+linesTendency_Offset;
				}
				if(1==newLineIdx[i]%2){
					offsetChgR0 = (curLineOffset - lastLineOffset) / oddPoleAvgOffset;
				}else{
					offsetChgR0 = (curLineOffset - lastLineOffset) / evenPoleAvgOffset;
				}
				if(offsetChgR0<0) continue;
				
				if(null!=nextLine){
					nextLineOffset = nextLine.getLineIntercept()+nextLine.getLineInterceptDelta();
					if(0==(newLineIdx[i]+1)%2){
						offsetChgR1 = (nextLineOffset - curLineOffset) / evenPoleAvgOffset;
						offsetChgR2 = (nextLineOffset - lastLineOffset) / evenPoleAvgOffset;
					}else{
						offsetChgR1 = (nextLineOffset - curLineOffset) / oddPoleAvgOffset;
						offsetChgR2 = (nextLineOffset - lastLineOffset) / oddPoleAvgOffset;
					}
				}
				
				if(12==lineIdx){
					System.out.print("");
				}
				
				weightChkRange = getWeightChkRange(linesMap,newLinesMap,lineIdx,newLineIdx[i]);
				weightCurLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, true, curLineIsLonger(newLineIdx[i],evenLineLonger), false);
				if(null!=lastLine){
					weightLastLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, newLineIdx[i]-1, targetLinesQty, true, curLineIsLonger(newLineIdx[i]-1,evenLineLonger), false);
					lastLineLengthIsOK = (curLineIsLonger && weightLastLine[0]<0.5 || !curLineIsLonger && weightLastLine[0]>=0.5);
				}
				if(null!=nextLine){
					weightNextLine = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx+1, targetLinesQty, true, curLineIsLonger(newLineIdx[i]+1,evenLineLonger), false);
					nextLineLengthIsOK = (curLineIsLonger && weightNextLine[0]<0.5 || !curLineIsLonger && weightNextLine[0]>=0.5);
				}
				
				curLineLengthIsOK = (curLineIsLonger && weightCurLine[0]>=0.5 || !curLineIsLonger && weightCurLine[0]<0.5);
				curLineOffsetIsOK = (offsetChgR0>minOffsetChgRate && offsetChgR0<maxOffsetChgRate);
				
				curLineIsConfirmed = false;
				//1.Expected case handling - Length of current pole is in expectation
				if(curLineLengthIsOK){
					//Offset variation of the most inner two poles could be bigger
					if(newLineIdx[i]==targetLinesQty-2){
						if(null!=nextLine){
							if(nextLine.getLineChecked()){//The most inner pole has confirmed
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
						//Length of current,left and right poles is in expectation
						if(!curLineIsConfirmed && lastLineLengthIsOK && nextLineLengthIsOK
							&& offsetChgR0>minOffsetChgRate*0.75){ //Pole offset meets the lower limit
							currLine.setLineChecked(true);
							newLinesMap.put(newLineIdx[i], currLine);
							curLineIsConfirmed = true;
						}
						//Offset of current pole is in control limit
						if(!curLineIsConfirmed){
							shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
									weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
									newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
							if(0<=shiftFlag){
								//Shift current line to next line
								if(1==shiftFlag) newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}else if(null!=lastLine && offsetChgR0>minOffsetChgRate*0.75 //Lower offset control limit could be loser while pole length is in expectation
						&& offsetChgR0<=maxOffsetChgRate //Pole offset is in control limit
						|| 0==newLineIdx[i] //Current line represents the most outer pole(the 1st pole)
						|| null!=lastLine && 1==currLine.getLineFlag() //Last line is fixed and current line is in the expected tendency
						|| null!=lastLine && curLineOffsetIsOK //Pole offset is in control limit
							//Current pole is the most inner pole and last pole is fixed
							&& newLineIdx[i]==targetLinesQty-1){
						//Key conditions:
						//(1)Last pole is fixed and offset of current pole is in ctrl limit
						//(2)Last pole is fixed and current pole is in ctrl tendency
						currLine.setLineChecked(true);
						newLinesMap.put(newLineIdx[i], currLine);
						curLineIsConfirmed = true;
					}
				}else if(0==newLineIdx[i] //Current line represents the most outer pole(the 1st pole)
					&& (offsetChgR0<=maxOffsetChgRate //Pole offset is in control criteria
						|| curLineIsLonger && weightCurLine[0]<0.5 //Length of current pole and next pole is very closed
						//Length of the most outer pole is not expected, which is usually caused by a longer
						//pole clings to the most outer short pole which leads to failed detection of short pole
						|| !curLineIsLonger && weightCurLine[0]>=0.5)){
					currLine.setLineChecked(true);
					newLinesMap.put(newLineIdx[i], currLine);
					curLineIsConfirmed = true;
				}else if(evenLineLonger && 1==newLineIdx[i]
					&& weightCurLine[0]>=0.5
					&& offsetChgR0>minOffsetChgRate*0.6){
					currLine.setLineChecked(true);
					newLinesMap.put(newLineIdx[i], currLine);
					curLineIsConfirmed = true;
				}
				
				//2.Common case handling
				if(!curLineIsConfirmed){//Length of current pole is out of expectation
					//2-1.Try to fix last pole first
					if(null==lastLine){ //Last pole is missing
						if(offsetChgR0<minOffsetChgRate //Current pole is too closed to last pole
							//Length of current pole is not expected
							|| offsetChgR0<maxOffsetChgRate*0.85 && !curLineLengthIsOK
							//Current line represents negative pole and last pole is negative pole
							|| offsetChgR0<maxOffsetChgRate*0.85 
								&& lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0) //Current line represents negative pole
								&& lineIsNegPole(newLineIdx[i]-1,evenLineLonger,evenPoleAvgOffset,oddPoleAvgOffset) //Last pole is negative pole
							//Current line represents the most inner pole and last pole is negative pole
							|| offsetChgR0<maxOffsetChgRate*0.75 && newLineIdx[i]==targetLinesQty-1 
								&& lineIsNegPole(newLineIdx[i]-1,evenLineLonger,evenPoleAvgOffset,oddPoleAvgOffset) //Last pole is negative pole
							//Current line represents the most inner pole and length of current pole is not expected
							|| offsetChgR0<maxOffsetChgRate*1.5 && newLineIdx[i]==targetLinesQty-1 
								&& (curLineIsLonger && weightCurLine[0]<0.45 //Length of current pole is not expected
									|| !curLineIsLonger && weightCurLine[0]>=0.5)){
							if(!lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0)
								&& newLineIdx[i]==targetLinesQty-1
								&& curLineIsLonger && weightCurLine[0]>0.5){
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}else{
								//Shift current line to previous line
								newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,-1);
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}else if((offsetChgR0>maxOffsetChgRate || newLineIdx[i]==targetLinesQty-1)//Offset of current pole is bigger or current pole is the most inner pole
							&& (curLineIsLonger && weightCurLine[0]>0.45 //Length of current pole is in expectation
								|| !curLineIsLonger && weightCurLine[0]<0.5)){
								//Offset of current pole exceeds upper limit but length of it is in expectation
								if(newLineIdx[i]==targetLinesQty-1 && curLineIsLonger
									&& weightCurLine[0]>=0.5 && lineIsThicker(weightCurLine,imgGrays,currLine,lastLine,offsetChgR0)){
									//Shift current line to previous line
									newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,-1);
								}
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
						}
					}
					//2-2.Refer to next line first since last line is supposed correct
					if(!curLineIsConfirmed && null!=nextLine){
						if(nextLineLengthIsOK){//Length of next pole is in expectation
							if(curLineLengthIsOK && nextLineLengthIsOK){
								//Offset of both current and next poles is on target
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}else{//Length of next pole is out of expectation
							if(offsetChgR1<minOffsetChgRate && offsetChgR2<maxOffsetChgRate){//Next pole is too closed to current pole
								if(newLineIdx[i]==targetLinesQty-2 && nextLine.getLineChecked()){
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}else{
									//Shift next line to current line
									newLineIdx=shiftLineIndex(newLineIdx,i+1,linesMap.size()-1,-1);
									nextLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], nextLine);//Shift next line to current line
								}
								curLineIsConfirmed = true;
							}else if((offsetChgR0>maxOffsetChgRate*0.85 || newLineIdx[i]==targetLinesQty-2 && offsetChgR0>minOffsetChgRate*0.6)//Offset of current pole is in expectation
									//Current pole is longer(expect shorter) than next pole
									&& !curLineIsLonger && weightCurLine[0]-weightNextLine[0]>0.15
							){
								//TODO Verification
								shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
										weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
										newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
								if(0<=shiftFlag){
									//Shift current line to next line
									if(1==shiftFlag) newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
								}
								curLineIsConfirmed = true;
							}else if(offsetChgR0>maxOffsetChgRate){
								maxValidPtsLineIdxDelta = getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+5)
										-getMaxValidDataPtsLineIndex(allPossibleLines,curLineOffset-5,curLineOffset+30);
								overhangFailed = twoNearLinesOverhangFailed(newLineIdx[i],currLine,nextLine,weightCurLine[0],weightNextLine[0]);
								if(0==maxValidPtsLineIdxDelta || overhangFailed){
									//Shift current line to next line
									newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
								}
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}else if(offsetChgR0>minOffsetChgRate*0.6 && offsetChgR1<maxOffsetChgRate
								&& 1==currLine.getLineFlag()){
								//Offset of next pole is in expectation
								//Offset of current pole meets the lower limit and it is in expecting tendency
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}
					//2-3.Refer to last line
					if(!curLineIsConfirmed && null!=lastLine){
						if(lastLineLengthIsOK){//Length of last pole is in expectation
							if(newLineIdx[i]==targetLinesQty-2){
								if(offsetChgR0>minOffsetChgRate*0.5){
									shiftFlag = shiftCurrentLineNext(currLine, lastLine, nextLine, newLineIdx[i], targetLinesQty, 
											weightCurLine, weightLastLine, weightNextLine, curLineIsLonger, imgGrays,
											newLinesMap, evenPoleAvgOffset, oddPoleAvgOffset);
									if(1==shiftFlag){
										//Shift current line to next line
										newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
									}
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}
							}else if(newLineIdx[i]==targetLinesQty-1 && curLineIsLonger){
								if(weightCurLine[0]>0.5 && currLine.getTendencyRSQ()>minBestRsq){
									currLine.setLineChecked(true);
									newLinesMap.put(newLineIdx[i], currLine);
									curLineIsConfirmed = true;
								}else{
									//Enlarge inner side searching range
									double researchOffset = currLine.getLineIntercept()+currLine.getLineInterceptDelta()+3;
									double researchOffsetStop = researchOffset + (evenPoleAvgOffset+oddPoleAvgOffset)/2*3;
									double researchSlope = currLine.getLineSlope();
									ImgExtractLine exLine = null;
									exLine = searchLine(peakVals, initVals, imgGrays, 255, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
									if(null!=exLine){
										linesMap.put(lineIdx+1, exLine);
										weight3 = currLine.weightOfBeingLine(linesMap, weightChkRange[1], weightChkRange[0], 0, imgGrays, peakVals, 5, lineIdx+1, targetLinesQty, true, curLineIsLonger(newLineIdx[i],evenLineLonger), false);
										if(weight3[0]>0.5 && weight3[0]>weightCurLine[0]
											|| weight3[0]>weightCurLine[0] && currLine.getTendencyRSQ()<minBestRsq){
											exLine.setLineChecked(true);
											newLinesMap.put(newLineIdx[i], exLine);
											curLineIsConfirmed = true;
										}
									}
									if(!curLineIsConfirmed){
										currLine.setLineChecked(true);
										newLinesMap.put(newLineIdx[i], currLine);
										curLineIsConfirmed = true;
									}
								}
							}
							
							//Offset of current pole is in a more expecting range
							if(!curLineIsConfirmed && offsetChgR0>minOffsetChgRate*1.1 && offsetChgR0<maxOffsetChgRate){
								currLine.setLineChecked(true);
								newLinesMap.put(newLineIdx[i], currLine);
								curLineIsConfirmed = true;
							}
						}
					}
				}
				
				//3.Abnormal case handling
				if(!curLineIsConfirmed){
					if(null!=lastLine && null!=nextLine){
						//Length of last and next poles is in expectation
						//Offset of last and next poles exceed the upper limit(they are far way from current pole)
						//Length of current pole is out of expectation
						if(offsetChgR0>maxOffsetChgRate && offsetChgR0<maxOffsetChgRate*1.5
							&& offsetChgR1>maxOffsetChgRate && offsetChgR1<maxOffsetChgRate*1.5
							&& (curLineIsLonger && weightCurLine[0]<0.5 
									&& weightLastLine[0]<0.5 && weightNextLine[0]<0.5
								|| !curLineIsLonger && weightCurLine[0]>=0.5
									&& weightLastLine[0]>=0.5 && weightNextLine[0]>=0.5)){
							//Shift current line to next line
							newLineIdx=shiftLineIndex(newLineIdx,i,linesMap.size()-1,1);
							currLine.setLineChecked(true);
							newLinesMap.put(newLineIdx[i], currLine);
							curLineIsConfirmed = true;
						}
					}
				}
			}
		}
		
		return newLinesMap;
	}
	
	private LinkedHashMap<Double,Double> getWrinklePtsEx(ImgExtractLine curLine, int[][] peakVals, int wrinkleStartChkPos, int wrinkleStopChkPos, int wrinkleLineMaxOffset, int maxChkOffset, boolean chkDownSide){
		LinkedHashMap<Double,Double> wrinklePts = new LinkedHashMap<Double,Double>();
		double tmpSlope = curLine.getLineSlope();
		double tmpOffset = curLine.getLineIntercept()+curLine.getLineInterceptDelta();
		int y = 0, nearCol = 0, imgHeight = peakVals[0].length;
		int minX = wrinkleStartChkPos, startY = (int)(wrinkleStartChkPos*tmpSlope+tmpOffset);
		
		boolean bFound = false;
		String[] pt = null;
		int xDelta = 0, yDelta = 0;
		ArrayList<ArrayList<String>> wrinkleLines = new ArrayList<ArrayList<String>>();
		ArrayList<String> pts = new ArrayList<String>();
		for(int x=wrinkleStartChkPos; x>wrinkleStopChkPos; x--){
			nearCol = (int)(x*tmpSlope+tmpOffset);
			for(int n=0; n<=(int)maxChkOffset; n++){
				if(chkDownSide){
					y = nearCol + n;
				}else{
					y = nearCol - n;
				}
				if(y>=0 && y<imgHeight && peakVals[x][y]>0 && peakVals[x][y]<noiseGrayThr){
					if(minX>x) minX = x;
					if(wrinkleLines.isEmpty()){
						pts.add(x+","+y);
						wrinkleLines.add(pts);
					}else{
						bFound = false;
						for(int i=0; i<wrinkleLines.size(); i++){
							pts = wrinkleLines.get(i);
							pt = pts.get(pts.size()-1).split(",");
							xDelta = Integer.parseInt(pt[0]) - x;
							yDelta = y - Integer.parseInt(pt[1]);
							if(Math.abs(yDelta)<lineScanRange/2 && xDelta<lineScanRange){
								bFound = true;
								pts.add(x+","+y);
								wrinkleLines.remove(i);
								wrinkleLines.add(i, pts);
							}
						}
						if(!bFound){
							pts = new ArrayList<String>();
							pts.add(x+","+y);
							wrinkleLines.add(pts);
						}
					}
				}
			}
		}
		
		double onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		double minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		
		double[] coef = null;
		double tmpAngle = 0.0, crossX = 0.0, maxAngle = -1, delta = 0.0;
		int maxAngleIdx = -1, maxSizeIdx = -1, maxSize = -1;
		ArrayList<LinkedHashMap<Double,Double>> tmpLines = new ArrayList<LinkedHashMap<Double,Double>>();
		if(wrinkleLines.size()>0){
			for(int i=0; i<wrinkleLines.size(); i++){
				pts = wrinkleLines.get(i);
				if(pts.size()>=5){
					LinkedHashMap<Double,Double> tmpLine = new LinkedHashMap<Double,Double>();
					for(int j=0; j<pts.size(); j++){
						pt = pts.get(j).split(",");
						tmpLine.put(Double.parseDouble(pt[0]), Double.parseDouble(pt[1]));
					}
					tmpLines.add(tmpLine);
					if(maxSize<0){
						maxSize = tmpLine.size();
						maxSizeIdx = 0;
					}else if(maxSize<tmpLine.size()){
						maxSize = tmpLine.size();
						maxSizeIdx = tmpLines.size()-1;
					}
					
					yDelta = 0; xDelta = 0;
					pt = pts.get(0).split(",");
					xDelta = wrinkleStartChkPos - Integer.parseInt(pt[0]);
					if(chkDownSide){
						yDelta = Integer.parseInt(pt[1]) - startY;
					}else{
						yDelta = startY - Integer.parseInt(pt[1]);
					}
					
					tmpAngle = -1;
					coef = MathUtils.lineFitting(tmpLine);
					if(-1!=tmpSlope*coef[0]){
						tmpAngle = (tmpSlope-coef[0])/(1+tmpSlope*coef[0]);
						tmpAngle = Math.toDegrees(Math.atan(tmpAngle));
					}
					if(tmpAngle>0){
						crossX = (coef[1]-tmpOffset)/(tmpSlope-coef[0]);
						delta = crossX - wrinkleStartChkPos;
						if(maxAngle<tmpAngle && Math.abs(delta)<lineScanRange*6 
							&& yDelta<lineScanRange*3
							&& !(xDelta>lineScanRange*4 
								&& yDelta>lineScanRange/2
								&& delta<minDistance)
							&& !(tmpLine.size()<lineScanRange*1.5
								&& yDelta>lineScanRange*1.5)){
							//Conditions
							//1.Cross point is close to the curve starting point
							//2.First point of the wrinkle line is close to the checked layer
							maxAngle=tmpAngle;
							maxAngleIdx = tmpLines.size() - 1;
						}
					}
				}
			}
			if(maxAngleIdx>=0){
				wrinklePts = tmpLines.get(maxAngleIdx);
			}else if(maxSizeIdx>=0){
				wrinklePts = tmpLines.get(maxSizeIdx);
				coef = MathUtils.lineFitting(wrinklePts);
				crossX = (coef[1]-tmpOffset)/(tmpSlope-coef[0]);
				delta = crossX - wrinkleStartChkPos;
				if(delta<lineScanRange*(-2) || delta>lineScanRange*2){
					yDelta = 0; xDelta = 0;
					for(Double x:wrinklePts.keySet()){
						xDelta = (int)(wrinkleStartChkPos - x);
						if(chkDownSide){
							yDelta = (int)(wrinklePts.get(x) - startY);
						}else{
							yDelta = (int)(startY - wrinklePts.get(x));
						}
						break;
					}
					
					tmpAngle = -1;
					if(-1!=tmpSlope*coef[0]){
						tmpAngle = (tmpSlope-coef[0])/(1+tmpSlope*coef[0]);
						tmpAngle = Math.toDegrees(Math.atan(tmpAngle));
					}
					
					double x0=0.0,y0=0.0;
					for(Double x:wrinklePts.keySet()){
						x0 = x; y0 = wrinklePts.get(x);
					}
					wrinklePts.clear();
					
					if(tmpAngle>0 && tmpAngle<5 && delta>lineScanRange*2
						&& yDelta<=lineScanRange/2 && xDelta<=lineScanRange/2){
						double x1,y1,newSlope,newOffset,xStep;
						x1=wrinkleStartChkPos;y1=tmpSlope*x1+tmpOffset;
						newSlope=(y1-y0)/(x1-x0);
						newOffset = y1-newSlope*x1;
						xStep = (x1-x0)/10;
						
						for(double x=x0; x<=x1; x=x+xStep){
							wrinklePts.put(x, newSlope*x+newOffset);
						}
					}
				}
			}
		}
		if(wrinklePts.size()>0){
			coef = MathUtils.lineFitting(wrinklePts);
			wrinklePts.put((double)minX, coef[0]*minX+coef[1]);
		}
		
		return wrinklePts;
	}
	
	private String getResultKey(int layerIdx){
		String procRsltKey = "";
		
		if(0==layerIdx%2){
			procRsltKey = "L" + (layerIdx/2) + "_L";
		}else{
			procRsltKey = "L" + ((layerIdx+1)/2) + "_R";
		}
		
		return procRsltKey;
	}
	
	private boolean twoNearLinesOverhangFailed(int curLineIdx, ImgExtractLine curLine, ImgExtractLine nextLine, double curLineWeight, double nextLineWeight){
		boolean failed = true;
		double minDistance = 10;//pixels
		double maxDistance = 116;//pixels
		double onePixelLen = 0.012;
		double overhang = 0.0;
		int refCurrLine = 0, refNextLine = 0;
		
		onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		
		if(null!=curLine && null!=nextLine){
			if(evenPoleIsLonger && 0==curLineIdx%2 || !evenPoleIsLonger && 1==curLineIdx%2){
				refCurrLine = (int)(curLine.getXAxisStop() + (curLine.getXAxisStart()-curLine.getXAxisStop())*(1-curLineWeight));
				refNextLine = (int)(nextLine.getXAxisStart() - (nextLine.getXAxisStart()-nextLine.getXAxisStop())*nextLineWeight);
			}else{
				refCurrLine = (int)(curLine.getXAxisStart() - (curLine.getXAxisStart()-curLine.getXAxisStop())*curLineWeight);
				refNextLine = (int)(nextLine.getXAxisStop() + (nextLine.getXAxisStart()-nextLine.getXAxisStop())*(1-nextLineWeight));
			}
			
			if(firstPoleIsLonger){
				overhang = evenPoleIsLonger?refNextLine - refCurrLine:refCurrLine - refNextLine;
			}else{
				overhang = !evenPoleIsLonger?refCurrLine - refNextLine:refNextLine - refCurrLine;
			}
			if(overhang>=minDistance && overhang<=maxDistance) failed = false;
		}
		
		return failed;
	}
	
	private boolean calculateFinalResult(LinkedHashMap<Integer, ImgExtractLine> linesMap, boolean evenLineLonger, int[][] imgGrays, int defaultVal, int targetLinesQty, int[][] peakVals, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean bPassed = false, curLinePassed = false;
		double minDistance = 10;//pixels
		double maxDistance = 116;//pixels
		double maxPoleAngle = 25;//degrees
		double maxMissedCheckRate = 0.0, minPassedRate = 1.0, onePixelLen = 0.012;
		int meetCndQty = 0, missedCheckQty = 0;
		double missedCheckRate = 0.0, passedRate = 0.0;
		int imgHeight = imgGrays[0].length;
		String procRsltKey = "";
		
		onePixelLen = Double.parseDouble(""+criteria.get("onePixel"));
		minDistance = Double.parseDouble(""+criteria.get("minPoleDistance"))/onePixelLen;
		maxDistance = Double.parseDouble(""+criteria.get("maxPoleDistance"))/onePixelLen;
		maxPoleAngle = Double.parseDouble(""+criteria.get("maxPoleAngle"));
		
		int[] distances = new int[targetLinesQty];
		int lineCounter = 0;
		for(int i=0; i<targetLinesQty; i++){
			curLinePassed = false;
			ImgExtractLine exLine = linesMap.get(i);
			if(null!=exLine){
				String grays = "";
				int start = 0, imgWidth = finalData.length, nearCol = 0;
				int lineFlag = lineIndexBase+i;
				double lineSlope = exLine.getLineSlope();
				double lineOffset = exLine.getLineIntercept()+exLine.getLineInterceptDelta();
				if(i>=10){
					start = exLine.getMostSharpChgPos(evenLineLonger,linesMap,i,imgGrays,peakVals,targetLinesQty);
				}else{
					if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
						start = exLine.getXAxisStop();
					}else{
						start = exLine.getXAxisStart();
					}
				}
				exLine.setPolePosition(start);
				if(i>0){
					procRsltKey = getResultKey(i);
					if(null!=linesMap.get(i-1)){
						if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
							distances[i] = linesMap.get(i-1).getPolePosition() - start;
						}else{
							distances[i] = start - linesMap.get(i-1).getPolePosition();
						}
						if(distances[i]>=minDistance && distances[i]<=maxDistance){
							meetCndQty++;
							curLinePassed = true;
						}else if(distances[i]<minDistance && i<10){
							//TODO Double check special case
							int[][] tmpGrays = new int[imgWidth][imgHeight];
							for(int k=0; k<imgWidth; k++){
								tmpGrays[k] = imgGrays[k].clone();
							}
							double tmpSlope = exLine.getLineSlope();
							double tmpOffset = exLine.getLineIntercept();
							double oriSlope = tmpSlope, oriOffset = tmpOffset;
							double maxDnChkOffset = 0.0, maxUpChkOffset = 0.0;
							boolean checkDnSide = false, checkUpSide = false;
							int newXAxisStop = -1, abnXAxisStop = -1, wrinkleLineMaxOffset = 0;
							int upStartChkPos = 0, dnStartChkPos = 0, dnCrossX = -1, upCrossX = -1;
							ImgExtractLine tmpLine = null;
							
							wrinkleLineMaxOffset = (int)(evenPoleAvgOffset+oddPoleAvgOffset)/2;
							maxDnChkOffset = (evenPoleAvgOffset+oddPoleAvgOffset)/2;
							maxUpChkOffset = maxDnChkOffset;
							if(curLineIsLonger(i, evenLineLonger)){
								//Current line is the longer one
								tmpLine = exLine;
								if(null!=linesMap.get(i-1) && null==linesMap.get(i-2)){
									maxUpChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i-1).getLineIntercept()-linesMap.get(i-1).getLineInterceptDelta();
									maxUpChkOffset = Math.abs(maxUpChkOffset)*1.5;
//									checkUpSide = true;
									upStartChkPos = linesMap.get(i-1).getXAxisStart();
								}
								if(null!=linesMap.get(i+1)){
									if(null!=linesMap.get(i+2)){
										maxDnChkOffset = linesMap.get(i+2).getLineIntercept()+linesMap.get(i+2).getLineInterceptDelta();
										maxDnChkOffset = maxDnChkOffset - tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
									}else{
										maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i+1).getLineIntercept()-linesMap.get(i+1).getLineInterceptDelta();
										maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
									}
									checkDnSide = true;
									dnStartChkPos = linesMap.get(i+1).getXAxisStart();
								}
							}else{
								//Last line is the longer one
								tmpLine = linesMap.get(i-1);
								tmpSlope = tmpLine.getLineSlope();
								tmpOffset = tmpLine.getLineIntercept();
								oriSlope = tmpSlope; oriOffset = tmpOffset;
								if(null!=linesMap.get(i-2) && null==linesMap.get(i-3)){
									maxUpChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-linesMap.get(i-2).getLineIntercept()-linesMap.get(i-2).getLineInterceptDelta();
									maxUpChkOffset = Math.abs(maxUpChkOffset)*1.5;
//									checkUpSide = true;
									upStartChkPos = linesMap.get(i-2).getXAxisStart();
								}
								if(null!=linesMap.get(i+1)){
									maxDnChkOffset = linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta();
									maxDnChkOffset = maxDnChkOffset-tmpLine.getLineIntercept()-tmpLine.getLineInterceptDelta()-3;
								}else{
									maxDnChkOffset = tmpLine.getLineIntercept()+tmpLine.getLineInterceptDelta()-exLine.getLineIntercept()-exLine.getLineInterceptDelta();
									maxDnChkOffset = Math.abs(maxDnChkOffset)*1.5;
								}
								checkDnSide = true;
								dnStartChkPos = exLine.getXAxisStart();
								if(1==tmpLine.getWrinkleFlag() || 3==tmpLine.getWrinkleFlag()){
									checkDnSide = false;
								}
							}
							
							int refPos = tmpLine.getPolePosition();
							int upSideGray = 0, dnSideGray = 0, scanLines = 3, minIdx = -1;
							int startChkPos = refPos - distances[i];
							if(startChkPos<0) startChkPos = 0;
							int stopChkPos = startChkPos - (int)maxDistance;
							if(stopChkPos<0) stopChkPos = 0;
							
							LinkedHashMap<Double,Double> dnSideWrinkleLine = new LinkedHashMap<Double,Double>();
							LinkedHashMap<Double,Double> upSideWrinkleLine = new LinkedHashMap<Double,Double>();
							//Check up side
							if(checkUpSide){
//								upSideWrinkleLine = getWrinklePts(tmpLine,peakVals,upStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxUpChkOffset,false);
//								upSideWrinkleLine = getWrinkleLineEx(tmpLine,upSideWrinkleLine,upStartChkPos,-maxUpChkOffset,maxPoleAngle,peakVals);
								upSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,upStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxUpChkOffset,false);
							}
							
							//Check down side
							if(checkDnSide){
//								dnSideWrinkleLine = getWrinklePts(tmpLine,peakVals,dnStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
//								dnSideWrinkleLine = getWrinkleLineEx(tmpLine,dnSideWrinkleLine,startChkPos,maxDnChkOffset,maxPoleAngle,peakVals);
								dnSideWrinkleLine = getWrinklePtsEx(tmpLine,peakVals,dnStartChkPos,stopChkPos,wrinkleLineMaxOffset,(int)maxDnChkOffset,true);
							}
							
							double[] dnLineParas = null, upLineParas = null;
							double dnSideAngle = 0.0, upSideAngle = 0.0;
							if(dnSideWrinkleLine.size()>=5){
								dnLineParas = MathUtils.lineFitting(dnSideWrinkleLine);
								dnSideAngle = 90.0;
								if(-1!=tmpSlope*dnLineParas[0]){
									dnSideAngle = Math.abs((tmpSlope-dnLineParas[0])/(1+tmpSlope*dnLineParas[0]));
									dnSideAngle = Math.toDegrees(Math.atan(dnSideAngle));
									dnCrossX = (int)((tmpOffset-dnLineParas[1])/(dnLineParas[0]-tmpSlope));
									System.out.println("Dn Side Angle:"+dnSideAngle);
								}
								tmpLine.setWrinkleFlag(1);
							}
							if(upSideWrinkleLine.size()>=5){
								upLineParas = MathUtils.lineFitting(upSideWrinkleLine);
								upSideAngle = 90.0;
								if(-1!=tmpSlope*upLineParas[0]){
									upSideAngle = Math.abs((tmpSlope-upLineParas[0])/(1+tmpSlope*upLineParas[0]));
									upSideAngle = Math.toDegrees(Math.atan(upSideAngle));
									upCrossX = (int)((tmpOffset-upLineParas[1])/(upLineParas[0]-tmpSlope));
									System.out.println("Up Side Angle:"+upSideAngle);
								}
								if(dnSideWrinkleLine.size()>=5){
									tmpLine.setWrinkleFlag(3);
								}else{
									tmpLine.setWrinkleFlag(2);
								}
							}
							if(!curLineIsLonger(i, evenLineLonger) && !checkDnSide){
								if(null!=imgProcResultAngle.get(procRsltKey) && imgProcResultAngle.get(procRsltKey)>maxPoleAngle){
									newXAxisStop = tmpLine.getXAxisStop();
								}
							}
							
							if(dnSideAngle>0 || upSideAngle>0){
								storeLayerAngle(evenLineLonger, i, dnSideAngle, upSideAngle);
								if(dnSideAngle>maxPoleAngle || upSideAngle>maxPoleAngle){
									if(0==i%2 && evenLineLonger || 1==i%2 &&!evenLineLonger){
										if(checkUpSide && upSideAngle>maxPoleAngle){
											abnXAxisStop = imgWidth;
											for(double k:upSideWrinkleLine.keySet()){
												if(k<abnXAxisStop) abnXAxisStop=(int)k;
											}
										}
									}else{
										if(checkDnSide && dnSideAngle>maxPoleAngle){
											abnXAxisStop = imgWidth;
											for(double k:dnSideWrinkleLine.keySet()){
												if(k<abnXAxisStop) abnXAxisStop=(int)k;
											}
										}
									}
									newXAxisStop = dnCrossX>upCrossX?dnCrossX:upCrossX;
									
									if(abnXAxisStop<0){
										dnSideAngle = 0; upSideAngle = 0;
									}
								}else{
									if(dnSideAngle>0 && dnSideAngle<=maxPoleAngle){
										upSideGray = dnSideGray + 1;
										minIdx = imgWidth;
										for(double k:dnSideWrinkleLine.keySet()){
											if(k<minIdx) minIdx=(int)k;
										}
										newXAxisStop = minIdx;
										for(int k=refPos; k>=minIdx; k--){
											nearCol = (int)(k*tmpSlope+tmpOffset);
											for(int n=(int)maxDnChkOffset;n>0;n--){
												if(nearCol+n>=0 && nearCol+n<imgHeight){
													if(imgGrays[k][nearCol+n]<defaultVal){
														if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
															tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
														}
													}
												}
											}
										}
									}else if(upSideAngle>0 && upSideAngle<=maxPoleAngle){
										dnSideGray = upSideGray + 1;
										minIdx = imgWidth;
										for(double k:upSideWrinkleLine.keySet()){
											if(k<minIdx) minIdx=(int)k;
										}
										if(newXAxisStop<0) newXAxisStop = minIdx;
										if(newXAxisStop>minIdx) newXAxisStop = minIdx;
										for(int k=(refPos+5); k>=minIdx; k--){
											nearCol = (int)(k*tmpSlope+tmpOffset);
											for(int n=(int)maxUpChkOffset;n>0;n--){
												if(nearCol-n>=0 && nearCol-n<imgHeight){
													if(imgGrays[k][nearCol-n]<defaultVal){
														if(tmpGrays[k][nearCol]>imgGrays[k][nearCol-n]){
															tmpGrays[k][nearCol]=imgGrays[k][nearCol-n];
														}
													}
												}
											}
										}
									}
								}
							}
							
							if(!(dnSideAngle>0 || upSideAngle>0) && -1==newXAxisStop){
								for(int k=refPos; k>0; k--){
									nearCol = (int)(k*tmpSlope+tmpOffset);
									if(nearCol>=1 && nearCol<imgHeight){
										upSideGray += imgGrays[k][nearCol-1];
										dnSideGray += imgGrays[k][nearCol+1];
									}
								}
								if(upSideGray>dnSideGray){//Check down side
									for(int k=refPos; k>0; k--){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=0 && nearCol<(imgHeight-scanLines)){
											for(int n=0; n<=scanLines; n++){
												if(imgGrays[k][nearCol+n]<defaultVal){
													if(tmpGrays[k][nearCol]>imgGrays[k][nearCol+n]){
														tmpGrays[k][nearCol]=imgGrays[k][nearCol+n];
													}
												}
											}
										}
									}
								}else if(upSideGray<dnSideGray){//Check up side
									for(int k=refPos; k>0; k--){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=scanLines && nearCol<imgHeight){
											for(int n=0; n<=scanLines; n++){
												if(imgGrays[k][nearCol-n]<defaultVal){
													if(tmpGrays[k][nearCol]>imgGrays[k][nearCol-n]){
														tmpGrays[k][nearCol] = imgGrays[k][nearCol-n];
													}
												}
											}
										}
									}
								}
							}
							
							int oriRefPos = tmpLine.getPolePosition();
							int startPos = 0, stopPos = 0, oriCol = 0;
							boolean bDnSideWrinkle = false;
							if(upSideGray>dnSideGray || dnSideGray>upSideGray || -1!=newXAxisStop){
								System.out.println("Ori start/stop:"+tmpLine.getXAxisStart()+"/"+tmpLine.getXAxisStop());
								if(newXAxisStop<0){
									tmpLine = setLineBoundary(tmpLine, tmpGrays, defaultVal);
								}else{
									tmpLine.setXAxisStop(newXAxisStop);
									if(tmpLine.getXAxisStart()<newXAxisStop) tmpLine.setXAxisStart(newXAxisStop);
								}
								System.out.println("Cur start/stop:"+tmpLine.getXAxisStart()+"/"+tmpLine.getXAxisStop());
								tmpLine.setPolePosition(tmpLine.getXAxisStop());//tmpLine is the longer pole
								
								if(curLineIsLonger(i, evenLineLonger)){
									linesMap.put(i, tmpLine);//Current line is the longer one
								}else{
									linesMap.put(i-1, tmpLine);//Last line is the longer one
								}
								
								if(0==i%2 && evenLineLonger || 1==i%2 && !evenLineLonger){
									distances[i] = linesMap.get(i-1).getPolePosition() - linesMap.get(i).getPolePosition();
								}else{
									distances[i] = linesMap.get(i).getPolePosition() - linesMap.get(i-1).getPolePosition();
								}
								//distances[i] = Math.abs(linesMap.get(i).getPolePosition() - linesMap.get(i-1).getPolePosition());
								if(distances[i]>=minDistance && distances[i]<=maxDistance){
									meetCndQty++;
									curLinePassed = true;
								}
								
								if(!curLinePassed) lineFlag = 4;
								refPos = tmpLine.getXAxisStop();
								if(refPos > oriRefPos){
									startPos = oriRefPos;
									stopPos = refPos;
								}else{
									startPos = refPos;
									stopPos = oriRefPos;
								}
								
								bDnSideWrinkle = false;
								if(dnSideAngle>0 || upSideAngle>0){
									if(dnSideAngle>upSideAngle){
										tmpSlope = dnLineParas[0];
										tmpOffset = dnLineParas[1];
										bDnSideWrinkle = true;
									}else{
										tmpSlope = upLineParas[0];
										tmpOffset = upLineParas[1];
									}
									for(int k=startPos; k<=stopPos; k++){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										oriCol = (int)(k*oriSlope+oriOffset);
										if(bDnSideWrinkle && nearCol<oriCol) nearCol = oriCol;
										if(!bDnSideWrinkle && nearCol>oriCol) nearCol = oriCol;
										if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
									}
								}else{
									for(int k=startPos; k<=stopPos; k++){
										nearCol = (int)(k*tmpSlope+tmpOffset);
										if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
									}
								}
							}
							
							if(null!=dnLineParas || null!=upLineParas){
								bDnSideWrinkle = false;
								if(null!=dnLineParas){
									tmpSlope = dnLineParas[0];
									tmpOffset = dnLineParas[1];
									bDnSideWrinkle = true;
									if(abnXAxisStop<0){
										abnXAxisStop = imgWidth;
										for(double k:dnSideWrinkleLine.keySet()){
											if(k<abnXAxisStop) abnXAxisStop=(int)k;
										}
									}
								}else{
									tmpSlope = upLineParas[0];
									tmpOffset = upLineParas[1];
									if(abnXAxisStop<0){
										abnXAxisStop = imgWidth;
										for(double k:upSideWrinkleLine.keySet()){
											if(k<abnXAxisStop) abnXAxisStop=(int)k;
										}
									}
								}
								for(int k=abnXAxisStop; k<=oriRefPos; k++){
									nearCol = (int)(k*tmpSlope+tmpOffset);
									oriCol = (int)(k*oriSlope+oriOffset);
									if(bDnSideWrinkle && nearCol<oriCol) nearCol = oriCol;
									if(!bDnSideWrinkle && nearCol>oriCol) nearCol = oriCol;
									if(nearCol>=0 && nearCol<imgHeight) finalData[k][nearCol] = lineFlag;
								}
							}
						}
						if(!curLinePassed) lineFlag = 4;//Draw the failed line
						imgProcResultLength.put(procRsltKey, distances[i]*onePixelLen);
						imgProcResultOK.put(procRsltKey, curLinePassed);
					}else{
						missedCheckQty++;
						imgProcResultLength.put(procRsltKey, 0.0);
						imgProcResultOK.put(procRsltKey, false);
					}
				}
				
				if(exLine.getCrossX()>0) start = exLine.getCrossX();
				for(int k=0; k<start; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					grays += "," + imgGrays[k][nearCol];
				}
				for(int k=start; k<imgWidth; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					finalData[k][nearCol] = lineFlag;
					grays += "," + imgGrays[k][nearCol];
				}
				
				lineCounter++;
				if(logEnabled){
					LogUtils.rawLog("sortLineParas_", exLine.printLineParas(i,1==lineCounter?true:false));
					LogUtils.rawLog("sortLineGrays_", "G"+i+grays);
				}
			}else{
				if(i>0) missedCheckQty++;
			}
		}
		
		//Most outer line special handling
		if(!evenLineLonger && null!=imgProcResultLength.get("L1_R") && null!=imgProcResultLength.get("L1_L")){
			double layer1R = imgProcResultLength.get("L1_R");
			double layer1L = imgProcResultLength.get("L1_L");
			if(layer1R>0 && layer1R<(minDistance*onePixelLen)
				&& layer1L>0 && layer1L>(minDistance*onePixelLen)){
				meetCndQty++;
			}
		}
		
		//Double check the result
		for(String key:imgProcResultOK.keySet()){
			if(!imgProcResultOK.get(key) && key.endsWith("_R")){
				if(null!=imgProcResultAngle.get(key.replace("_R", "_L"))){
					meetCndQty++;
					imgProcResultOK.put(key, true);
					imgProcResultLength.put(key, imgProcResultLength.get(key.replace("_R", "_L")));
				}
			}
		}
		
		missedCheckRate = (double)missedCheckQty / (targetLinesQty - 1);
		passedRate = (double)meetCndQty / (targetLinesQty - 1 - missedCheckQty);
		if(missedCheckRate<=maxMissedCheckRate && passedRate>=minPassedRate){
			bPassed = true;
		}
		
		return bPassed;
	}

	private void storeLayerAngle(boolean evenLineLonger, int layerIdx, double dnSideAngle, double upSideAngle) {
		if(dnSideAngle>0 || upSideAngle>0){
			String angleKey = "";
			if(curLineIsLonger(layerIdx, evenLineLonger)){
				if(0==layerIdx%2){
					angleKey = "L" + (layerIdx/2);
				}else{
					angleKey = "L" + ((layerIdx+1)/2);
				}
			}else{
				if(0==(layerIdx-1)%2){
					angleKey = "L" + ((layerIdx-1)/2);
				}else{
					angleKey = "L" + (layerIdx/2);
				}
			}
			angleKey = angleKey + (dnSideAngle>upSideAngle?"_L":"_R");
			imgProcResultAngle.put(angleKey, (dnSideAngle>upSideAngle?dnSideAngle:upSideAngle));
		}
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> searchMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap,
			ImgExtractLine myBaseline,int[][] peakVals, int[][] initVals, int[][]imgGrays, 
			int defaultVal, double[] slope, double[] offset, int bestRsqIdx,
			double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty, boolean chkMinOffset){
		
		double diff1,diff2,offsetChgR,addLineSlope,addLineOffset,off1,off2,curOffset;
		double researchSlope = myBaseline.getLineSlope(), researchOffset = myBaseline.getLineIntercept();
		double researchOffsetStop = 0;
		
		for(int i=0; i<targetLinesQty; i++){
			ImgExtractLine exLine = linesMap.get(i);
			if(null==exLine){
				if(null!=linesMap.get(i-1)){
					researchOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta();
				}else{
					researchOffset = slope[bestRsqIdx]*(i-1)+offset[bestRsqIdx];
				}
				
				if(null!=linesMap.get(i+1)){
					researchOffsetStop = linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta();
				}else{
					researchOffsetStop = slope[bestRsqIdx]*(i+1)+offset[bestRsqIdx];
				}
				off1 = researchOffset; off2 = researchOffsetStop;
				addLineSlope = researchSlope; addLineOffset = (researchOffset+researchOffsetStop)/2;
				if(0==i%2){
					researchOffset += evenPoleAvgOffset*0.9;
					researchOffsetStop -= (oddPoleAvgOffset*0.9>lineScanRange?lineScanRange:oddPoleAvgOffset*0.9);
					if(i==(targetLinesQty-1)) researchOffsetStop = researchOffset + oddPoleAvgOffset*1.5;
				}else{
					researchOffset += oddPoleAvgOffset*0.9;
					researchOffsetStop -= (evenPoleAvgOffset*0.9>lineScanRange?lineScanRange:evenPoleAvgOffset*0.9);
					if(i==(targetLinesQty-1)) researchOffsetStop = researchOffset + evenPoleAvgOffset*1.5;
				}
				if(researchOffsetStop-researchOffset<lineScanRange){
					researchOffset = (researchOffsetStop+researchOffset)/2-lineScanRange/2-1;
					researchOffsetStop = researchOffset+lineScanRange+1;
				}
				
				exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
				if(null!=exLine){
					if(null!=linesMap.get(i-2) && null!=linesMap.get(i-3)){
						diff1 = exLine.getLineIntercept()+exLine.getLineInterceptDelta()-researchOffset;
						diff2 = linesMap.get(i-2).getLineIntercept()-linesMap.get(i-3).getLineIntercept();
						diff2 += linesMap.get(i-2).getLineInterceptDelta()-linesMap.get(i-3).getLineInterceptDelta();
						offsetChgR = diff1/diff2;
						if(offsetChgR>maxOffsetChgRate){
							researchOffsetStop = exLine.getLineIntercept()+exLine.getLineInterceptDelta() - lineScanRange/2;
							exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
						}
						else if(chkMinOffset && offsetChgR<minOffsetChgRate){
							curOffset = exLine.getLineIntercept()+exLine.getLineInterceptDelta();
							if(off2-curOffset<curOffset-off1){
								exLine = addFixedLine(peakVals,imgGrays,defaultVal,addLineSlope,addLineOffset);
							}
						}
					}
					if(null!=exLine){
						exLine.setLineFlag(3);
						linesMap.put(i, exLine);
					}
				}
				System.out.println((null==exLine?"Missing:":"Insert:")+i);
			}else{
				researchSlope = linesMap.get(i).getLineSlope();
			}
		}
		
		return linesMap;
	}
	
	private boolean thereIsMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap, int targetLinesQty){
		boolean missing = false;
		
		for(int i=0; i<targetLinesQty; i++){
			if(null == linesMap.get(i)){
				missing = true;
				break;
			}
		}
		return missing;
	}
	
	private boolean lineIsNegPole(int lineIdx, boolean evenLineLonger, double evenPoleAvgOffset, double oddPoleAvgOffset){
		boolean isNegPole = false;
		
		if(0==lineIdx%2 && !evenLineLonger || 1==lineIdx%2 && evenLineLonger){
			if(evenPoleAvgOffset>oddPoleAvgOffset) isNegPole = true;
		}
		
		return isNegPole;
	}
	
	private ImgExtractLine getMostClosedLine(double offset, double tolerance){
		ImgExtractLine line = null;
		int idx = -1;
		for(int i=0; i<allPossibleLines.size(); i++){
			if(allPossibleLines.get(i).getLineIntercept()>=offset){
				idx = i;
				break;
			}
		}
		if(idx>=0){
			if(allPossibleLines.get(idx).getLineIntercept()-offset<=tolerance){
				line = allPossibleLines.get(idx);
			}else if(idx>0 && allPossibleLines.get(idx-1).getLineIntercept()-offset<=tolerance){
				line = allPossibleLines.get(idx-1);
			}
		}
		
		return line;
	}
	
	private int getLineMeanGray(ImgExtractLine currLine, int[][] imgGrays, int startIdx, int stopIdx){
		if(null==currLine) return -1;
		
		double slope = currLine.getLineSlope(), sumGray = 0.0;
		double offset = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
		int nearCol = 0, imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		int meanGray = -1, counter = 0;
		if(startIdx>stopIdx){
			nearCol = startIdx;
			startIdx = stopIdx;
			stopIdx = nearCol;
		}
		if(startIdx<0) startIdx = 0;
		if(stopIdx+1>imgWidth) stopIdx=imgWidth-1;
		
		for(int i=startIdx; i<=stopIdx; i++){
			nearCol = (int)(slope * i + offset);
			if(nearCol>=0 && nearCol<imgHeight){
				sumGray += imgGrays[i][nearCol];
				counter++;
			}
		}
		if(counter>0) meanGray = (int)(sumGray/counter);
		
		return meanGray;
	}
	
	private boolean thereIsPoleBtw(int[][] imgGrays, ImgExtractLine currLine, ImgExtractLine lastLine, boolean supposed){
		boolean poleExisting = supposed;
		
		if(null!=currLine && null!=lastLine){
			poleExisting = false;
			ImgExtractLine tmpLine = null;
			double offset1 = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
			double offset2 = lastLine.getLineIntercept()+lastLine.getLineInterceptDelta();
			poleExisting = offsetInPeakRegion(allPossibleLines,(offset1+offset2)/2);
			
			//If out of expectation
			int gray0 = 0, gray1 = 0, gray2 = 0;
			if(!poleExisting && supposed){
				tmpLine = getMostClosedLine((offset1+offset2)/2,lineScanRange/2);
				if(null!=tmpLine){
					gray0 = getLineMeanGray(tmpLine,imgGrays,imgGrays.length/2,imgGrays.length);
					gray1 = getLineMeanGray(currLine,imgGrays,imgGrays.length/2,imgGrays.length);
					gray2 = getLineMeanGray(lastLine,imgGrays,imgGrays.length/2,imgGrays.length);
					if((double)(gray0-gray1+gray0-gray2)/2+0.5<3){
						poleExisting = supposed;
					}else{
						poleExisting = !supposed;
					}
				}
			}
		}
		
		return poleExisting;
	}
	
	private boolean lineIsThicker(double[] weightOfLine, int[][] imgGrays, ImgExtractLine currLine, ImgExtractLine lastLine, double offsetChgR){
		boolean thicker = false;
		//Total lines appear in Up or Dn side checking region is more than 3
		if(weightOfLine[6]>=0.6 && weightOfLine[8]>=5 
			|| weightOfLine[5]>=0.6 && weightOfLine[7]>=5
			|| weightOfLine[5]*weightOfLine[7]+weightOfLine[6]*weightOfLine[8]>=5){
			if(null==currLine){
				thicker = true;
			}else{
				double slope = currLine.getLineSlope();
				double offsetCurrLine = currLine.getLineIntercept()+currLine.getLineInterceptDelta();
				double offsetLastLine = offsetCurrLine-10;
				if(null!=lastLine) offsetLastLine = lastLine.getLineIntercept() + lastLine.getLineInterceptDelta()-3;
				int scanRange = (int)(offsetCurrLine - offsetLastLine);
				if(scanRange<0) scanRange = 10;
				int stDelta = -5;
				int[] grays = new int[scanRange+1-stDelta];
				int innerAvgGray = 0, outerAvgGray = 0, innerCnt = 0, outerCnt = 0;
				double innerGray = 0.0, outerGray = 0.0;
				
				for(int i=stDelta; i<=scanRange; i++){
					grays[i-stDelta] = currLine.getLineAvgGray(imgGrays, currLine.getXAxisStop(), slope, offsetCurrLine-i);
					if(i<scanRange/2){
						innerGray += grays[i-stDelta];
						innerCnt++;
					}else{
						outerGray += grays[i-stDelta];
						outerCnt++;
					}
				}
				outerAvgGray = (int)(outerGray/outerCnt);
				innerAvgGray = (int)(innerGray/innerCnt);
				
				if(outerAvgGray-innerAvgGray>3 
					|| outerAvgGray-innerAvgGray>=3 && weightOfLine[5]*weightOfLine[7]+weightOfLine[6]*weightOfLine[8]>=5
				){
					thicker = true;
				}
			}
		}
		
		return thicker;
	}
	
	private boolean evenLineIsLonger(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays){
		boolean evenLineLonger = false;
		int[] refGrayIndex = new int[targetLinesQty];
		double[] refGrays = new double[targetLinesQty];
		int longPoleFirstQty = 0, imgHeight = imgGrays[0].length;
		double weightOfEvenLineLonger = 0.0;
		
		for(int i=0; i<targetLinesQty; i++){
			ImgExtractLine exLine = linesMap.get(i);
			if(null!=exLine){
				if(0==i%2){
					refGrayIndex[i] = exLine.getXAxisStart();
				}else{
					refGrayIndex[i] = refGrayIndex[i-1];
				}
				
				double refGray = 0.0;
				double lineSlope = exLine.getLineSlope();
				double lineOffset = exLine.getLineIntercept();
				int nearCol = 0;
				for(int k=0; k<=refGrayIndex[i]; k++){
					nearCol = (int)(k*lineSlope+lineOffset);
					if(nearCol<0 || nearCol>(imgHeight-1)) continue;
					refGray += imgGrays[k][nearCol];
				}
				exLine.setRefGray(refGray);
				refGrays[i] = refGray;
				
				if(0!=i%2){
					if(refGrays[i]>refGrays[i-1]) longPoleFirstQty++;
				}
			}
		}
		weightOfEvenLineLonger = (double)longPoleFirstQty*2 / targetLinesQty;
		if(weightOfEvenLineLonger>0.5) evenLineLonger = true;
		
		return evenLineLonger;
	}
	
	private LinkedHashMap<Integer, ImgExtractLine> addMissingLines(LinkedHashMap<Integer, ImgExtractLine> linesMap,
			ImgExtractLine myBaseline,int[][] peakVals, int[][] initVals, int[][]imgGrays, 
			int defaultVal, double[] slope, double[] offset, int bestRsqIdx,
			double evenPoleAvgOffset, double oddPoleAvgOffset, int targetLinesQty){
		
		double addLineSlope = 0.0, addLineOffset = 0.0;
		double researchOffset = 0.0, researchOffsetStop = 0.0, researchSlope = 0.0;
		
		for(int i=1; i<targetLinesQty; i++){
			if(null==linesMap.get(i) && null!=linesMap.get(i-1)){
				ImgExtractLine exLine = null;
				addLineSlope = 0.0; addLineOffset = 0.0;
				if(null!=linesMap.get(i+1)){
					addLineSlope = (linesMap.get(i-1).getLineSlope()+linesMap.get(i+1).getLineSlope())/2;
					addLineOffset = (linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()
							+linesMap.get(i+1).getLineIntercept()+linesMap.get(i+1).getLineInterceptDelta())/2;
				}else if(i==(targetLinesQty-1)){
					researchSlope = linesMap.get(i-1).getLineSlope();
					researchOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()+(evenPoleAvgOffset+oddPoleAvgOffset)/2;
					researchOffsetStop = researchOffset + (evenPoleAvgOffset+oddPoleAvgOffset)/2*3;
					exLine = searchLine(peakVals, initVals, imgGrays, defaultVal, researchOffset, researchOffsetStop, researchSlope, (int)(researchOffsetStop-researchOffset));
					if(null!=exLine){
						exLine.setLineFlag(3);
					}else{
						addLineSlope = linesMap.get(i-1).getLineSlope();
						addLineOffset = linesMap.get(i-1).getLineIntercept()+linesMap.get(i-1).getLineInterceptDelta()
								+(evenPoleAvgOffset+oddPoleAvgOffset)/2;
					}
				}
				if(addLineOffset>0) exLine = addFixedLine(peakVals,imgGrays,defaultVal,addLineSlope,addLineOffset);
				if(null!=exLine) linesMap.put(i, exLine);
			}
		}
		
		return linesMap;
	}
	
	private ImgExtractLine addFixedLine(int[][] peakVals, int[][]imgGrays, 
			int defaultVal, double addLineSlope, double addLineOffset){
		
		ImgExtractLine exLine = null;
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int nearCol = 0, scanRng = lineScanRange/2, colOffset = 0, maxCnt = 0;
		int[] dataCounters = new int[scanRng*2+1];
		exLine = new ImgExtractLine();
		
		for(int j=(imgWidth-1); j>=0; j--){
			nearCol = (int)(j*addLineSlope+addLineOffset);
			for(int k=-scanRng; k<=scanRng; k++){
				if(nearCol+k>=0 && nearCol+k<imgHeight){
					if(peakVals[j][nearCol+k]<lineFitGrayThr){
						dataCounters[k+scanRng] = dataCounters[k+scanRng]+1;
					}
				}
			}
		}
		
		for(int k=0; k<dataCounters.length; k++){
			if(maxCnt<dataCounters[k]){
				maxCnt = dataCounters[k];
				colOffset = k;
			}
		}
		
		colOffset = colOffset - scanRng;
		for(int j=(imgWidth-1); j>=0; j--){
			nearCol = (int)(j*addLineSlope+addLineOffset);
			if(nearCol+colOffset>=0 && nearCol+colOffset<imgHeight){
				if(peakVals[j][nearCol+colOffset]<lineFitGrayThr){
					exLine.addPoint(j, nearCol, imgGrays[j][nearCol]);
				}
			}
		}
		
		exLine.getLineCoef(false);
		exLine.setLineFlag(3);
		exLine = setLineBoundary(exLine, imgGrays, defaultVal);
		
		return exLine;
	}
	
	private void initLineFitGrayThreshold(){
		lineFitGrayThr = 255 * 0.8;
	}
	
	private void adjustLineFitGrayThreshold(int[][] imgGrays, ImgExtractLine myBaseline, int scanOffset){
		double slope = myBaseline.getLineSlope();
		double offset = myBaseline.getLineIntercept();
		int nearRow = 0, imgWidth = imgGrays.length, imgHeight = imgGrays[0].length;
		double grayAvg = 0.0;
		int counter = 0;
		
		for(int col=0; col<imgWidth; col++){
			nearRow = (int)(slope*col+offset);
			if(nearRow<0 || nearRow+scanOffset>imgHeight) continue;
			for(int row=0; row<scanOffset; row++){
				if(imgGrays[col][nearRow+row]<noiseGrayThr){
					counter++;
					grayAvg += imgGrays[col][nearRow+row];
				}
			}
		}
		
		if(counter>0){
			grayAvg = grayAvg / counter * 1.05;
			System.out.println("Line fit threshold:"+lineFitGrayThr+"/"+grayAvg);
			if(grayAvg>lineFitGrayThr) lineFitGrayThr = grayAvg;
		}
	}
	
	private ArrayList<ImgExtractLine> searchLines(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, ImgExtractLine myBaseline){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int validCnt = 0, nearCol = 0, noisePoints = 0, realPoints = 0;
		int invalidCnt = 0, minValidCol = imgWidth*2, maxValidCol = -1;
		int startChkX = (int)(imgWidth*0.4), lastValidX = 0;
		int maxBlankX = (int)(imgWidth*0.05);
		double noiseRate = 0.0, slopeDelta = 0.0, validRate = 0.0;
		double lastLineOffset = 0.0, lastLineSlope = 0.0;
		double offsetDelta1 = 0.0, offsetDelta2 = 0.0, offsetDelta3 = 0.0, offsetDelta = 0.0;
		double invalidRatio = 0.0, maxColDelta = 3.0;
		int startSearchingOffset = 0, currentLineOffset = 0, finalSearchingOffset = 0;
		int lineSearchingRng = lineScanRange / 2;//Two sides searching
		
		int fittingMinPoints = (int)(imgWidth * minValidRatio);
		boolean bLineFound = false;
		
		int[][] sortData = new int[imgWidth][imgHeight];
		int[][] searchingLinesData = new int[imgWidth][imgHeight];
		finalData = new int[imgWidth][imgHeight];
		for(int i=0; i<imgWidth; i++){
			sortData[i] = initVals[i].clone();
			finalData[i] = initVals[i].clone();
			searchingLinesData[i] = peakVals[i].clone();
		}
		double myBaselineSlope = myBaseline.getLineSlope();
		double myBaselineOffset = myBaseline.getLineIntercept();
		startSearchingOffset = (int)(myBaselineSlope*(imgWidth-1)+myBaselineOffset);
		if(startSearchingOffset<0) startSearchingOffset = 0;
		lastLineOffset = -1;
		initLineFitGrayThreshold();
		adjustLineFitGrayThreshold(imgGrays,myBaseline,30);
		
		double[] lineCoef = null;
		ArrayList<ImgExtractLine> extractLines = new ArrayList<ImgExtractLine>();
		ImgExtractLine lastPossibleLine = null;
		ImgExtractLine extractLine = new ImgExtractLine();
		ImgExtractLine.setMinRSQ(0.7f);
		
		if(imgWidth > fittingMinPoints && imgHeight > lineSearchingRng){
			for(int i=startSearchingOffset; i<imgHeight; i++){
				bLineFound = false;
				minValidCol = imgWidth*2; maxValidCol = -1;
				extractLine.clearLineData();
				for(int j=(imgWidth-1); j>=0; j--){
					if(j<startChkX){
						lineSearchingRng = 1;
					}else{
						lineSearchingRng = lineScanRange / 2;
					}
					nearCol = (int)(j*myBaselineSlope+myBaselineOffset);
					if((nearCol-lineSearchingRng)>=0 && nearCol<(imgHeight-lineSearchingRng)){
						for(int k=-lineSearchingRng; k<lineSearchingRng; k++){
							if(peakVals[j][nearCol+k]<lineFitGrayThr){
								if(j>=startChkX || j<startChkX && lastValidX-j<maxBlankX){
									extractLine.addPoint(j, nearCol+k, peakVals[j][nearCol+k]);
									if((nearCol+k)<minValidCol) minValidCol = nearCol+k;
									if((nearCol+k)>maxValidCol) maxValidCol = nearCol+k;
									if(Math.abs(k)<=1) extractLine.addRealPoints(j, nearCol+k, 1);
									lastValidX = j;
								}
							}
							if(imgGrays[j][nearCol+k]>=noiseGrayThr) extractLine.addInvalidPoints(1);
						}
					}
				}
				
				validCnt = extractLine.getValidPoints();
				realPoints = extractLine.getRealPoints();
				invalidCnt = extractLine.getInvalidPoints();
				invalidRatio = (double)invalidCnt / (lineSearchingRng*2+1) / imgWidth;
				
				if(extractLines.size()<=0){
					saveSearchingLines(searchingLinesData,myBaselineSlope,myBaselineOffset,i,"debug");
					if(i-startSearchingOffset>(lineScanRange*3)){
						System.out.println("Fail to get 1st layer");
						break;
					}
				}else if(2==extractLines.size()){
//					if(249==i)
//					System.out.println("debug:"+i);
				}
				
				if((validCnt>=fittingMinPoints || realPoints>=fittingMinPoints*0.8) && invalidRatio<maxInvalidRatio){
					lineCoef = extractLine.getLineCoef(false);
					currentLineOffset = (int)(lineCoef[0]*(imgWidth-1)+lineCoef[1]);
					slopeDelta = Math.abs(myBaselineSlope-extractLine.getLineSlope());
					if(-1==lastLineOffset){
						offsetDelta1 = minOffsetDelta*1.1;
						offsetDelta2 = offsetDelta1; offsetDelta3 = offsetDelta1;
					}else{
						offsetDelta1 = lineCoef[1]-lastLineOffset;
						offsetDelta2 = (lineCoef[0]-lastLineSlope)*imgWidth/2+lineCoef[1]-lastLineOffset;
						offsetDelta3 = (lineCoef[0]-lastLineSlope)*(imgWidth-1)+lineCoef[1]-lastLineOffset;
					}
					offsetDelta = (offsetDelta1+offsetDelta2+offsetDelta3)/3;
					
					if(maxValidCol-minValidCol>maxColDelta){
						validRate = extractLine.getValidRateByYAxis((maxValidCol+minValidCol)/2-1, (maxValidCol+minValidCol)/2+1);
					}else{
						validRate = 1.0;
					}
					
					if(null!=lineCoef && (ImgExtractLine.getMinRSQ()<=lineCoef[2] 
							|| (maxValidCol-minValidCol)<=maxColDelta 
							|| validRate>minValidRate) 
							&& (extractLines.size()>0 && currentLineOffset > 0
								|| extractLines.isEmpty() && currentLineOffset>=0)
							&& slopeDelta<maxSlopeDelta 
							&& offsetDelta1>minOffsetDelta/3 
							&& offsetDelta2>minOffsetDelta/3 
							&& offsetDelta3>minOffsetDelta/3
							&& offsetDelta>minOffsetDelta){
						for(int k=0; k<imgWidth; k++){
							nearCol = (int)(k*lineCoef[0]+lineCoef[1]);
							if(nearCol>noiseScanRng && nearCol<(imgHeight-noiseScanRng)){
								noisePoints = 0;
								for(int n=-noiseScanRng; n<=noiseScanRng; n++){
									if(peakVals[k][nearCol+n]<noiseGrayThr){
										if(Math.abs(n)>1){
											noisePoints++;
										}else{
											extractLine.addOnlinePoint();
										}
									}
								}
								if(noisePoints>0) extractLine.addSideNoise(noisePoints);
							}else{
								break;
							}
						}
						
						noiseRate = maxNoiseRate + 1.0;
						if(extractLine.getOnlinePoints()>0) noiseRate = (double)extractLine.getNoisePoints() / extractLine.getOnlinePoints();
						
						if(extractLine.getOnlinePoints()>=(fittingMinPoints*0.8) 
							&& (noiseRate<maxNoiseRate 
							|| noiseRate>=maxNoiseRate 
							&& validRate>=1.0 
							&& ImgExtractLine.getMinRSQ()<=lineCoef[2])){
							
							if(extractLines.isEmpty()) extractLine.getLineCoef(true);
							lastLineSlope = extractLine.getLineSlope();
							lastLineOffset = extractLine.getLineIntercept();
							
							saveSearchingLines(searchingLinesData,myBaselineSlope,myBaselineOffset,extractLines.size(),"found");
							
							myBaselineSlope = extractLine.getLineSlope();
							myBaselineOffset = extractLine.getLineIntercept()+1;
							
							currentLineOffset = (int)(myBaselineSlope*(imgWidth-1)+myBaselineOffset);
							i = currentLineOffset+lineSearchingRng;
							bLineFound = true;
							extractLine = setLineBoundary(extractLine, imgGrays, defaultVal);
							extractLines.add(extractLine.clone());
							if(targetLinesQty==extractLines.size()) finalSearchingOffset = i;
							System.out.println("Line found:"+myBaselineSlope+"/"+myBaselineOffset);
						}
					}
				}
				if(!bLineFound) myBaselineOffset = myBaselineOffset+1;
				
				if(allPossibleLines.size()>0) lastPossibleLine = allPossibleLines.get(allPossibleLines.size()-1);
				if(!bLineFound && validCnt>5 && 0==extractLine.getLineIntercept()) extractLine.getLineCoef(false);
				if(allPossibleLines.size()>0 && validCnt==lastPossibleLine.getValidPoints()
					&& extractLine.getLineIntercept()-lastPossibleLine.getLineIntercept()<5){
					if(bLineFound || extractLine.getLineRSQ()>lastPossibleLine.getLineRSQ()){
						if(!bLineFound) bLineFound = (3==lastPossibleLine.getLineFlag()?true:false);
						allPossibleLines.remove(allPossibleLines.size()-1);
						if(allPossibleLines.size()>0){
							lastPossibleLine = allPossibleLines.get(allPossibleLines.size()-1);
						}else{
							lastPossibleLine = null;
						}
					}
				}
				if(allPossibleLines.isEmpty() || allPossibleLines.size()>0
					&& (validCnt!=lastPossibleLine.getValidPoints()
						|| extractLine.getLineIntercept()-lastPossibleLine.getLineIntercept()>=5)){
					if(bLineFound) extractLine.setLineFlag(3);
					allPossibleLines.add(extractLine.clone());
				}
				
				if(targetLinesQty==extractLines.size()){
					if(i>=finalSearchingOffset+lineScanRange*6) break;
				}
			}
		}
		
		if(extractLines.size()>0) extractLines = adjustAllSearchedLines(allPossibleLines,extractLines,imgGrays,defaultVal);
		saveImgData("graysSortLines_",sortData);
		return extractLines;
	}
	
	private double[] getPoleOffset(ArrayList<ImgExtractLine> lines, int targetLinesQty){
		double[] poleOffset = new double[]{0.0,0.0};
		double oddPoleOffset = 0.0, evenPoleOffset = 0.0, tmpOffset = 0.0;
		double oddMin = 0.0, oddMax = 0.0, evenMin = 0.0, evenMax = 0.0;
		int oddPoleCnt = 1, evenPoleCnt = 1;
		
		if(null!=lines && lines.size()>2){
			oddPoleOffset = lines.get(1).getLineIntercept() - lines.get(0).getLineIntercept();
			evenPoleOffset = lines.get(2).getLineIntercept() - lines.get(1).getLineIntercept();
			oddMin = oddPoleOffset; oddMax = oddMin;
			evenMin = evenPoleOffset; evenMax = evenMin;
			if(lines.size()>3){
				for(int i=3; i<lines.size(); i++){
					tmpOffset = lines.get(i).getLineIntercept() - lines.get(i-1).getLineIntercept();
					if(1==i%2){
						oddPoleCnt++;
						oddPoleOffset += tmpOffset;
						if(oddMin>tmpOffset) oddMin = tmpOffset;
						if(oddMax<tmpOffset) oddMax = tmpOffset;
					}else{
						evenPoleCnt++;
						evenPoleOffset += tmpOffset;
						if(evenMin>tmpOffset) evenMin = tmpOffset;
						if(evenMax<tmpOffset) evenMax = tmpOffset;
					}
				}
			}
			if(oddPoleCnt>2){
				oddPoleOffset = (oddPoleOffset-oddMin-oddMax)/(oddPoleCnt-2);
			}else{
				oddPoleOffset = oddPoleOffset/oddPoleCnt;
			}
			if(evenPoleCnt>2){
				evenPoleOffset = (evenPoleOffset-evenMin-evenMax)/(evenPoleCnt-2);
			}else{
				evenPoleOffset = evenPoleOffset/evenPoleCnt;
			}
			poleOffset[0] = evenPoleOffset;
			poleOffset[1] = oddPoleOffset;
		}
		
		return poleOffset;
	}
	
	private double[] twoLinesAvgOffset(double slope1, double offset1, double slope2, double offset2, double startX, double stopX){
		double sumOffset = 0.0, avgOffset = 0.0, stepX = (startX+stopX)/10, dblTemp = 0.0;
		double minOffset = 0.0, maxOffset = 0.0, offsetFactor = 1.0;
		int counter = 0;
		
		if(startX>stopX){
			dblTemp = startX;
			startX = stopX;
			stopX = dblTemp;
		}
		
		if(0==stepX) stepX = 1.0;
		if(offset2>offset1) offsetFactor = -1.0;
		minOffset = Math.abs(offset2-offset1); maxOffset = minOffset;
		for(double x = startX; x<=stopX; x+=stepX){
			dblTemp = (slope1*x+offset1 - (slope2*x+offset2))*offsetFactor;
			sumOffset += dblTemp;
			counter++;
			if(minOffset>dblTemp) minOffset = dblTemp;
			if(maxOffset<dblTemp) maxOffset = dblTemp;
		}
		
		avgOffset = sumOffset / counter;
		
		return new double[]{avgOffset,minOffset,maxOffset};
	}
	
	private ArrayList<ImgExtractLine> adjustAllSearchedLines(ArrayList<ImgExtractLine> allPossibleLines,ArrayList<ImgExtractLine> extractLines,int[][] imgGrays,int defaultVal){
		double ratio = 0.0, bestRsq = 0.0, offsetDelta = 0.0, off2 = 0.0, ratio2 = 0.0, ratio3 = 0.0;
		double refOffset = 0.0, lastOffset = 0.0, nextOffset = -1.0, tmpOffset = 0.0;
		int bestIdx = 0, refValidPts = 0, lastFoundIdx = -1, size = 0, nextIdx = 0;
		int scanRng = lineScanRange/2, offsetCmpFlag = 0;
		boolean swapPoleOffset = false;
		ArrayList<ImgExtractLine> adjLines1 = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjLines2 = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjustLines = new ArrayList<ImgExtractLine>();
		ArrayList<ImgExtractLine> adjLines = new ArrayList<ImgExtractLine>();
		ImgExtractLine tmpLine = null, lastLine = null;
		
		//Step_1:Adjust the first found lines
		for(int idx=0; idx<allPossibleLines.size(); idx++){
			if(3!=allPossibleLines.get(idx).getLineFlag()) continue;
			refValidPts = allPossibleLines.get(idx).getValidPoints();
			refOffset = allPossibleLines.get(idx).getLineIntercept();
			bestRsq = allPossibleLines.get(idx).getLineRSQ();
			bestIdx = idx;
			for(int i=-scanRng; i<=scanRng; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(null!=tmpLine && Math.abs(refOffset-tmpLine.getLineIntercept())<5){
					ratio = (double)tmpLine.getValidPoints()/refValidPts;
					if(ratio>0.95 && bestRsq<tmpLine.getLineRSQ()){
						bestRsq = tmpLine.getLineRSQ();
						bestIdx = idx+i;
					}
				}
			}
			tmpLine = allPossibleLines.get(bestIdx);
			offsetDelta = tmpLine.getLineIntercept();
			if(null!=lastLine){
				offsetDelta -= lastLine.getLineIntercept();
				if(offsetDelta<=5){
					adjLines1.remove(adjLines1.size()-1);
					lastLine = null;
				}
			}
			if(null==lastLine || null!=lastLine && offsetDelta>5){
				if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, defaultVal);
				adjLines1.add(tmpLine);
				lastLine = tmpLine;
			}
		}
		
		//Step_2:Get all potential lines via peak searching method
		adjLines2 = adjustAllSearchedLinesEx(allPossibleLines,imgGrays,defaultVal);
		adjLines2 = doubleCheckAllPotentialLines(adjLines2,allPossibleLines);
		double[] poleOffset = getPoleOffset(adjLines2,targetLinesQty);
		
		//Step_3:Combine all lines from Step_1 and Step_2
		lastFoundIdx = -1;
		if(adjLines2.isEmpty()){
			for(int i=0; i<adjLines1.size(); i++){
				adjustLines.add(adjLines1.get(i));
			}
		}else{
			for(int i=0; i<adjLines1.size(); i++){//First found lines are more reliable(they are the base)
				bestIdx = -1;
				tmpLine = adjLines1.get(i);
				refOffset = tmpLine.getLineIntercept();
				
				if(12==adjustLines.size()){
					System.out.print("");
				}
				
				for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
					//Double confirm in all potential lines
					if(Math.abs(refOffset-adjLines2.get(j).getLineIntercept())<3){
						bestIdx = j;
						break;
					}
					if(adjLines2.get(j).getLineIntercept()-refOffset>3) break;
				}
				
				//TODO Verification
				if(bestIdx<0 && adjustLines.isEmpty() && adjLines2.size()>0){
					//Double check the most outer line
					double[] offs = twoLinesAvgOffset(tmpLine.getLineSlope(),tmpLine.getLineIntercept(),adjLines2.get(0).getLineSlope(),adjLines2.get(0).getLineIntercept(),0.0,imgGrays.length);
					if(offs[0]<3 && offs[1]<1) continue;
				}
				
				if(bestIdx>=0){
					if(lastFoundIdx<0 && bestIdx>0){//Suppose adjLines2 is reliable
						for(int j=0; j<bestIdx; j++){
							adjustLines.add(adjLines2.get(j));
							lastFoundIdx = j;
						}
					}
					
					//Found in potential lines
					if(lastFoundIdx>=0 && bestIdx-lastFoundIdx>1){
						//Confirm the missed potential lines
						if(adjustLines.size()>0) refOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
						for(int k=(lastFoundIdx+1);k<bestIdx;k++){
							if(adjLines2.get(k).getLineIntercept()<refOffset) continue;
							lastOffset = refOffset;
							if(k>0) lastOffset = adjLines2.get(k-1).getLineIntercept();
							offsetDelta = adjLines2.get(k+1).getLineIntercept()-adjLines2.get(k).getLineIntercept();
							if((adjLines2.get(k).getLineIntercept()-lastOffset>=5 || k<2 && adjLines2.get(k).getLineIntercept()-lastOffset>=3)
								&& offsetDelta>=5){
								ratio = (double)adjLines2.get(k).getValidPoints()/imgGrays.length;
								if(ratio>=minValidRatio){
									adjustLines.add(adjLines2.get(k));
								}else{
									off2 = adjLines2.get(k).getLineIntercept()-lastOffset;
									ratio = offsetDelta/off2;
									if(ratio<minOffsetChgRate || ratio>maxOffsetChgRate
										|| offsetDelta>5 && off2>5) adjustLines.add(adjLines2.get(k));
								}
							}
						}
					}
					lastFoundIdx = bestIdx;
					tmpLine = adjLines2.get(bestIdx);
				}else if(adjustLines.size()>0 && refOffset>adjLines2.get(0).getLineIntercept()){
					//Not found in potential lines(after the 1st found line)
					if(lastFoundIdx+1<adjLines2.size()){
						offsetDelta = refOffset-adjLines2.get(lastFoundIdx+1).getLineIntercept();
						if(offsetDelta>5){//First found line is behind the potential lines
							for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
								if(refOffset-adjLines2.get(j).getLineIntercept()>5){
									adjustLines.add(adjLines2.get(j));
									lastFoundIdx = j;
								}else{
									break;
								}
							}
						}else if(offsetDelta<=5){//First found line is very closed to the potential lines
							for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
								if(refOffset>adjLines2.get(j).getLineIntercept()){//Fetch the potential lines
									adjustLines.add(adjLines2.get(j));
									lastFoundIdx = j;
								}else{
									break;
								}
							}
						}
					}
					
					//Get next potential line
					nextOffset = -1.0; nextIdx = -1;
					for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
						if(adjLines2.get(j).getLineIntercept()>refOffset){
							nextOffset = adjLines2.get(j).getLineIntercept();
							nextIdx = j;
							break;
						}
					}
					
					//Offset change rate of the first found line
					ratio = -1.0; lastOffset = 0.0; ratio2 = -1.0;
					size = adjustLines.size();
					if(size>0){
						lastOffset = adjustLines.get(size-1).getLineIntercept();
						if(size>2){//Refer to previous data
							ratio = (refOffset - lastOffset)/(adjustLines.get(size-2).getLineIntercept()-adjustLines.get(size-3).getLineIntercept());
							ratio2 = (nextOffset - lastOffset)/(adjustLines.get(size-2).getLineIntercept()-adjustLines.get(size-3).getLineIntercept());
						}else if(nextIdx>0 && nextIdx+3<adjLines2.size()){
							ratio = (refOffset - lastOffset)/(adjLines2.get(nextIdx+3).getLineIntercept()-adjLines2.get(nextIdx+2).getLineIntercept());
							ratio2 = (nextOffset - lastOffset)/(adjLines2.get(nextIdx+3).getLineIntercept()-adjLines2.get(nextIdx+2).getLineIntercept());
						}else{
							if(1==adjustLines.size()%2){//Supposed the first found line is a missing potential line
								if(poleOffset[1]>0){
									ratio = (refOffset - lastOffset)/poleOffset[1];
									ratio2 = (nextOffset - lastOffset)/poleOffset[1];
								}
							}else{
								if(poleOffset[0]>0){
									ratio = (refOffset - lastOffset)/poleOffset[0];
									ratio2 = (nextOffset - lastOffset)/poleOffset[0];
								}
							}
						}
					}
					
					swapPoleOffset = true;
					offsetCmpFlag = offsetInSamePeak(allPossibleLines,refOffset,nextOffset,lastOffset);
					
					if(-1==offsetCmpFlag){
						continue;//Skip because the first found line is not in a valid peak region
					}else if(2==offsetCmpFlag){
						continue;//Skip because the first found line is in the valid peak region of last line
					}else if(1==offsetCmpFlag){
						tmpLine = adjLines2.get(nextIdx);//Replace the first found line with next potential line
						lastFoundIdx = nextIdx;
						swapPoleOffset = false;
					}else if(0==offsetCmpFlag){
						if(!(adjustLines.size()>2 && ratio>minOffsetChgRate)){
							ratio3 = (double)tmpLine.getValidPoints()/imgGrays.length;
							if(ratio3<minValidRatio) continue;
						}
						if(ratio<maxOffsetChgRate*0.6 && ratio2>0 && ratio2<maxOffsetChgRate) continue;
					}
					
					if(swapPoleOffset){
						tmpOffset = poleOffset[0];
						poleOffset[0] = poleOffset[1];
						poleOffset[1] = tmpOffset;
					}
				}
				if(adjustLines.isEmpty()) tmpLine.setLineChecked(true);//Fixed the 1st found layer
				adjustLines.add(tmpLine);
			}
		}
		
		//Step_4:Check whether all layers are found
		if(adjustLines.size()<targetLinesQty){
			refOffset = 0.0;
			if(adjustLines.size()>0) refOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
			for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
				if(adjLines2.get(j).getLineIntercept()>refOffset && adjustLines.size()<targetLinesQty){
					adjustLines.add(adjLines2.get(j));
				}
			}
		}
		
		LinkedHashMap<Double,Double> tendency = new LinkedHashMap<Double,Double>();
		double[] coef = null;
		for(int i=0; i<adjustLines.size(); i++){
			tmpLine = adjustLines.get(i);
			tmpLine.setLineIndex(i);
			tendency.put((double)i, tmpLine.getLineIntercept());
			if(tendency.size()<3){
				tmpLine.setTendencyRSQ(1.0);
			}else{
				coef = MathUtils.lineFitting(tendency);
				tmpLine.setTendencyRSQ(coef[2]);
			}
			if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, 255);
			
			//TODO Verification
			if(i<(targetLinesQty-3)) tmpLine.setLineChecked(true);
			
			adjLines.add(tmpLine);
			allPotentialLines.add(tmpLine);
		}
		
		//Add all potential lines
		if(adjLines2.size()>lastFoundIdx+1){
			refOffset = allPotentialLines.get(allPotentialLines.size()-1).getLineIntercept();
			for(int j=lastFoundIdx+1; j<adjLines2.size(); j++){
				if(adjLines2.get(j).getLineIntercept()>refOffset){
					allPotentialLines.add(adjLines2.get(j));
				}
			}
		}
		
		if(logEnabled){
			for(int i=0; i<adjustLines.size(); i++){
				tmpLine = adjustLines.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,0==i?true:false));
			}
			for(int i=0; i<adjLines2.size(); i++){
				tmpLine = adjLines2.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,false));
			}
			for(int i=0; i<extractLines.size(); i++){
				tmpLine = extractLines.get(i);
				LogUtils.rawLog("adjustLineParas_", tmpLine.printLineParas(i,false));
			}
			for(int i=0; i<allPossibleLines.size(); i++){
				tmpLine = allPossibleLines.get(i);
				LogUtils.rawLog("searchLineParas_", tmpLine.printLineParas(tmpLine.getLineFlag(),0==i?true:false));
			}
			logSelectedLinesGray(adjustLines,imgGrays,5);
		}
		
		return adjLines;
	}
	
	private void logSelectedLinesGray(ArrayList<ImgExtractLine> selectedLines, int[][] imgGrays, int grayScanRng){
		ImgExtractLine tmpLine = null;
		int imgWidth = imgGrays.length, imgHeight = imgGrays[0].length, col = 0;
		double lineSlope = 0.0, lineOffset = 0.0;
		String title = "LineIdx,Offset,Col,Edge1,Edge2,X", data = "";
		
		if(null!=selectedLines && selectedLines.size()>0){
			for(int i=0; i<imgWidth; i++){
				title += "," + i;
			}
			LogUtils.rawLog("selectedLinesXY_",title);
			for(int i=0; i<selectedLines.size(); i++){
				tmpLine = selectedLines.get(i);
				lineSlope = tmpLine.getLineSlope(); lineOffset = tmpLine.getLineIntercept();
				for(int j=-grayScanRng; j<=grayScanRng; j++){
					data = i + "," + lineOffset + "," + j + "," + tmpLine.getXAxisStop() + "," + tmpLine.getXAxisStart() + ",Y";
					for(int k=0; k<imgWidth; k++){
						col = (int)(lineSlope * k + lineOffset + j);
						if(col>=0 && col<imgHeight){
							data += "," + imgGrays[k][col];
						}else{
							data += ",255";
						}
					}
					LogUtils.rawLog("selectedLinesXY_",data);
				}
			}
		}
	}
	
	private boolean offsetInPeakRegion(ArrayList<ImgExtractLine> allPossibleLines, double chkOffset){
		boolean inPeakRegion = false;
		double minDelta = 0.0, offsetDelta = 0.0, ratio = 0.0;
		int mostCloseIdx = -1, scanRng = lineScanRange/2, counter = 0, minValidPts = 0;
		int size = allPossibleLines.size(), peakIdx = -1, maxValidPts = 0;
		
		if(size>0){
			//Get the index of chkOffset in allPossibleLines
			minDelta = Math.abs(allPossibleLines.get(0).getLineIntercept()-chkOffset);
			mostCloseIdx = 0;
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-chkOffset);
				if(minDelta>offsetDelta){
					minDelta = offsetDelta;
					mostCloseIdx = i;
				}
			}
			
			//Fine-tune the index of chkOffset
			peakIdx = -1; maxValidPts = 0;
			for(int i=-scanRng; i<=scanRng; i++){
				if(mostCloseIdx+i>=0 && mostCloseIdx+i<size){
					offsetDelta = Math.abs(allPossibleLines.get(mostCloseIdx+i).getLineIntercept()-chkOffset);
					if(offsetDelta<3){
						if(maxValidPts<allPossibleLines.get(mostCloseIdx+i).getValidPoints()){
							maxValidPts = allPossibleLines.get(mostCloseIdx+i).getValidPoints();
							peakIdx = mostCloseIdx+i;
						}
					}
				}
			}
			
			if(peakIdx>=0){
				//Possibility of being in the peak region
				counter = 0;
				for(int i=scanRng; i>0; i--){
					if(peakIdx-i>=0 && peakIdx+i<size){
						if(allPossibleLines.get(peakIdx).getValidPoints()>=allPossibleLines.get(peakIdx-i).getValidPoints()
							&& allPossibleLines.get(peakIdx).getValidPoints()>=allPossibleLines.get(peakIdx+i).getValidPoints()){
							counter++;
						}
					}
				}
				ratio = (double)counter/scanRng;
				if(ratio>0.66){
					//Check whether current peakIdx represents a valid peak or not
					maxValidPts = allPossibleLines.get(peakIdx).getValidPoints();
					minValidPts = maxValidPts;
					ratio = 0.0;
					//Get the base&max value in last 10 points
					for(int i=peakIdx; i>(peakIdx-10); i--){
						if(i<0) break;
						if(maxValidPts<allPossibleLines.get(i).getValidPoints()) maxValidPts = allPossibleLines.get(i).getValidPoints();
						if(minValidPts>allPossibleLines.get(i).getValidPoints()) minValidPts = allPossibleLines.get(i).getValidPoints();
					}
					if(maxValidPts>minValidPts) ratio = (double)(allPossibleLines.get(peakIdx).getValidPoints()-minValidPts)/(maxValidPts-minValidPts);
					if(ratio>0.2) inPeakRegion = true;
				}
			}
		}
		return inPeakRegion;
	}
	
	private int offsetInSamePeak(ArrayList<ImgExtractLine> allPossibleLines, double chkOffset, double nextOffset, double lastOffset){
		int rsltFlag = -1;
		double minDelta0 = 0.0, offsetDelta = 0.0, minDelta1 = 0.0, minDelta2 = 0.0;
		int chkIdx = -1, nextIdx = -1, lastIdx = -1;
		int size = allPossibleLines.size();
		int[] validPts = null, idx1 = null, idx2 = null;
		
		if(size>0 && chkOffset>0 && (nextOffset>0 || lastOffset>0)){
			minDelta0 = Math.abs(allPossibleLines.get(0).getLineIntercept()-chkOffset);
			minDelta1 = Math.abs(allPossibleLines.get(0).getLineIntercept()-nextOffset);
			minDelta2 = Math.abs(allPossibleLines.get(0).getLineIntercept()-lastOffset);
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-chkOffset);
				if(minDelta0>offsetDelta){
					minDelta0 = offsetDelta;
					chkIdx = i;
				}
				
				if(nextOffset>0){
					offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-nextOffset);
					if(minDelta1>offsetDelta){
						minDelta1 = offsetDelta;
						nextIdx = i;
					}
				}
				
				if(lastOffset>0){
					offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-lastOffset);
					if(minDelta2>offsetDelta){
						minDelta2 = offsetDelta;
						lastIdx = i;
					}
				}
			}
			
			validPts = getPossibleLinesValidDtPts(allPossibleLines);
			idx1 = MathUtils.getPeakCenterIndex(validPts, chkIdx, lineScanRange, true);
			if(idx1[0]>=0){
				rsltFlag = 0;
				if(nextIdx>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, nextIdx, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 1;
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(allPossibleLines.get(idx2[0]).getLineIntercept()-allPossibleLines.get(idx1[0]).getLineIntercept()<=lineScanRange/2) rsltFlag = 1;
						}
					}
				}
				if(0==rsltFlag && lastIdx>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, lastIdx, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 2;
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(allPossibleLines.get(idx1[0]).getLineIntercept()-allPossibleLines.get(idx2[0]).getLineIntercept()<=lineScanRange/2) rsltFlag = 2;
						}
					}
				}
			}
		}
		return rsltFlag;
	}
	
	private int offsetInSamePeakEx(ArrayList<ImgExtractLine> allPossibleLines, double offset1, double offset2){
		int rsltFlag = -1;//Not found in all possible lines
		double minDelta0 = 0.0, offsetDelta = 0.0, minDelta1 = 0.0;
		int index1 = -1, index2 = -1;
		int size = allPossibleLines.size();
		int[] validPts = null, idx1 = null, idx2 = null;
		
		if(size>0 && offset1>0 && offset2>0){
			minDelta0 = Math.abs(allPossibleLines.get(0).getLineIntercept()-offset1);
			minDelta1 = Math.abs(allPossibleLines.get(0).getLineIntercept()-offset2);
			for(int i=1; i<allPossibleLines.size(); i++){
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-offset1);
				if(minDelta0>offsetDelta){
					minDelta0 = offsetDelta;
					index1 = i;
				}
				
				offsetDelta = Math.abs(allPossibleLines.get(i).getLineIntercept()-offset2);
				if(minDelta1>offsetDelta){
					minDelta1 = offsetDelta;
					index2 = i;
				}
			}
			
			validPts = getPossibleLinesValidDtPts(allPossibleLines);
			idx1 = MathUtils.getPeakCenterIndex(validPts, index1, lineScanRange, true);
			if(idx1[0]>=0){
				rsltFlag = 0;//offset1 is found
				if(index2>0){
					idx2 = MathUtils.getPeakCenterIndex(validPts, index2, lineScanRange, true);
					if(idx2[0]>=0){
						if(Math.abs(idx2[0]-idx1[0])<=lineScanRange/2){
							rsltFlag = 1;//offset1 and offset2 is in same peak
						}else if(idx2[0]<allPossibleLines.size() && idx1[0]<allPossibleLines.size()){
							if(Math.abs(allPossibleLines.get(idx2[0]).getLineIntercept()-allPossibleLines.get(idx1[0]).getLineIntercept())<=lineScanRange/2) rsltFlag = 1;
						}
						
						if(0==rsltFlag && Math.abs(idx2[1]-idx1[1])<=2){
							rsltFlag = 2;//Left edge of offset1 and offset2 is the same
						}
					}
				}
			}
		}
		return rsltFlag;
	}
	
	private int[] getPossibleLinesValidDtPts(ArrayList<ImgExtractLine> allPossibleLines){
		int[] lineValidDataPts = new int[allPossibleLines.size()];
		for(int i=0; i<allPossibleLines.size(); i++){
			lineValidDataPts[i] = allPossibleLines.get(i).getValidPoints();
		}
		return lineValidDataPts;
	}
	
	private ArrayList<ImgExtractLine> roughCheckAllPotentialLines(ArrayList<ImgExtractLine> potentialLines){
		ArrayList<ImgExtractLine> newPotentialLines = new ArrayList<ImgExtractLine>();
		double currOffset = 0.0, nextOffset = 0.0;
		
		if(null!=potentialLines && potentialLines.size()>0){
			if(potentialLines.size()>1){
				for(int i=0; i<potentialLines.size()-1; i++){
					currOffset = potentialLines.get(i).getLineIntercept();
					nextOffset = potentialLines.get(i+1).getLineIntercept();
					if(currOffset>0 && currOffset<nextOffset){
						newPotentialLines.add(potentialLines.get(i));
					}
				}
				if(currOffset>0 && currOffset<nextOffset){
					newPotentialLines.add(potentialLines.get(potentialLines.size()-1));
				}
			}else{
				newPotentialLines = potentialLines;
			}
		}
		
		return newPotentialLines;
	}
	
	private ArrayList<ImgExtractLine> doubleCheckAllPotentialLines(ArrayList<ImgExtractLine> potentialLines, ArrayList<ImgExtractLine> allPossibleLines){
		ArrayList<ImgExtractLine> newPotentialLines = new ArrayList<ImgExtractLine>();
		
		potentialLines = roughCheckAllPotentialLines(potentialLines);
		if(null!=potentialLines && potentialLines.size()>0){
			int size = potentialLines.size(), newSize = 0;
			int currLineIdx = 0, lastLineIdx = 0;
			int peakFlags = -1;
			double ratio = 0.0;
			ImgExtractLine exLine = null;
			if(size<=1){
				newPotentialLines = potentialLines;
			}else{
				newPotentialLines.add(potentialLines.get(0));
				for(int i=1; i<size; i++){
					newSize = newPotentialLines.size();
					if(13==newSize){
						System.out.print("");
					}
					lastLineIdx = getLineIndex(allPossibleLines,newPotentialLines.get(newSize-1).getLineIntercept());
					currLineIdx = getLineIndex(allPossibleLines,potentialLines.get(i).getLineIntercept());
					if(lastLineIdx>0 && currLineIdx>lastLineIdx){
						if(newSize>2){//Check offset change rate of current line - see whether need to skip current line
							ratio = potentialLines.get(i).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
							ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
							if(ratio<maxOffsetChgRate*0.6){//Current line is very closed to last line
								ratio = (double)potentialLines.get(i).getValidPoints()/newPotentialLines.get(newSize-1).getValidPoints();
								if(ratio<0.2) continue;//Valid data points of current line is out of expectation
								
								peakFlags = offsetInSamePeakEx(allPossibleLines,newPotentialLines.get(newSize-1).getLineIntercept(),potentialLines.get(i).getLineIntercept());
								if(peakFlags>=1) continue;//Current line and last line is in the same peak
								
								if(i+1<size && newSize>2){//Double check next line
									ratio = potentialLines.get(i+1).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
									ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
									if(ratio<maxOffsetChgRate){
										if(ratio<maxOffsetChgRate*0.6){
											continue;//Next line is very close to last line, so skip current line
										}else if(newSize>4){
											ratio = potentialLines.get(i+1).getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
											ratio = ratio/(newPotentialLines.get(newSize-4).getLineIntercept()-newPotentialLines.get(newSize-5).getLineIntercept());
											if(ratio<maxOffsetChgRate) continue;//Offset change rate btw next and last line lower than upper control limit is true
										}
									}
								}
							}
						}
						
						//Check whether there is line btw current and last line
						exLine = getPotentialLineBtw(allPossibleLines,lastLineIdx,currLineIdx,newPotentialLines.get(newSize-1).getValidPoints());
						
						if(null!=exLine){
							ratio = 1.0;
							if(newSize>2){
								ratio = exLine.getLineIntercept()-newPotentialLines.get(newSize-1).getLineIntercept();
								ratio = ratio/(newPotentialLines.get(newSize-2).getLineIntercept()-newPotentialLines.get(newSize-3).getLineIntercept());
							}
							if(ratio>minOffsetChgRate) newPotentialLines.add(exLine);
						}
					}
					newPotentialLines.add(potentialLines.get(i));
				}
			}
		}
		
		return newPotentialLines;
	}
	
	private ImgExtractLine getPotentialLineBtw(ArrayList<ImgExtractLine> allPossibleLines,int startIdx,int stopIdx,int refValidDataPts){
		ImgExtractLine exLine = null;
		int validPts = 0, maxValidPts = -1, maxIdx = -1, peakFlag = 0;
		double ratio = 0.0, startOffset = 0.0, stopOffset = 0.0, foundOffset = 0.0;
		boolean startCheck = false, lineFound = false;
		if(null!=allPossibleLines && startIdx>0 && stopIdx>startIdx && stopIdx<allPossibleLines.size() && refValidDataPts>0){
			startOffset = allPossibleLines.get(startIdx).getLineIntercept();
			stopOffset = allPossibleLines.get(stopIdx).getLineIntercept();
			
			for(int i=startIdx; i<=stopIdx; i++){
				validPts = allPossibleLines.get(i).getValidPoints();
				ratio = (double)validPts/refValidDataPts;
				if(ratio<0.15){
					if(!startCheck){
						startCheck = true;
						maxValidPts = validPts;
						maxIdx = i;
					}else{
						ratio = (double)maxValidPts/refValidDataPts;
						if(ratio>0.2){
							lineFound = true;
							break;
						}
					}
				}
				if(startCheck){
					if(maxValidPts<validPts){
						maxValidPts = validPts;
						maxIdx = i;
					}
				}
			}
			
			if(lineFound){
				foundOffset = allPossibleLines.get(maxIdx).getLineIntercept();
				peakFlag = offsetInSamePeakEx(allPossibleLines,startOffset,foundOffset);
				if(0==peakFlag) peakFlag = offsetInSamePeakEx(allPossibleLines,foundOffset,stopOffset);
				if(0==peakFlag) exLine = allPossibleLines.get(maxIdx);
			}
		}
		
		return exLine;
	}
	
	private int getLineIndex(ArrayList<ImgExtractLine> allPossibleLines, double lineOffset){
		int idx = -1;
		double offsetDelta = 0.0, minDelta = 10000.0;
		if(null!=allPossibleLines && allPossibleLines.size()>0){
			for(int i=0; i<allPossibleLines.size(); i++){
				offsetDelta = allPossibleLines.get(i).getLineIntercept() - lineOffset;
				if(offsetDelta<-5) continue;
				if(offsetDelta>5) break;
				
				offsetDelta = Math.abs(offsetDelta);
				if(minDelta>offsetDelta){
					minDelta = offsetDelta;
					idx = i;
				}
			}
		}
		return idx;
	}
	
	private int getMaxValidDataPtsLineIndex(ArrayList<ImgExtractLine> allPossibleLines, double startOffset, double stopOffset){
		int idx = -1, maxPts = 0;
		double lineOffset = 0.0;
		if(null!=allPossibleLines && allPossibleLines.size()>0){
			for(int i=0; i<allPossibleLines.size(); i++){
				lineOffset = allPossibleLines.get(i).getLineIntercept();
				if(lineOffset>stopOffset) break;
				if(lineOffset<startOffset) continue;
				if(maxPts<allPossibleLines.get(i).getValidPoints()){
					maxPts = allPossibleLines.get(i).getValidPoints();
					idx = i;
				}
			}
		}
		
		return idx;
	}
	
	private ArrayList<ImgExtractLine> adjustAllSearchedLinesEx(ArrayList<ImgExtractLine> allPossibleLines,int[][] imgGrays,int defaultVal){
		double ratio = 0.0, bestRsq = 0.0, refOffset = 0.0, lastOffset = 0.0, baseLine = 0.0, baseThr = 0.0;
		int bestIdx = 0, scanRng = lineScanRange/2, scanStart = -scanRng, scanStop = scanRng, maxVPts = 0, tmpVPts = 0;
		int lastBestIdx = 0, minValidPts = 0, basePts = 0, peakFlag = 0;
		ArrayList<ImgExtractLine> adjustLines = new ArrayList<ImgExtractLine>();
		ArrayList<Integer> maxValidPts = new ArrayList<Integer>();
		ArrayList<Integer> possLinesIdx = new ArrayList<Integer>();
		ImgExtractLine tmpLine = null;
		int[] lineValidDataPts = getPossibleLinesValidDtPts(allPossibleLines);
		
		LinkedHashMap<Integer,Integer> peaks = MathUtils.getPeakValsEx(lineValidDataPts, lineScanRange, true);
		
		for(int idx:peaks.keySet()){
			refOffset = allPossibleLines.get(idx).getLineIntercept();
			bestRsq = allPossibleLines.get(idx).getLineRSQ();
			maxVPts = allPossibleLines.get(idx).getValidPoints();
			bestIdx = idx;
			
			//Get peak index fine tune range
			for(int i=-scanRng; i>=0; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(0==tmpLine.getLineRSQ()) scanStart = i;
			}
			for(int i=0; i<=scanRng; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(0==tmpLine.getLineRSQ()) scanStop = i;
			}
			
			//Fine tune the peak index
			for(int i=scanStart; i<=scanStop; i++){
				if(idx+i<0 || idx+i>=allPossibleLines.size()) continue;
				tmpLine = allPossibleLines.get(idx+i);
				if(null!=tmpLine && Math.abs(refOffset-tmpLine.getLineIntercept())<5){
					tmpVPts = tmpLine.getValidPoints();
					ratio = (double)tmpVPts/peaks.get(idx);
					if(ratio>0.95 && bestRsq<tmpLine.getLineRSQ()){
						bestRsq = tmpLine.getLineRSQ();
						bestIdx = idx+i;
					}
					if(maxVPts<tmpVPts) maxVPts = tmpVPts;
				}
			}
			tmpLine = allPossibleLines.get(bestIdx);
			
			if(11==adjustLines.size()){
				System.out.print("");
			}
			
			ratio = 1.0;
			if(adjustLines.size()>1){
				lastOffset = adjustLines.get(adjustLines.size()-1).getLineIntercept();
				tmpVPts = maxValidPts.get(maxValidPts.size()-1);
				if(tmpVPts>0){
					lastBestIdx = possLinesIdx.get(possLinesIdx.size()-1);
					minValidPts = tmpLine.getValidPoints();
					for(int k=lastBestIdx; k<=bestIdx; k++){
						if(minValidPts>allPossibleLines.get(k).getValidPoints()) minValidPts=allPossibleLines.get(k).getValidPoints();
					}
					if(tmpVPts!=minValidPts){
						baseThr = (tmpVPts-minValidPts)*0.2+minValidPts;
						baseLine = 0.0; basePts = 0;
						for(int k=lastBestIdx; k<=bestIdx; k++){
							if(allPossibleLines.get(k).getValidPoints()<baseThr){
								baseLine += allPossibleLines.get(k).getValidPoints();
								basePts++;
							}
						}
						if(basePts>0){
							baseLine = baseLine / basePts;
							ratio = (double)(tmpLine.getValidPoints()-baseLine)/(tmpVPts-baseLine);
						}else{
							ratio = (double)(tmpLine.getValidPoints()-minValidPts)/(tmpVPts-minValidPts);
						}
					}
				}
			}
			
			if(0==lastOffset || lastOffset>0 && tmpLine.getLineIntercept()-lastOffset>=5){
				if(lastOffset>0 && ratio<=0.2){
					peakFlag = offsetInSamePeakEx(allPossibleLines,lastOffset,refOffset);
					if(peakFlag>=1){
						continue;
					}else if(adjustLines.size()>3){
						ratio = (refOffset-lastOffset)/(adjustLines.get(adjustLines.size()-2).getLineIntercept()-adjustLines.get(adjustLines.size()-3).getLineIntercept());
						if(ratio<minOffsetChgRate) continue;
					}
				}
				if(0==tmpLine.getXAxisStart()) tmpLine = setLineBoundary(tmpLine, imgGrays, defaultVal);
				adjustLines.add(tmpLine);
				maxValidPts.add(maxVPts);
				possLinesIdx.add(bestIdx);
			}
		}
		
		return adjustLines;
	}
	
	private ImgExtractLine searchLine(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal, double startSearchOffset, double stopSearchOffset, double mySearchSlope, int maxSearchRange){
		ImgExtractLine finalLine = null;
//		finalLine = getLineBtw(startSearchOffset,stopSearchOffset);
//		if(null!=finalLine){
//			if(0==finalLine.getXAxisStart()) finalLine = setLineBoundary(finalLine, imgGrays, defaultVal);
//			return finalLine;
//		}
		
		boolean bLineFound = false;
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int validCnt = 0, nearCol = 0, noisePoints = 0, realPoints = 0;
		int invalidCnt = 0, minValidCol = imgWidth*2, maxValidCol = -1;
		double noiseRate = 0.0, slopeDelta = 0.0, validRate = 0.0;
		double offsetDelta1 = 0.0, offsetDelta2 = 0.0, offsetDelta3 = 0.0, offsetDelta = 0.0;
		double invalidRatio = 0.0, maxColDelta = 3.0;
		int searchMinCol = 0, searchMaxCol = 0;
		int lineSearchingRng = lineScanRange / 2;//Two sides searching
		if(maxSearchRange<lineScanRange) lineSearchingRng = maxSearchRange/2;
		if(lineSearchingRng<=0) return null;
		
		int[][] searchingLinesData = new int[imgWidth][imgHeight];
		for(int i=0; i<imgWidth; i++){
			searchingLinesData[i] = peakVals[i].clone();
		}
		
		int fittingMinPoints = (int)(imgWidth * minValidRatio * 0.8);
		double[] lineCoef = null;
		finalLine = new ImgExtractLine();
		
		LinkedHashMap<Integer,ImgExtractLine> possibleLines = new LinkedHashMap<Integer,ImgExtractLine>();
		int possibleLineIdx = -1, bestValidRateIdx = -1;
		double bestValidRate = 0.0;
		
		if(stopSearchOffset>imgHeight) stopSearchOffset=imgHeight;
		if(imgWidth > fittingMinPoints && imgHeight > lineSearchingRng){
			for(int i=lineSearchingRng; i<=(maxSearchRange-lineSearchingRng); i++){
				minValidCol = imgWidth*2; maxValidCol = -1;
				ImgExtractLine extractLine = new ImgExtractLine();
				ImgExtractLine.setMinRSQ(0.7f);
				
				for(int j=(imgWidth-1); j>=0; j--){
					nearCol = (int)(j*mySearchSlope+startSearchOffset)+i;
					searchMinCol = (int)(j*mySearchSlope+startSearchOffset);
					searchMaxCol = (int)(j*mySearchSlope+stopSearchOffset);
					if(searchMinCol<0 || searchMinCol>(imgHeight-1)) continue;
					if(searchMaxCol<0 || searchMaxCol>(imgHeight-1)) continue;
					
					if((nearCol-lineSearchingRng)>=0 && nearCol<=(searchMaxCol-lineSearchingRng)){
						for(int k=-lineSearchingRng; k<=lineSearchingRng; k++){
							if(peakVals[j][nearCol+k]<lineFitGrayThr){
								extractLine.addPoint(j, nearCol+k, peakVals[j][nearCol+k]);
								if((nearCol+k)<minValidCol) minValidCol = nearCol+k;
								if((nearCol+k)>maxValidCol) maxValidCol = nearCol+k;
								if(Math.abs(k)<=1) extractLine.addRealPoints(j, nearCol+k, 1);
							}
							if(imgGrays[j][nearCol+k]>=noiseGrayThr) extractLine.addInvalidPoints(1);
						}
					}
				}
				
				if(i>=lineSearchingRng){
//					saveSearchingLines(searchingLinesData,mySearchSlope,startSearchOffset,i+500);
				}
				
				validCnt = extractLine.getValidPoints();
				realPoints = extractLine.getRealPoints();
				invalidCnt = extractLine.getInvalidPoints();
				invalidRatio = (double)invalidCnt / (lineSearchingRng*2+1) / imgWidth;
				if((validCnt>=fittingMinPoints 
						|| maxSearchRange<=3 
						|| realPoints>=fittingMinPoints*0.8) 
						&& invalidRatio<maxInvalidRatio){
					lineCoef = extractLine.getLineCoef(false);
					slopeDelta = Math.abs(mySearchSlope-extractLine.getLineSlope());
					offsetDelta1 = lineCoef[1] - startSearchOffset;
					offsetDelta2 = (lineCoef[0]-mySearchSlope)*imgWidth/2+lineCoef[1]-startSearchOffset;
					offsetDelta3 = (lineCoef[0]-mySearchSlope)*(imgWidth-1)+lineCoef[1]-startSearchOffset;
					offsetDelta = (offsetDelta1+offsetDelta2+offsetDelta3)/3;
					
					if(maxValidCol-minValidCol>maxColDelta){
						validRate = extractLine.getValidRateByYAxis((maxValidCol+minValidCol)/2-1, (maxValidCol+minValidCol)/2+1);
					}else{
						validRate = 1.0;
					}
					
					if(slopeDelta<maxSlopeDelta 
							&& offsetDelta1>0 && offsetDelta2>0 && offsetDelta3>0 
							&& offsetDelta>minOffsetDelta*0.5){
						possibleLineIdx++;
						possibleLines.put(possibleLineIdx, extractLine);
						if(bestValidRate<validRate){
							bestValidRate = validRate;
							bestValidRateIdx = possibleLineIdx;
						}
					}
					
					if(null!=lineCoef && (ImgExtractLine.getMinRSQ()<=lineCoef[2] 
							|| (maxValidCol-minValidCol)<=maxColDelta 
							|| validRate>minValidRate) 
							&& slopeDelta<maxSlopeDelta 
							&& offsetDelta1>0 && offsetDelta2>0 && offsetDelta3>0
							&& offsetDelta>minOffsetDelta*0.5){
						for(int k=0; k<imgWidth; k++){
							nearCol = (int)(k*lineCoef[0]+lineCoef[1]);
							if(nearCol>noiseScanRng && nearCol<(imgHeight-noiseScanRng)){
								noisePoints = 0;
								for(int n=-noiseScanRng; n<=noiseScanRng; n++){
									if(peakVals[k][nearCol+n]<noiseGrayThr){
										if(Math.abs(n)>1){
											noisePoints++;
										}else{
											extractLine.addOnlinePoint();
										}
									}
								}
								if(noisePoints>0) extractLine.addSideNoise(noisePoints);
							}else{
								break;
							}
						}
						
						noiseRate = (double)extractLine.getNoisePoints() / extractLine.getOnlinePoints();
						if(extractLine.getOnlinePoints()>=(fittingMinPoints*0.8) 
							&& noiseRate<maxNoiseRate){
							
							extractLine = setLineBoundary(extractLine, imgGrays, defaultVal);
							finalLine = extractLine;
							bLineFound = true;
							break;
						}
					}
				}
			}
		}
		
		if(!bLineFound){
			if(possibleLines.size()>0 && bestValidRateIdx>=0){
				finalLine = possibleLines.get(bestValidRateIdx);
				finalLine = setLineBoundary(finalLine, imgGrays, defaultVal);
			}else{
				finalLine = null;
			}
		}
		
		if(null!=finalLine){
			if(logEnabled){
				LogUtils.rawLog("researchLineParas_", finalLine.printLineParas(0,true));
			}
		}
		
		return finalLine;
	}
	
	private LinkedHashMap<Integer,Double> getSharpChgPosition(double[] chgs){
		LinkedHashMap<Integer, Double> sharpChgPos = new LinkedHashMap<Integer, Double>();
		
		int col = chgs.length;
		int scanPoints = 4;//Two sides scanning
		int meatCndCnt = 0;
		if(col>8){
			for(int j=scanPoints; j<(col-scanPoints); j++){
				meatCndCnt = 0;
				for(int k=scanPoints; k>0; k--){
					if(0!=chgs[j] && chgs[j]<=chgs[j-k] && chgs[j]<=chgs[j+k]){
						meatCndCnt++;
					}
				}
				if(meatCndCnt==scanPoints){
					sharpChgPos.put(j, chgs[j]);
					j += scanPoints;
				}
			}
		}
		
		return sharpChgPos;
	}
	
	private void setLinesSharpChgPosition(LinkedHashMap<Integer, ImgExtractLine> linesMap, int[][] imgGrays, int[][] peakVals, boolean evenLineLonger, int targetLinesQty){
		ImgExtractLine extLine = null;
		double lineSlope, lineOffset, stdevRatio = 0.0;
		double[] Xs = new double[10], Ys = new double[10], chgs = null, tmp = null;
		int firstChgPos = 0, nearCol = 0, imgHeight = imgGrays[0].length, size = 0;
		int start = -1, stop = -1, chgStopPos = 0;
		int[] grays = null;
		String str1 = "", str2 = "";
		String[] sGrays = new String[11];
		
		for(int lineIdx:linesMap.keySet()){
			extLine = linesMap.get(lineIdx);
			if(null!=extLine){
				lineSlope = extLine.getLineSlope();
				lineOffset = extLine.getLineIntercept()+extLine.getLineInterceptDelta();
				firstChgPos = extLine.getXAxisStart()+10;
				chgStopPos = extLine.getXAxisStop();
				chgs = new double[firstChgPos];
				grays = new int[firstChgPos];
				str1 = ""; str2 = "";
				for(int k=0; k<11; k++){
					sGrays[k] = "";
				}
				
				for(int i=firstChgPos; i>0;i--){
					size = 0;
					for(int k=0; k<10; k++){
						nearCol = (int)(k*lineSlope+lineOffset);
						if(nearCol>=0 && nearCol<imgHeight){
							try {
								Xs[k] = i + k;
								Ys[k] = imgGrays[(int)Xs[k]][nearCol];
								size++;
							} catch (Exception e) {
								System.out.println(Xs[k]+":"+i+"/"+k);
							}
						}
					}
					tmp = MathUtils.lineFitting(Xs, Ys, size);
					chgs[i-1] = tmp[0];
					nearCol = (int)(i*lineSlope+lineOffset);
					if(nearCol>=0 && nearCol<imgHeight){
						if(i<imgGrays.length) grays[i-1] = imgGrays[i][nearCol];
					}
					for(int k=-5; k<=5; k++){
						if((nearCol+k)>=0 && (nearCol+k)<imgHeight && i<imgGrays.length){
							sGrays[k+5] += "," + imgGrays[i][nearCol+k];
						}else{
							sGrays[k+5] += ",0";
						}
					}
					
					str1 += "," + i;
					str2 += "," + chgs[i-1];
				}
				
				LinkedHashMap<Integer,Double> sharpChgPos = getSharpChgPosition(chgs);
				LinkedHashMap<Integer,LinkedHashMap<SharpChgItems,Double>> sharpChgPosParas = new LinkedHashMap<Integer,LinkedHashMap<SharpChgItems,Double>>();
				size = -1;
				for(int key:sharpChgPos.keySet()){
					size++;
					if(start<0){
						start = key;
						continue;
					}else{
						stop = key;
					}
					LinkedHashMap<SharpChgItems,Double> statisticParas = new LinkedHashMap<SharpChgItems,Double>();
					tmp = extLine.getLineStatisticParas(linesMap, start, (start+stop)/2, imgGrays, lineIdx, evenLineLonger);
					stdevRatio = tmp[3];
					if(1==size){
						LinkedHashMap<SharpChgItems,Double> sttParas = new LinkedHashMap<SharpChgItems,Double>();
						double[] weightOfBeingLine = extLine.weightOfBeingLine(linesMap,firstChgPos-10, chgStopPos, 0, imgGrays, peakVals, 5, lineIdx, targetLinesQty, true, curLineIsLonger(lineIdx,evenLineLonger), false);
						sttParas.put(SharpChgItems.STDEV, tmp[3]);
						sttParas.put(SharpChgItems.STDEVRATIO, weightOfBeingLine[0]);
						sttParas.put(SharpChgItems.AREARATIO, tmp[4]);
						
						tmp = extLine.getLineStatisticParas(linesMap, firstChgPos-10, chgStopPos, imgGrays, lineIdx, evenLineLonger);
						sttParas.put(SharpChgItems.INNERGRAYRATIO, tmp[5]);
						sharpChgPosParas.put(start, sttParas);
					}
					tmp = extLine.getLineStatisticParas(linesMap, (start+stop)/2, stop, imgGrays, lineIdx, evenLineLonger);
					stdevRatio = tmp[3] / stdevRatio;
					
					statisticParas.put(SharpChgItems.STDEV, tmp[3]);
					statisticParas.put(SharpChgItems.STDEVRATIO, stdevRatio);
					statisticParas.put(SharpChgItems.AREARATIO, tmp[4]);
					statisticParas.put(SharpChgItems.INNERGRAYRATIO, tmp[5]);
					sharpChgPosParas.put(key, statisticParas);
					start = key;
				}
				extLine.setSharpChgPos(sharpChgPos);
				extLine.setSharpChgPosParas(sharpChgPosParas);
				
				if(logEnabled){
					LogUtils.rawLog("sharpChgGrays_", "X"+lineIdx+str1);
					LogUtils.rawLog("sharpChgGrays_", "S"+lineIdx+str2);
					for(int k=-5; k<=5; k++){
						LogUtils.rawLog("sharpChgGrays_", "G"+lineIdx+"("+k+")"+sGrays[k+5]);
					}
					LogUtils.rawLog("sharpChgPos_", extLine.printSharpChgPos(lineIdx));
				}
			}
		}
	}
	
	private double boundaryNewThreshold(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal, int boundaryIdx, int dblCfmDataPts){
		int imgWidth = imgGrays.length;
		int imgHeight = imgGrays[0].length;
		int counter1 = 0, nearCol = 0;
		
		double sumGray1 = 0.0, grayThr1 = lineFitGrayThr;
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		
		for(int k=boundaryIdx; k<imgWidth; k++){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(k<0 || nearCol<0 || nearCol>=imgHeight) continue;
			if(imgGrays[k][nearCol]<noiseGrayThr){
				counter1++;
				sumGray1 += imgGrays[k][nearCol];
			}
			if(counter1>=dblCfmDataPts) break;
		}
		if(counter1>0){
			grayThr1 = sumGray1 / counter1;
			grayThr1 = grayThr1 + (defaultVal - grayThr1)*0.25;
		}
		
		return grayThr1;
	}
	
	private boolean boundaryIsOK(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal, int boundaryIdx, int backwardPts, double grayThr1){
		boolean ok = false;
		int imgHeight = imgGrays[0].length;
		int nearCol = 0, continueCnt1 = 0;
		
		double minGray = 0.0;
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		
		for(int k=boundaryIdx; k>=boundaryIdx-backwardPts; k--){
			if(k<0) break;
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			
			//Check +/-1 tracks
			minGray = imgGrays[k][nearCol];
			if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
			if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
			
			if(minGray<grayThr1){
				if(continueCnt1<5) continueCnt1 = 0;
			}else{
				continueCnt1++;
			}
		}
		
		if(continueCnt1>=5) ok = true;
		return ok;
	}
	
	private ImgExtractLine setLineBoundary(ImgExtractLine extractLine, int[][] imgGrays, int defaultVal){
		int imgWidth = imgGrays.length;
		int imgHeight = imgGrays[0].length;
		int start = (int)(imgWidth*0.5);
		int counter1 = 0, counter2 = 0, nearCol = 0, contCntThr = 5;
		int continueCnt1 = 0, continueCnt2 = 0, minGray = 0, continueCnt3 = 0;
		double sumGray1 = 0.0, grayThr1 = lineFitGrayThr, newGrayThr1 = grayThr1;
		double sumGray2 = 0.0, grayThr2 = lineFitGrayThr, meanGray2 = 150.0, grayThr3 = noiseGrayThr2;
		
		double lineSlope = extractLine.getLineSlope();
		double lineOffset = extractLine.getLineIntercept();
		for(int k=start; k<imgWidth; k++){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			if(imgGrays[k][nearCol]<noiseGrayThr){
				counter1++;
				sumGray1 += imgGrays[k][nearCol];
			}
		}
		if(counter1>0){
			grayThr1 = sumGray1 / counter1;
			grayThr1 = grayThr1 + (defaultVal - grayThr1)*0.25;
		}
		
		for(int k=start; k>=0; k--){
			nearCol = (int)(k*lineSlope+lineOffset);
			if(nearCol<0 || nearCol>=imgHeight) continue;
			
			//Check +/-1 tracks
			minGray = imgGrays[k][nearCol];
			if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
			if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
			
			if(minGray<grayThr1){
				if(continueCnt1<contCntThr) continueCnt1 = 0;//Reset only when the X Axis Start is not found
			}else{
				continueCnt1++;
			}
			if(contCntThr==continueCnt1){
				newGrayThr1 = boundaryNewThreshold(extractLine,imgGrays,defaultVal,k+contCntThr,30);//Renew the threshold for a double confirmation
				if(boundaryIsOK(extractLine,imgGrays,defaultVal,k+contCntThr,contCntThr+2,newGrayThr1)){
					extractLine.setXAxisStart(k+contCntThr);
					extractLine.setMeanGray((int)grayThr1);
				}else{
					grayThr1 = newGrayThr1;
					continueCnt1 = 0;
				}
			}
			
			//To find X Axis Stop after X Axis Start is found
			if(contCntThr<=continueCnt1){
				counter2++;
				sumGray2 += imgGrays[k][nearCol];
				meanGray2 = sumGray2 / counter2;
				grayThr2 = (meanGray2 + defaultVal) / 2;
				
				minGray = imgGrays[k][nearCol];
				if(nearCol-1>=0 && imgGrays[k][nearCol-1]<minGray) minGray = imgGrays[k][nearCol-1];
				if(nearCol+1<imgHeight && imgGrays[k][nearCol+1]<minGray) minGray = imgGrays[k][nearCol+1];
				
				if(minGray>=grayThr2){
					continueCnt2++;
				}else{
					if(continueCnt2<contCntThr) continueCnt2=0;
				}
				
				if(minGray>=grayThr3){
					continueCnt3++;
				}else{
					if(continueCnt3<contCntThr) continueCnt3=0;
				}
				
				if(contCntThr<=continueCnt2 || contCntThr<=continueCnt3){
					extractLine.setXAxisStop(k+contCntThr);
					break;
				}
			}
		}
		
		return extractLine;
	}
	
	private ImgExtractLine getBaseLine(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int continueCnt = 0, minHeight = imgHeight, maxHeight = 0;
		int startY = 0, stopY = 0, contCntThr = 5, baseAvgPts = 10;
		int[][] startLine = new int[imgWidth][imgHeight];
		double baseGVal = 0.0, baseFactor = 0.9;
		String title = "", data = "";
		
		for(int i=0; i<imgWidth; i++){
			startLine[i] = imgGrays[i].clone();
		}
		
		int nearCol = 0;
		ImgExtractLine extractLine = new ImgExtractLine();
		LinkedHashMap<Integer,Integer> baseLineXY = new LinkedHashMap<Integer,Integer>();
		
		for(int i=(imgWidth-1); i>(int)(imgWidth*0.45); i-=10){
			continueCnt = 0; baseGVal = 0.0;
			for(int j=0; j<baseAvgPts; j++){
				baseGVal += imgGrays[i][j];
			}
			baseGVal = baseGVal / baseAvgPts * baseFactor;
			
			for(int j=baseAvgPts; j<imgHeight; j++){
				if(imgGrays[i][j]<baseGVal){
					continueCnt++;
				}else{
					baseGVal = 0.0;
					for(int k=j; k>j-baseAvgPts; k--){
						baseGVal += imgGrays[i][k];
					}
					baseGVal = baseGVal / baseAvgPts * baseFactor;
					continueCnt = 0;
				}
				if(continueCnt>=contCntThr){
					if(minHeight>(j-contCntThr)) minHeight = j-contCntThr;
					if(maxHeight<(j-contCntThr)) maxHeight = j-contCntThr;
					extractLine.addPoint(i, j-contCntThr, imgGrays[i][j-contCntThr]);
					baseLineXY.put(i, j-contCntThr);
					break;
				}
			}
		}
		extractLine.getLineCoef(false);
		
		//Fetch base line raw data
		if(logEnabled){
			if(baseLineXY.size()>0){
				startY = minHeight - 20;
				stopY = maxHeight + 30;
				if(startY<0) startY = 0;
				if(stopY>=imgHeight) stopY = imgHeight - 1;
				
				title = "x,y,rawY";
				for(int y=startY; y<=stopY; y++){
					title += "," + y;
				}
				LogUtils.rawLog("baseLineXY_",title);
				for(Integer key:baseLineXY.keySet()){
					data = key + "," + baseLineXY.get(key) + ",gray";
					for(int y=startY; y<=stopY; y++){
						data += "," + imgGrays[key][y];
					}
					LogUtils.rawLog("baseLineXY_",data);
				}
			}
			
			double startLineSlope = extractLine.getLineSlope();
			double startLineOffset = extractLine.getLineIntercept();
			for(int k=0; k<imgWidth; k++){
				nearCol = (int)(k*startLineSlope+startLineOffset);
				if(nearCol>=0 && nearCol<imgHeight) startLine[k][nearCol] = 0;
			}
			saveImgData("graysStartLine_",startLine);
		}
		
		return extractLine;
	}
	
	private ImgExtractLine getBaseLineBackup(int[][] peakVals, int[][] initVals, int[][] imgGrays, int defaultVal){
		int imgWidth = peakVals.length;
		int imgHeight = peakVals[0].length;
		int continueCnt = 0, minHeight = imgHeight, maxHeight = 0;
		int startY = 0, stopY = 0;
		int[][] startLine = new int[imgWidth][imgHeight];
		String title = "", data = "";
		
		for(int i=0; i<imgWidth; i++){
			startLine[i] = imgGrays[i].clone();
		}
		
		int nearCol = 0;
		ImgExtractLine extractLine = new ImgExtractLine();
		LinkedHashMap<Integer,Integer> baseLineXY = new LinkedHashMap<Integer,Integer>();
		
		for(int i=(imgWidth-1); i>(int)(imgWidth*0.45); i-=10){
			continueCnt = 0;
			for(int j=0; j<imgHeight; j++){
				if(imgGrays[i][j]<noiseGrayThr2){
					continueCnt++;
				}else{
					continueCnt = 0;
				}
				if(continueCnt>10){
					if(minHeight>(j-10)) minHeight = j-10;
					if(maxHeight<(j-10)) maxHeight = j-10;
					extractLine.addPoint(i, j-10, imgGrays[i][j-10]);
					baseLineXY.put(i, j-10);
					break;
				}
			}
		}
		
		//Fetch base line raw data
		if(baseLineXY.size()>0){
			startY = minHeight - 20;
			stopY = maxHeight + 30;
			if(startY<0) startY = 0;
			if(stopY>=imgHeight) stopY = imgHeight - 1;
			
			title = "x,y,rawY";
			for(int y=startY; y<=stopY; y++){
				title += "," + y;
			}
			LogUtils.rawLog("baseLineXY_",title);
			for(Integer key:baseLineXY.keySet()){
				data = key + "," + baseLineXY.get(key) + ",gray";
				for(int y=startY; y<=stopY; y++){
					data += "," + imgGrays[key][y];
				}
				LogUtils.rawLog("baseLineXY_",data);
			}
		}
		
		extractLine.getLineCoef(false);
		double startLineSlope = extractLine.getLineSlope();
		double startLineOffset = extractLine.getLineIntercept();
		for(int k=0; k<imgWidth; k++){
			nearCol = (int)(k*startLineSlope+startLineOffset);
			if(nearCol>=0 && nearCol<imgHeight) startLine[k][nearCol] = 0;
		}
		saveImgData("graysStartLine_",startLine);
		
		return extractLine;
	}
	
	private int[][] getPeakVals(int[][] imgGrays, int[][] initVals){
		int[][] peakVals = null;
		if(null != imgGrays){
			int row = imgGrays.length;
			int col = imgGrays[0].length;
			int scanPoints = 3;//Two sides scanning
			int positiveCnt = 0, negativeCnt = 0;
			peakVals = new int[row][col];
			if(col>5){
				for(int i=0; i<row; i++){
					peakVals[i] = initVals[i].clone();
					for(int j=scanPoints; j<col; j++){
						if((j+scanPoints)<col){
							positiveCnt = 0;
							negativeCnt = 0;
							for(int k=scanPoints; k>0; k--){
								if(imgGrays[i][j]>imgGrays[i][j-k] && imgGrays[i][j]>imgGrays[i][j+k]){
									positiveCnt++;
								}
								
								if(imgGrays[i][j]<imgGrays[i][j-k] && imgGrays[i][j]<imgGrays[i][j+k]){
									negativeCnt++;
								}
							}
							if(negativeCnt==scanPoints){
								peakVals[i][j] = imgGrays[i][j];
								j += scanPoints;
							}
							if(positiveCnt==scanPoints) j += scanPoints;
						}else{
							break;
						}
					}
				}
			}
		}
		
		if(null!=peakVals) saveImgData("graysPeakVals_",peakVals);
		return peakVals;
	}
	
	private void saveImgData(String filePrefix, int[][] data){
		if(logEnabled){
			int width = data.length;
			int height = data[0].length;
			String str = "";
			
	    	for (int i = 0; i < width; i++) {
	        	str = "";
	            for (int j = (height-1); j >= 0; j--) {
	                str += data[i][j]+",";
	            }
	            LogUtils.rawLog(filePrefix,str);
	        }
		}
	}
	
	private void saveSearchingLines(int[][] data, double slope, double offset, int index, String flag){
		if(logEnabled){
			int imgWidth = data.length, imgHeight = data[0].length, nearCol = 0;
			for(int k=0; k<imgWidth; k++){
				nearCol = (int)(k*slope+offset);
				if(nearCol>=0 && nearCol<imgHeight){
					if(data[k][nearCol]>230) data[k][nearCol] = 0;
				}
			}
			saveImgData("graysSeachingLine_"+flag+"_"+index+"_",data);
		}
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2019-03-31 15:09:55.018
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:55.018
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2019-03-31 15:09:55.018
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:140)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:810)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1067)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4760)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4727)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:768)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:679)
	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:274)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1023)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
